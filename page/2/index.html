<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Tianchi's Blog</title><meta name="description" content="南大计算机科学与技术系小学生，程序猿"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/long.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://itanch.github.io/atom.xml" title="Tianchi's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/long.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ITanCh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-11-Android的InputManagerService的工作过程/" class="post-title-link">Android系统源码阅读(11):Android的InputManagerService的工作过程</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><blockquote>
<p>请对照AOSP版本：6.0.1_r50。  </p>
</blockquote>
<h2 id="1-创建InputManager"><a href="#1-创建InputManager" class="headerlink" title="1. 创建InputManager"></a>1. 创建InputManager</h2><p>这里和老罗当年的版本有很大不同了，有了InputManagerService管理InputManager。</p>
<p><img src="http://img.blog.csdn.net/20160921173810675" alt="这里写图片描述"></p></div><a href="/2017/02/14/Android系统源码阅读-11-Android的InputManagerService的工作过程/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android-Monkey-源代码阅读/" class="post-title-link">Android Monkey 源代码阅读</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><h2 id="0-Monkey基本信息"><a href="#0-Monkey基本信息" class="headerlink" title="0. Monkey基本信息"></a>0. Monkey基本信息</h2><p>目前该工具位于源代码的位置：<code>development/cmds/monkey</code>。</p>
<p>生成的jar包位于：<code>out/traget/product/generic/system/framework/monkey.jar</code>。</p>
<p>在设备中，启动monkey的脚本位于<code>/system/bin/monkey</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Script to start "monkey" on the device, which has a very rudimentary</span></div><div class="line"><span class="comment"># shell.</span></div><div class="line"><span class="comment">#</span></div><div class="line">base=/system</div><div class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$base</span>/framework/monkey.jar</div><div class="line"><span class="built_in">trap</span> <span class="string">""</span> HUP</div><div class="line"><span class="built_in">exec</span> app_process <span class="variable">$base</span>/bin com.android.commands.monkey.Monkey $*</div></pre></td></tr></table></figure></p></div><a href="/2017/02/14/Android-Monkey-源代码阅读/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-10-Android应用程序的消息处理机制/" class="post-title-link">Android系统源码阅读(10):Android应用程序的消息处理机制</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote>
<p>原来写好的博客被CSDN给坑了，法克，只能靠回忆重写。    </p>
</blockquote>
<ol>
<li>Android应用程序的四种组件皆运行于ActivityThread之中。ActivityThread包含有程序入口main，同时它会启动一个循环，这个循环会轮询消息队列，来处理发送给它的消息。而四种组件则被这个线程统一管理。所以，ActivityThread这个线程是一个动态的过程，像一个无休止的转动的法条，而四个组件则像是被驱动四个齿轮，需要它们转动时才会在法条的带动下进行转动。</li>
<li>主线程中有一个Looper，Looper是一个循环，其中又有一个MessageQueue来管理消息队列。MessageQueue又有一个mPtr变量，记录了c++层对应的NativeMessageQueue的位置。NativeMessageQueue也有一个c++层的Looper，它负责管理pip，而pip则是进程间通信的通道。 </li>
</ol></div><a href="/2017/02/14/Android系统源码阅读-10-Android应用程序的消息处理机制/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-9-ContentProvider数据更新通知/" class="post-title-link">Android系统源码阅读(9):ContentProvider数据更新通知</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><h2 id="1-用户注册内容观察者"><a href="#1-用户注册内容观察者" class="headerlink" title="1. 用户注册内容观察者"></a><em>1.</em> 用户注册内容观察者</h2><p><img src="http://img.blog.csdn.net/20160908190740714" alt="这里写图片描述"></p>
<ol>
<li>用户（比如一个Activity）想要实时获得某项内容的变化，需要注册相应的观察者。这个观察者可以自定，但是需要继承<code>ContentObserver</code>类，这个类的构造函数需要一个Handle参数，这个Handle就是用来向用户发送数据变化消息的。然后将observer作为参数，利用ContentResolver的这个函数进行注册。</li>
<li>在1.1中想要注册observer，首先要利用该步骤获取<code>ContentService</code>。ContentService是一个系统服务，由ServiceManager管理。这一步获取的实际上市ContentService的Binder代理对象。</li>
<li>在1.1中注册的observer实际传递的是observer的Transport类型的Binder代理对象，所以这一步要从observer中获得这个transport。</li>
<li>这一步为进程间函数调用。这一步会将observer加入到mRootNode中，因为ContentService用一棵树来维护所有注册到这里的观测者。用树结构是因为URI天然的树状结构。</li>
<li>这个函数是一个在树上寻找和添加节点的递归函数。在按照URI的层次结构寻找目标节点时，可能会创造新的节点。直到匹配了最后的节点，将observer封装在ObserverEntry中，添加进该节点。</li>
</ol></div><a href="/2017/02/14/Android系统源码阅读-9-ContentProvider数据更新通知/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-8-ContentProvider数据传输过程/" class="post-title-link">Android系统源码阅读(8):ContentProvider数据传输过程</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><blockquote>
<p>该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 </p>
</blockquote>
<h2 id="1-用户开始查询"><a href="#1-用户开始查询" class="headerlink" title="1. 用户开始查询"></a><em>1</em>. 用户开始查询</h2><p><img src="http://img.blog.csdn.net/20160905214338676" alt="这里写图片描述"></p>
<ol>
<li>用户调用<code>query</code>函数进行查询。首先尝试获得provider，这里分为两种，先是unstable，后是stable，暂时没有分清这两者之间的区别。在尝试获取Provider的过程中，将会类似于第7篇文章中的过程。这里假设该用户已经有该provider的记录，获取过程见1.2。在取得provider后，见1.5。</li>
<li>继续获取Provider。</li>
<li>继续获取Provider。</li>
<li>ActivityThread将所有已经获得的Provider放在mProviderMap中。这里假设需要获取的Provider存在，返回一个<code>IContentProvider</code>类型的provider，这个接口指向了Content Provider的一个Transport代理对象，即ContentProviderProxy对象。</li>
<li>使用provider的代理进行查询。这里会创建一个<code>BulkCursorToCursorAdaptor</code>对象。该版本没有创建CursorWindow对象，即没有创建匿名内存，和旧版本有些区别。那么，新版本中在哪里创建共享的内存区呢？最后，准备通过进程间通信发送消息，等待返回的BulkCursorDescriptor，然后可以获得对应的BulkCursorToCursorAdaptor，即一个AbstractWindowedCursor。</li>
</ol></div><a href="/2017/02/14/Android系统源码阅读-8-ContentProvider数据传输过程/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-7-ContentProvider的启动/" class="post-title-link">Android系统源码阅读(7):Content Provider的启动</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><blockquote>
<p>该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。   </p>
</blockquote>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ul>
<li>Content Provider运行在一个独立的应用程序进程中，它本事就是一个Android应用程序。</li>
<li>Binder进程间通信只适合传递体积较小的数据结构，不适合大量数据的传输。所以需要采用匿名共享内存来传输体积较大的数据。</li>
<li>Cursor对象通过匿名共享内存来传输数据，而Bundle是通过Binder传递数据。</li>
</ul></div><a href="/2017/02/14/Android系统源码阅读-7-ContentProvider的启动/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-6-广播机制/" class="post-title-link">Android系统源码阅读(6)广播机制</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><h1 id="Android系统源码阅读（6）：广播机制"><a href="#Android系统源码阅读（6）：广播机制" class="headerlink" title="Android系统源码阅读（6）：广播机制"></a>Android系统源码阅读（6）：广播机制</h1><blockquote>
<p>该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。    </p>
</blockquote>
<h2 id="注册广播接收器"><a href="#注册广播接收器" class="headerlink" title="注册广播接收器"></a>注册广播接收器</h2><h3 id="Step1-Activity开始注册"><a href="#Step1-Activity开始注册" class="headerlink" title="Step1. Activity开始注册"></a>Step1. Activity开始注册</h3><p><img src="http://img.blog.csdn.net/20160821154639757" alt="这里写图片描述"></p></div><a href="/2017/02/14/Android系统源码阅读-6-广播机制/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-5-Service在进程内绑定/" class="post-title-link">Android系统源码阅读(5):Service在进程内绑定</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><h1 id="Android系统源码阅读（5）：Service在进程内绑定"><a href="#Android系统源码阅读（5）：Service在进程内绑定" class="headerlink" title="Android系统源码阅读（5）：Service在进程内绑定"></a>Android系统源码阅读（5）：Service在进程内绑定</h1><blockquote>
<p>该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 </p>
</blockquote>
<h2 id="Step1-Activity开始启动Service"><a href="#Step1-Activity开始启动Service" class="headerlink" title="Step1. Activity开始启动Service"></a>Step1. Activity开始启动Service</h2><p><img src="http://img.blog.csdn.net/20160818225346176" alt="这里写图片描述"></p></div><a href="/2017/02/14/Android系统源码阅读-5-Service在进程内绑定/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-4-Service在新进程中启动过程/" class="post-title-link">Android系统源码阅读(4):Service在新进程中启动过程</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><h1 id="Android系统源码阅读（4）：Service在新进程中启动过程"><a href="#Android系统源码阅读（4）：Service在新进程中启动过程" class="headerlink" title="Android系统源码阅读（4）：Service在新进程中启动过程"></a>Android系统源码阅读（4）：Service在新进程中启动过程</h1><blockquote>
<p>该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。   </p>
</blockquote>
<h2 id="Step1-Activity开始启动Service"><a href="#Step1-Activity开始启动Service" class="headerlink" title="Step1. Activity开始启动Service"></a>Step1. Activity开始启动Service</h2><p><img src="http://img.blog.csdn.net/20160818135053514" alt="这里写图片描述">  </p></div><a href="/2017/02/14/Android系统源码阅读-4-Service在新进程中启动过程/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/14/Android系统源码阅读-3-子Activity在进程内的启动过程/" class="post-title-link">Android系统源码阅读(3):子Activity在进程内的启动过程</a></h2><div class="post-info">Feb 14, 2017</div><div class="post-content"><blockquote>
<p>该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。</p>
</blockquote>
<h2 id="子Activity在进程内的启动过程"><a href="#子Activity在进程内的启动过程" class="headerlink" title="子Activity在进程内的启动过程"></a>子Activity在进程内的启动过程</h2><h3 id="Step1-Activity开始启动另一个Activity"><a href="#Step1-Activity开始启动另一个Activity" class="headerlink" title="Step1. Activity开始启动另一个Activity"></a>Step1. Activity开始启动另一个Activity</h3><p><img src="http://img.blog.csdn.net/20160817155832276" alt="这里写图片描述"><br>这里和从Launcher启动过程几乎没分别，但是启动有些参数的设置还是有区别的。</p></div><a href="/2017/02/14/Android系统源码阅读-3-子Activity在进程内的启动过程/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">PREV</a><a href="/page/3/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2017 <a href="http://itanch.github.io">Tian chi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>