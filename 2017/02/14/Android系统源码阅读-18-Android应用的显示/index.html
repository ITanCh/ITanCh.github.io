<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android系统源码阅读(18):Android应用的显示 · Tianchi's Blog</title><meta name="description" content="Android系统源码阅读(18):Android应用的显示 - Tian chi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://itanch.github.io/atom.xml" title="Tianchi's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android系统源码阅读(18):Android应用的显示</h1><div class="post-info">Feb 14, 2017</div><div class="post-content"><h2 id="1-启动ActivityManagerService"><a href="#1-启动ActivityManagerService" class="headerlink" title="1. 启动ActivityManagerService"></a>1. 启动ActivityManagerService</h2><p>在前面第14章讲到，在System进程启动时，会启动系统的一些基本服务。启动就有ActivityManagerService和PackageManagerService。在SystemServer中如下启动ActivityManagerService。</p>
<p><em>frameworks/base/services/java/com/android/server/SystemServer.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Activity manager runs the show.</span></div><div class="line">mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService();</div></pre></td></tr></table></figure>   </p>
<p>startService就是创建了ActivityManagerService的实例对象mActivityManagerService，然后启动了ActivityManagerService的looper线程。在SystemServer启动了基本服务后，就会调用mActivityManagerService的systemReady函数来启动HomeActivity。<br><a id="more"></a></p>
<h2 id="2-启动HomeActivity"><a href="#2-启动HomeActivity" class="headerlink" title="2. 启动HomeActivity"></a>2. 启动HomeActivity</h2><p>目前仍在SystemServer主线程中调用的systemReady函数。该函数又会接着调用startHomeActivityLocked函数来启动HomeActivity，具体如下：</p>
<p><em>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</em>  :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</div><div class="line">      <span class="comment">//...</span></div><div class="line">      <span class="comment">//先创建一个启动Home的Intent，Intent的category为android.intent.category.home</span></div><div class="line">      Intent intent = getHomeIntent();</div><div class="line">      ActivityInfo aInfo =</div><div class="line">          resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</div><div class="line">      <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</div><div class="line">          intent.setComponent(<span class="keyword">new</span> ComponentName(</div><div class="line">                  aInfo.applicationInfo.packageName, aInfo.name));</div><div class="line">          <span class="comment">// Don't do this if the home app is currently being</span></div><div class="line">          <span class="comment">// instrumented.</span></div><div class="line">          aInfo = <span class="keyword">new</span> ActivityInfo(aInfo);</div><div class="line">          aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</div><div class="line">          <span class="comment">//因为是第一次启动home，所以还没有相应的进程，所以app为null</span></div><div class="line">          ProcessRecord app = getProcessRecordLocked(aInfo.processName,</div><div class="line">                  aInfo.applicationInfo.uid, <span class="keyword">true</span>);</div><div class="line">          <span class="keyword">if</span> (app == <span class="keyword">null</span> || app.instrumentationClass == <span class="keyword">null</span>) &#123;</div><div class="line">              intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">              <span class="comment">//这里开始启动HomeActivity</span></div><div class="line">              mStackSupervisor.startHomeActivity(intent, aInfo, reason);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>   </p>
<p>这里交给了mStackSupervisor.startHomeActivity函数来启动HomeActivity，然后就会调用startActivityLocked函数。到这里，就开始重复第2章中，启动普通应用的activity的过程了，不再赘述。其中，在Launcher的Manifest中指明了它的类型为android.intent.category.home，所以启动的就是Laucher应用。</p>
<h2 id="3-Launcher展示应用"><a href="#3-Launcher展示应用" class="headerlink" title="3. Launcher展示应用"></a>3. Launcher展示应用</h2><p>下面从Launcher的onCreate函数开始讲起，部分代码如下：</p>
<p><em>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">LauncherAppState app = LauncherAppState.getInstance();</div><div class="line"><span class="comment">//将该launcher设置为mModel的callback函数</span></div><div class="line">mModel = app.setLauncher(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!mRestoring) &#123;</div><div class="line">    <span class="keyword">if</span> (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) &#123;</div><div class="line">        <span class="comment">// If the user leaves launcher, then we should just load items asynchronously when</span></div><div class="line">        <span class="comment">// they return.</span></div><div class="line">        mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// We only load the page synchronously if the user rotates (or triggers a</span></div><div class="line">        <span class="comment">// configuration change) while launcher is in the foreground</span></div><div class="line">        <span class="comment">//开始加载应用信息</span></div><div class="line">        mModel.startLoader(mWorkspace.getRestorePage());</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>其中mModel是一个LauncherModel对象，它负责加载应用信息。在重载的startLoader函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLoader</span><span class="params">(<span class="keyword">int</span> synchronousBindPage, <span class="keyword">int</span> loadFlags)</span> </span>&#123;</div><div class="line">       <span class="comment">//...</span></div><div class="line">       <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">           <span class="comment">//...</span></div><div class="line">           <span class="comment">// Don't bother to start the thread if we know it's not going to do anything</span></div><div class="line">           <span class="keyword">if</span> (mCallbacks != <span class="keyword">null</span> &amp;&amp; mCallbacks.get() != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">//需要重新加载了，所以先把原来的加载任务停了</span></div><div class="line">               <span class="comment">// If there is already one running, tell it to stop.</span></div><div class="line">               stopLoaderLocked();</div><div class="line">               <span class="comment">//创建了一个加载任务</span></div><div class="line">               mLoaderTask = <span class="keyword">new</span> LoaderTask(mApp.getContext(), loadFlags);</div><div class="line">               <span class="keyword">if</span> (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE</div><div class="line">                   <span class="comment">//...</span></div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="comment">//交给workThread来处理这个任务</span></div><div class="line">                   sWorkerThread.setPriority(Thread.NORM_PRIORITY);</div><div class="line">                   <span class="comment">//sWorker是sWorkerThread的Handler</span></div><div class="line">                   sWorker.post(mLoaderTask);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>   
<p>因为加载所有安装的应用信息是一个比较耗时的过程，所以应该交给一个异步线程来处理。这里先创建了一个加载任务mLoaderTask，然后将它交给sWorkerThread来处理。sWorkerThread是一个HandlerThread，我们知道HandlerThread是一个独立的线程，并且有着自己的looper。mLoaderTask加载任务执行一次就可以结束，但是为什么需要用一个HandlerThread在这里不断等待着其它任务呢？因为桌面上应用可以动态的添加和删除，所以应用的加载可能是频繁的。这里使用HandlerThread可以避免重复的创建加载线程。</p>
<p>下面我们就看LoaderTask.run函数中具体做了哪些任务。</p>
<p><em>packages/apps/Launcher3/src/com/android/launcher3/LauncherModel.java</em>  :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">          <span class="keyword">if</span> (mStopped) &#123;</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line">          mIsLoaderTaskRunning = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Optimize for end-user experience: if the Launcher is up and // running with the</span></div><div class="line">      <span class="comment">// All Apps interface in the foreground, load All Apps first. Otherwise, load the</span></div><div class="line">      <span class="comment">// workspace first (default).</span></div><div class="line">      keep_running: &#123;</div><div class="line">          <span class="keyword">if</span> (DEBUG_LOADERS) Log.d(TAG, <span class="string">"step 1: loading workspace"</span>);</div><div class="line">          <span class="comment">//启动workspace</span></div><div class="line">          loadAndBindWorkspace();</div><div class="line">          <span class="keyword">if</span> (mStopped) &#123;</div><div class="line">              <span class="keyword">break</span> keep_running;</div><div class="line">          &#125;</div><div class="line">          waitForIdle();</div><div class="line">          <span class="comment">// second step</span></div><div class="line">          <span class="keyword">if</span> (DEBUG_LOADERS) Log.d(TAG, <span class="string">"step 2: loading all apps"</span>);</div><div class="line">          <span class="comment">//加载应用</span></div><div class="line">          loadAndBindAllApps();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//...</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>   </p>
<p>WorkSpace就是Android桌面中的分屏，每个分屏有若干应用。先加载工作区，再加载应用更符合用户的心理预期？函数loadAndBindAllApps会判断是否已经加载过应用，如果已经加载过信息，则直接将app显示在桌面上即可；如果没有，则需要先调用函数loadAllApps，具体内容如下：</p>
<p><em>packages/apps/Launcher3/src/com/android/luancher3/LauncherModel.java</em>  :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAllApps</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">final</span> Callbacks oldCallbacks = mCallbacks.get();</div><div class="line"></div><div class="line">           <span class="comment">// Clear the list of apps</span></div><div class="line">           mBgAllAppsList.clear();</div><div class="line">           <span class="keyword">for</span> (UserHandleCompat user : profiles) &#123;</div><div class="line">               <span class="comment">// Query for the set of apps</span></div><div class="line">               <span class="comment">//获取所有的app信息，这里最终还是从PackageManagerService获取的应用信息</span></div><div class="line">               <span class="keyword">final</span> List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(<span class="keyword">null</span>, user);</div><div class="line">        </div><div class="line">               <span class="comment">// Create the ApplicationInfos</span></div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; apps.size(); i++) &#123;</div><div class="line">                   LauncherActivityInfoCompat app = apps.get(i);</div><div class="line">                   <span class="comment">//把每个应用信息封装成AppInfo</span></div><div class="line">                   <span class="comment">// This builds the icon bitmaps.</span></div><div class="line">                   mBgAllAppsList.add(<span class="keyword">new</span> AppInfo(mContext, app, user, mIconCache));</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//...</span></div><div class="line">           <span class="comment">// Huh? Shouldn't this be inside the Runnable below?</span></div><div class="line">           <span class="keyword">final</span> ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;</div><div class="line">           mBgAllAppsList.added = <span class="keyword">new</span> ArrayList&lt;AppInfo&gt;();</div><div class="line">            </div><div class="line">           <span class="comment">//这里一直运行在Launcher中创建的一个HandlerThread子线程中</span></div><div class="line">           <span class="comment">//获取了应用信息后，需要通知主线程进行ui更新，mHandler是主线程的Handler</span></div><div class="line">           <span class="comment">// Post callback on main thread</span></div><div class="line">           mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                   <span class="comment">//这个callback就是launcher</span></div><div class="line">                   <span class="keyword">final</span> Callbacks callbacks = tryGetCallbacks(oldCallbacks);</div><div class="line">                   <span class="keyword">if</span> (callbacks != <span class="keyword">null</span>) &#123;</div><div class="line">                      <span class="comment">//显示所有应用</span></div><div class="line">                       callbacks.bindAllApplications(added);</div><div class="line">                      <span class="comment">//...</span></div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">//...</span></div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">           <span class="comment">//...</span></div><div class="line">       &#125;</div></pre></td></tr></table></figure>   </p>
<p>mLauncherApps.getActivityList获取app信息的方法是通过向PackageManager发送请求的方式实现的。下面回到Launcher主线程，开始显示应用图标。首先看一眼这个回调函数：</p>
<p><em>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Add the icons for all apps.</div><div class="line">  *</div><div class="line">  * Implementation of the method from LauncherModel.Callbacks.</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindAllApplications</span><span class="params">(<span class="keyword">final</span> ArrayList&lt;AppInfo&gt; apps)</span> </span>&#123;</div><div class="line">     <span class="comment">//...</span></div><div class="line">     <span class="keyword">if</span> (mAppsView != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="comment">//mAppsView管理着所有应用的view</span></div><div class="line">         mAppsView.setApps(apps);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//...</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>   </p>
<p>mAppsView是一个view的容器，维持了一个AlphabeticalAppsList列表，保存应用的信息。当向其中添加新的应用信息后，会对home上的应用进行更新。当home上的图标被点击后，会触发启动该应用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/14/写在2017的开始/" class="prev">PREV</a><a href="/2017/02/14/Android系统源码阅读-17-Android应用的安装/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://itanch.github.io">Tian chi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>