<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android系统源码阅读(11):Android的InputManagerService的工作过程 · Tianchi's Blog</title><meta name="description" content="Android系统源码阅读(11):Android的InputManagerService的工作过程 - Tian chi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/long_round.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://itanch.github.io/atom.xml" title="Tianchi's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/long_round.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ITanCh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android系统源码阅读(11):Android的InputManagerService的工作过程</h1><div class="post-info">Feb 14, 2017</div><div class="post-content"><blockquote>
<p>请对照AOSP版本：6.0.1_r50。  </p>
</blockquote>
<h2 id="1-创建InputManager"><a href="#1-创建InputManager" class="headerlink" title="1. 创建InputManager"></a>1. 创建InputManager</h2><p>这里和老罗当年的版本有很大不同了，有了InputManagerService管理InputManager。</p>
<p><img src="http://img.blog.csdn.net/20160921173810675" alt="这里写图片描述"></p>
<a id="more"></a>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>想要探索如何启动的相关server，需要从SystemServer开始探寻。从SystemServer的进程开始运行开始，它就会创建一些系统server，这里就会启动other services。</p>
<p>其中，会创建Input Manager和Window Manager两个服务。</p>
<p><em>frameworks/base/services/java/com/android/server/SystemServer.java :</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Slog.i(TAG, <span class="string">"Input Manager"</span>);</div><div class="line">inputManager = <span class="keyword">new</span> InputManagerService(context);</div><div class="line"></div><div class="line">Slog.i(TAG, <span class="string">"Window Manager"</span>);</div><div class="line">wm = WindowManagerService.main(context, inputManager,</div><div class="line">		mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</div><div class="line">		!mFirstBoot, mOnlyCore);</div><div class="line">ServiceManager.addService(Context.WINDOW_SERVICE, wm);</div><div class="line">ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</div><div class="line"><span class="comment">//..</span></div><div class="line">inputManager.start();</div></pre></td></tr></table></figure></p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>先来仔细端详一下InputManagerService的构造函数。这里会调用c++层的初始化函数。<br><em>frameworks/base/services/core/java/com/android/server/input/InputManagerService.java :</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper);</div><div class="line"><span class="comment">//..</span></div><div class="line">mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</div></pre></td></tr></table></figure></p>
<p>注意这里将DisplayThread的Looper传递过去，DisplayThread是一个单例模式的类，它会启动唯一的线程。同时DisplayThread是一个HandlerThread的子类，实现了Looper循环机制。DisplayThread是用来执行和显示有关的操作，显示操作一般需要比较小的延迟。DisplayThread只能被WindowManager、DisplayManager，InputManager用来执行一些快速地实时操作。</p>
<h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p>这一步首先将java层的MessageQueue变为了c++的MessageQueue。然后构造了一个NativeInputManager对象，最后将指向该对象的指针<code>im</code>返回给java层。</p>
<p><em>frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj, messageQueue-&gt;getLooper());</div></pre></td></tr></table></figure></p>
<h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><p>在构造NativeInputManager时，会创建一个InputManager对象mInputManager。</p>
<p><em>frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</div><div class="line">mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><p>这一步会创建一个dispatcher负责分发输入事件，一个reader负责获取事件。<br><em>frameworks/native/services/inputflinger/InputManager.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</div><div class="line">mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</div><div class="line">initialize();</div></pre></td></tr></table></figure></p>
<h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><p>这里会创建两个线程，在以后的步骤中会用来运行前面创建的dispathcer和reader。</p>
<p><em>frameworks/native/services/inputflinger/InputManager.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</div><div class="line">mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</div></pre></td></tr></table></figure></p>
<h2 id="2-启动InputManager"><a href="#2-启动InputManager" class="headerlink" title="2. 启动InputManager"></a>2. 启动InputManager</h2><p>将视线再次回到SystemServer中，在创建完InputManagerService后，需要将这个Service启动，同样是在1.1的startOtherServices函数里，调用了InputManagerService的成员函数start。</p>
<p><img src="http://img.blog.csdn.net/20160921173838750" alt="这里写图片描述"></p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>这里首先调用了c++层的nativeStart，然后InputManagerService将自己交给Watchdog监视。然后注册了PointerSpeedSetting和ShowTouchesSetting两个Observer。</p>
<p><em>frameworks/base/services/core/java/com/android/server/input/InputManagerService.java :</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">nativeStart(mPtr);</div><div class="line"></div><div class="line"><span class="comment">// Add ourself to the Watchdog monitors.</span></div><div class="line">Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">registerPointerSpeedSettingObserver();</div><div class="line">registerShowTouchesSettingObserver();</div></pre></td></tr></table></figure></p>
<p>这两个Observer暂时还没搞清楚是干什么的。</p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><p>这一步将传来的ptr参数转化为一个NativeInputManager指针，同时开始启动NativeInputManager中的InputManager。</p>
<p><em>frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</div><div class="line"><span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</div></pre></td></tr></table></figure></p>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><p>这里会启动在1.6中创建的两个线程，分别用来分发和监听Input事件。</p>
<p><em>frameworks/native/services/inputflinger/InputManager.cpp ：</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</div><div class="line">result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);)</div></pre></td></tr></table></figure></p>
<h2 id="3-启动InputDispatcher"><a href="#3-启动InputDispatcher" class="headerlink" title="3. 启动InputDispatcher"></a>3. 启动InputDispatcher</h2><p>在2.3中运行的线程以threadLoop为入口，开始进入循环。</p>
<p><img src="http://img.blog.csdn.net/20160921173903504" alt="这里写图片描述"></p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><p>这一步直接将任务交给InputDispatcher的dispatchOnce函数。</p>
<p><em>frameworks/native/services/inputflinger/InputDispatcher.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</div><div class="line">	mDispatcher-&gt;dispatchOnce();</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p>整个函数如下：</p>
<p><em>frameworks/native/services/inputflinger/InputDispatcher.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</div><div class="line"></div><div class="line">	<span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// acquire lock</span></div><div class="line">		AutoMutex _l(mLock);</div><div class="line">		mDispatcherIsAliveCondition.broadcast();</div><div class="line"></div><div class="line">		<span class="comment">// Run a dispatch loop if there are no pending commands.</span></div><div class="line">		<span class="comment">// The dispatch loop might enqueue commands to run afterwards.</span></div><div class="line">		<span class="keyword">if</span> (!haveCommandsLocked()) &#123;</div><div class="line">			dispatchOnceInnerLocked(&amp;nextWakeupTime);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Run all pending commands if there are any.</span></div><div class="line">		<span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></div><div class="line">		<span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</div><div class="line">			nextWakeupTime = LONG_LONG_MIN;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="comment">// release lock</span></div><div class="line"></div><div class="line">	<span class="keyword">nsecs_t</span> currentTime = now();</div><div class="line">	<span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</div><div class="line">	mLooper-&gt;pollOnce(timeoutMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在这一步骤中，首先判断是否有Command还未被执行，如果有去执行Command。否则，调用dispatchOnceInnerLocked函数去获取事件，这里会将nextWakeupTime传递过去，让其设置合适的苏醒时间，具体内容在以后讲解。然后runCommandsLockedInterruptible函数会执行缓存的Command，如果有Command在这一步中被执行，则需要将苏醒事件设置为<code>LONG_LONG_MIN</code>，因为执行这些命令需要耗费事件，在这期间可能已经有输入事件发生了，所有下次循环不需要等待。</p>
<p>最后，根据等待时间和当前时间，计算出需要睡眠的时间，通过pollOnce进入睡眠，等待唤醒，或者超时。</p>
<h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p>这里和上一个章节中的pollOnce道理相同。</p>
<h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>这里会调用epoll_wait函数，使其在mEpollFd所描述的epoll上等待一段时间，这个epoll监听着文件描述符的读写事件。如果有人在pip中写入，则会返回，否则等待指定时间后返回。</p>
<p><em>system/core/libutils/Looper.cpp</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div></pre></td></tr></table></figure></p>
<h2 id="4-启动InputReader"><a href="#4-启动InputReader" class="headerlink" title="4. 启动InputReader"></a>4. 启动InputReader</h2><p>在2.3中运行的线程以threadLoop为入口，开始进入循环。</p>
<p><img src="http://img.blog.csdn.net/20160921173918126" alt="这里写图片描述"></p>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><p>这一步与3.1一样，将任务丢给InputReader处理。</p>
<h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p>这一步会尝试从mEventHub中获取事件，如果获取一些事件，则进行处理。<br><em>frameworks/native/services/inputflinger/InputReader.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从EventHub中获取event，这里先详细讲解这一步</span></div><div class="line"><span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</div><div class="line"><span class="comment">//省略..</span></div><div class="line"><span class="keyword">if</span> (count) &#123;</div><div class="line">	<span class="comment">//事件处理，将在后面博客中讲解</span></div><div class="line">	processEventsLocked(mEventBuffer, count);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这里我们先考虑如何从EventHub中获取事件的。</p>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><p>首先这一个函数不是就获得一个event这么简单，它是想获得一组event，这里和旧版本有所不同，可见工程师对系统做了优化。这一步内容比较到，让我们通过注释来讲解。</p>
<p><em>frameworks/native/services/inputflinger/EventHub.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis, RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</div><div class="line">    ALOG_ASSERT(bufferSize &gt;= <span class="number">1</span>);</div><div class="line">    AutoMutex _l(mLock);</div><div class="line">    <span class="keyword">struct</span> input_event readBuffer[bufferSize];</div><div class="line">    <span class="comment">//event 指向了存储事件的位置</span></div><div class="line">    RawEvent* event = buffer;</div><div class="line">    <span class="keyword">size_t</span> capacity = bufferSize;</div><div class="line">    <span class="keyword">bool</span> awoken = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">//开始循环获取事件,目的是填充buffer</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class="line"></div><div class="line">        <span class="comment">// Reopen input devices if needed.</span></div><div class="line">        <span class="comment">//如果需要重新打开输入设备，则首先要关闭所有的设备</span></div><div class="line">        <span class="keyword">if</span> (mNeedToReopenDevices) &#123;</div><div class="line">            mNeedToReopenDevices = <span class="literal">false</span>;</div><div class="line">            ALOGI(<span class="string">"Reopening all input devices due to a configuration change."</span>);</div><div class="line">            closeAllDevicesLocked();</div><div class="line">            mNeedToScanDevices = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">break</span>; <span class="comment">// return to the caller before we actually rescan</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Report any devices that had last been added/removed.</span></div><div class="line">        <span class="comment">//这里会移除所有关闭的设备</span></div><div class="line">        <span class="keyword">while</span> (mClosingDevices) &#123;</div><div class="line">            Device* device = mClosingDevices;</div><div class="line">            ALOGV(<span class="string">"Reporting device closed: id=%d, name=%s\n"</span>,</div><div class="line">                 device-&gt;id, device-&gt;path.<span class="built_in">string</span>());</div><div class="line">            mClosingDevices = device-&gt;next;</div><div class="line">            <span class="comment">//创建了一个设备removed的event</span></div><div class="line">            event-&gt;when = now;</div><div class="line">            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device-&gt;id;</div><div class="line">            event-&gt;type = DEVICE_REMOVED;</div><div class="line">            event += <span class="number">1</span>;</div><div class="line">            <span class="keyword">delete</span> device;</div><div class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">	<span class="comment">//如果上面步骤关闭了设备，这里需要重新扫描所有的设备</span></div><div class="line">        <span class="keyword">if</span> (mNeedToScanDevices) &#123;</div><div class="line">            mNeedToScanDevices = <span class="literal">false</span>;</div><div class="line">            <span class="comment">//下面会详细讲解这里如何获取输入设备的</span></div><div class="line">            scanDevicesLocked();</div><div class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">	<span class="comment">//这里会添加正在开启的设备</span></div><div class="line">        <span class="keyword">while</span> (mOpeningDevices != <span class="literal">NULL</span>) &#123;</div><div class="line">            Device* device = mOpeningDevices;</div><div class="line">            ALOGV(<span class="string">"Reporting device opened: id=%d, name=%s\n"</span>,</div><div class="line">                 device-&gt;id, device-&gt;path.<span class="built_in">string</span>());</div><div class="line">            mOpeningDevices = device-&gt;next;</div><div class="line">            <span class="comment">//同样这里会创建设备添加的event</span></div><div class="line">            event-&gt;when = now;</div><div class="line">            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="number">0</span> : device-&gt;id;</div><div class="line">            event-&gt;type = DEVICE_ADDED;</div><div class="line">            event += <span class="number">1</span>;</div><div class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mNeedToSendFinishedDeviceScan) &#123;</div><div class="line">            mNeedToSendFinishedDeviceScan = <span class="literal">false</span>;</div><div class="line">            event-&gt;when = now;</div><div class="line">            event-&gt;type = FINISHED_DEVICE_SCAN;</div><div class="line">            event += <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//以上步骤主要是负责重新获取接入的设备，下面将会负责获得设备中的event</span></div><div class="line">	</div><div class="line">        <span class="comment">// Grab the next input event.</span></div><div class="line">        <span class="keyword">bool</span> deviceChanged = <span class="literal">false</span>;</div><div class="line">        <span class="comment">//开始循环获取pending的event</span></div><div class="line">        <span class="comment">//当前处理的Event序号是否小于正在等待的事件数目，这里会循环读出所有等待的事件</span></div><div class="line">        <span class="keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;</div><div class="line">	    <span class="comment">//获取一个event项</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">struct</span> epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++];</div><div class="line">	    <span class="comment">//如果这是个INotify事件</span></div><div class="line">            <span class="keyword">if</span> (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123;</div><div class="line">                <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</div><div class="line">                    mPendingINotify = <span class="literal">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for INotify."</span>, eventItem.events);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">	    <span class="comment">//如果这是一个Id wake事件，则读出mWakeReadPipeFd的数据，让等待在这个文件描述符上的线程得到唤醒	</span></div><div class="line">            <span class="keyword">if</span> (eventItem.data.u32 == EPOLL_ID_WAKE) &#123;</div><div class="line">                <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</div><div class="line">                    ALOGV(<span class="string">"awoken after wake()"</span>);</div><div class="line">                    awoken = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">char</span> buffer[<span class="number">16</span>];</div><div class="line">                    <span class="keyword">ssize_t</span> nRead;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));</div><div class="line">                    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="keyword">sizeof</span>(buffer));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for wake read pipe."</span>,</div><div class="line">                            eventItem.events);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">	   </div><div class="line">	    <span class="comment">//这里开始处理其它非特殊的event</span></div><div class="line">	    <span class="comment">//获取event项对应的设备的编号</span></div><div class="line">            <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(eventItem.data.u32);</div><div class="line">            <span class="keyword">if</span> (deviceIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">                ALOGW(<span class="string">"Received unexpected epoll event 0x%08x for unknown device id %d."</span>,</div><div class="line">                        eventItem.events, eventItem.data.u32);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//获取设备，所有已知的设备都放在了mDevices中</span></div><div class="line">            Device* device = mDevices.valueAt(deviceIndex);</div><div class="line">            <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</div><div class="line">                <span class="comment">//从这个设备中读出数据流，并且存入readBuffer下</span></div><div class="line">                <span class="keyword">int32_t</span> readSize = read(device-&gt;fd, readBuffer,</div><div class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_event) * capacity);</div><div class="line">                <span class="keyword">if</span> (readSize == <span class="number">0</span> || (readSize &lt; <span class="number">0</span> &amp;&amp; errno == ENODEV)) &#123;</div><div class="line">                    <span class="comment">// Device was removed before INotify noticed.</span></div><div class="line">	            <span class="comment">//先处理一些异常情况，先省略</span></div><div class="line">	            <span class="comment">//...</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123; </div><div class="line">                    <span class="comment">//键盘事件的id需要特殊处理，一直设置为0</span></div><div class="line">                    <span class="keyword">int32_t</span> deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="number">0</span> : device-&gt;id;</div><div class="line"></div><div class="line">                    <span class="keyword">size_t</span> count = <span class="keyword">size_t</span>(readSize) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_event);</div><div class="line">                    <span class="comment">//开始循环，从设备中读出每一个event</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                        <span class="keyword">struct</span> input_event&amp; iev = readBuffer[i];</div><div class="line">                       </div><div class="line">                        <span class="comment">//这里做了许多处理事件异常时间的工作，先略过</span></div><div class="line">                        <span class="comment">//...</span></div><div class="line">                        </div><div class="line">                        <span class="comment">//将获取的事件存入event</span></div><div class="line">                        event-&gt;deviceId = deviceId;</div><div class="line">                        event-&gt;type = iev.type;</div><div class="line">                        event-&gt;code = iev.code;</div><div class="line">                        event-&gt;value = iev.value;</div><div class="line">                        <span class="comment">//event指向下一个位置，容量也随之减少一个</span></div><div class="line">                        event += <span class="number">1</span>;</div><div class="line">                        capacity -= <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// The result buffer is full.  Reset the pending event index</span></div><div class="line">                        <span class="comment">// so we will try to read the device again on the next iteration.</span></div><div class="line">                        <span class="comment">//buffer已经填满，退出处理pending event的循环，将index回到上一个位置，因为该设备event还没读完，下次再接着读</span></div><div class="line">                        mPendingEventIndex -= <span class="number">1</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventItem.events &amp; EPOLLHUP) &#123;</div><div class="line">	          <span class="comment">//处理一些其它情况，省略</span></div><div class="line">	          <span class="comment">//...</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">//在读出所有event后，才能关闭设备，这里省略了对此的处理过程</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">        </div><div class="line">        <span class="comment">//到这里说明pending event已经处理完，或者buffer已经塞满。buffer塞满或者存了一些事件，则退出最外层填充buffer的循环</span></div><div class="line">        <span class="comment">// Return now if we have collected any events or if we were explicitly awoken.</span></div><div class="line">        <span class="keyword">if</span> (event != buffer || awoken) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//这里处理了一些wake lock的事情，省略</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">        </div><div class="line">        <span class="comment">//到这一步说明buffer里没有填任何事件，同时也没有pending event</span></div><div class="line">        <span class="comment">//所以需要等待有人向device文件描述符里写入一些事件</span></div><div class="line">        <span class="keyword">int</span> pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div><div class="line">        </div><div class="line">        <span class="comment">//时间已到，还是没有事件，那咱就结束吧</span></div><div class="line">        <span class="keyword">if</span> (pollResult == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Timed out.</span></div><div class="line">            mPendingEventCount = <span class="number">0</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//出错了，让我睡一会，下次再尝试</span></div><div class="line">        <span class="keyword">if</span> (pollResult &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// An error occurred.</span></div><div class="line">            mPendingEventCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Sleep after errors to avoid locking up the system.</span></div><div class="line">            <span class="comment">// Hopefully the error is transient.</span></div><div class="line">            <span class="keyword">if</span> (errno != EINTR) &#123;</div><div class="line">                ALOGW(<span class="string">"poll failed (errno=%d)\n"</span>, errno);</div><div class="line">                usleep(<span class="number">100000</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Some events occurred.</span></div><div class="line">            mPendingEventCount = <span class="keyword">size_t</span>(pollResult);</div><div class="line">            <span class="comment">//获取了一些event，那么继续循环，填充buffer！</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// All done, return the number of events we read.</span></div><div class="line">    <span class="keyword">return</span> event - buffer;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h3><p>从这里开始扫描设备。在研究这个函数前，先看一下<code>DEVICE_PATH</code>的来头：</p>
<p><em>frameworks/native/services/inputflinger/EventHub.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这一段代码位于EventHub的构造函数中，这里使用了linux的inotify机制</span></div><div class="line"><span class="comment">//inotify机制可以监控文件的变化</span></div><div class="line"><span class="comment">//因此系统可以实时监控设备的添加和移除</span></div><div class="line">mINotifyFd = inotify_init();</div><div class="line"><span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</div></pre></td></tr></table></figure></p>
<p><em>frameworks/native/services/inputflinger/EventHub.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> EventHub::scanDevicesLocked() &#123;</div><div class="line">     <span class="comment">//扫描目录：/dev/input</span></div><div class="line">    <span class="keyword">status_t</span> res = scanDirLocked(DEVICE_PATH);</div><div class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</div><div class="line">        ALOGE(<span class="string">"scan dir failed for %s\n"</span>, DEVICE_PATH);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//创建一个虚拟键盘</span></div><div class="line">        createVirtualKeyboardLocked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-5"><a href="#4-5" class="headerlink" title="4.5"></a>4.5</h3><p>这里开始扫描<code>/dev/input/</code>目录下的所有设备。</p>
<p><em>frameworks/native/services/inputflinger/EventHub.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> EventHub::scanDirLocked(<span class="keyword">const</span> <span class="keyword">char</span> *dirname)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> devname[PATH_MAX];</div><div class="line">    <span class="keyword">char</span> *filename;</div><div class="line">    DIR *dir;</div><div class="line">    <span class="keyword">struct</span> dirent *de;</div><div class="line">    dir = opendir(dirname);</div><div class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="built_in">strcpy</span>(devname, dirname);</div><div class="line">    filename = devname + <span class="built_in">strlen</span>(devname);</div><div class="line">    <span class="comment">//filename指向了devname目录的尾端，方便在其后面添加设备文件</span></div><div class="line">    *filename++ = <span class="string">'/'</span>;</div><div class="line">    <span class="comment">//读取该目录下的每一个设备文件</span></div><div class="line">    <span class="keyword">while</span>((de = readdir(dir))) &#123;</div><div class="line">        <span class="keyword">if</span>(de-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp;</div><div class="line">           (de-&gt;d_name[<span class="number">1</span>] == <span class="string">'\0'</span> ||</div><div class="line">            (de-&gt;d_name[<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; de-&gt;d_name[<span class="number">2</span>] == <span class="string">'\0'</span>)))</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="built_in">strcpy</span>(filename, de-&gt;d_name);</div><div class="line">        <span class="comment">//打开设备，devname里是设备的绝对路径</span></div><div class="line">        openDeviceLocked(devname);</div><div class="line">    &#125;</div><div class="line">    closedir(dir);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-6"><a href="#4-6" class="headerlink" title="4.6"></a>4.6</h3><p><em>frameworks/native/services/inputflinger/EventHub.cpp :</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> EventHub::openDeviceLocked(<span class="keyword">const</span> <span class="keyword">char</span> *devicePath) &#123;</div><div class="line">    <span class="keyword">char</span> buffer[<span class="number">80</span>];</div><div class="line"></div><div class="line">    <span class="comment">//打开文件</span></div><div class="line">    <span class="keyword">int</span> fd = open(devicePath, O_RDWR | O_CLOEXEC);</div><div class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</div><div class="line">        ALOGE(<span class="string">"could not open %s, %s\n"</span>, devicePath, strerror(errno));</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InputDeviceIdentifier identifier;</div><div class="line"></div><div class="line">    <span class="comment">// Get device name.</span></div><div class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGNAME(<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//fprintf(stderr, "could not get device name for %s, %s\n", devicePath, strerror(errno));</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</div><div class="line">        identifier.name.setTo(buffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Check to see if the device is on our excluded list</span></div><div class="line">    <span class="comment">//删除排除的设备</span></div><div class="line"> </div><div class="line">    <span class="comment">//一下步骤从文件中获取device的基本信息</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="comment">// Get device driver version.</span></div><div class="line">    <span class="comment">// Get device identifier.</span></div><div class="line">    <span class="comment">// Get device physical location.</span></div><div class="line">    <span class="comment">// Get device unique id.</span></div><div class="line">    <span class="comment">// Fill in the descriptor.</span></div><div class="line">    <span class="comment">// Make file descriptor non-blocking for use with poll().</span></div><div class="line"></div><div class="line">    <span class="comment">//创建device对象</span></div><div class="line">    <span class="comment">// Allocate device.  (The device object takes ownership of the fd at this point.)</span></div><div class="line">    <span class="keyword">int32_t</span> deviceId = mNextDeviceId++;</div><div class="line">    Device* device = <span class="keyword">new</span> Device(fd, deviceId, String8(devicePath), identifier);</div><div class="line">    <span class="comment">//根据device的特征，设置device的class参数</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">    </div><div class="line">    <span class="comment">// Register with epoll.</span></div><div class="line">    <span class="keyword">struct</span> epoll_event eventItem;</div><div class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</div><div class="line">    eventItem.events = EPOLLIN;</div><div class="line">    <span class="keyword">if</span> (mUsingEpollWakeup) &#123;</div><div class="line">        eventItem.events |= EPOLLWAKEUP;</div><div class="line">    &#125;</div><div class="line">    eventItem.data.u32 = deviceId;</div><div class="line">    <span class="comment">//将该device的文件fd交给epoll监视，以及时获得它的变化</span></div><div class="line">    <span class="keyword">if</span> (epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp;eventItem)) &#123;</div><div class="line">        ALOGE(<span class="string">"Could not add device fd to epoll instance.  errno=%d"</span>, errno);</div><div class="line">        <span class="keyword">delete</span> device;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//处理时钟问题..</span></div><div class="line"></div><div class="line">    <span class="comment">//添加device</span></div><div class="line">    addDeviceLocked(device);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<h3 id="4-7"><a href="#4-7" class="headerlink" title="4.7"></a>4.7</h3><p>这一步比较轻松，将创建好的device对象放入mDevices即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> EventHub::addDeviceLocked(Device* device) &#123;</div><div class="line">    mDevices.add(device-&gt;id, device);</div><div class="line">    device-&gt;next = mOpeningDevices;</div><div class="line">    mOpeningDevices = device;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/14/Android系统源码阅读-12-InputChannel的注册过程/" class="prev">PREV</a><a href="/2017/02/14/Android-Monkey-源代码阅读/" class="next">NEXT</a></div><div data-thread-key="2017/02/14/Android系统源码阅读-11-Android的InputManagerService的工作过程/" data-title="Android系统源码阅读(11):Android的InputManagerService的工作过程" data-url="http://itanch.github.io/2017/02/14/Android系统源码阅读-11-Android的InputManagerService的工作过程/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"tianchi"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2017 <a href="http://itanch.github.io">Tian chi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>