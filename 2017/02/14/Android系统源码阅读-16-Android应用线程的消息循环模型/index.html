<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android系统源码阅读(16):Android应用线程的消息循环模型 · Tianchi's Blog</title><meta name="description" content="Android系统源码阅读(16):Android应用线程的消息循环模型 - Tian chi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://itanch.github.io/atom.xml" title="Tianchi's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android系统源码阅读(16):Android应用线程的消息循环模型</h1><div class="post-info">Feb 14, 2017</div><div class="post-content"><blockquote>
<p>读书不宜拖沓</p>
</blockquote>
<h2 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h2><p>Android应用的主线程为ActivityThread，在第（10）章已经讲过，它主要负责处理界面事件，所以开发者应该避免在主线程中处理耗时的任务。为了减轻主线程的负担，开发者应该启用多线程来处理耗时的任务。在Android中可以创建多种线程，有的线程可以有自己的消息循环，有的线程则可以向主线程发送消息来使得界面发生改变。</p>
<p>##1. 主线程的消息循环</p>
<p>应用程序的主线程创建过程如下：ActivityManagerService线程请求Zygote进程创建应用进程；Zygote通过fork来创建一个新进程，新进程将ActivityThread的main作为入口进入Looper循环；Looper会调用静态成员函数prepareMainLooper创建一个Looper对象，并且在该应用进程中，该方法只会调用一次，因为只有一个主线程。<br><a id="more"></a></p>
<h2 id="2-子线程HandlerThread"><a href="#2-子线程HandlerThread" class="headerlink" title="2. 子线程HandlerThread"></a>2. 子线程HandlerThread</h2><p>Android应用中，创建子线程可以和java桌面应用一样，创建一个Thread子类，实现run函数，然后start即可。但是这种方式是没有消息循环的，是一种比较简单的方法。</p>
<p>另一种则是使用Android定制版的Thread–HandlerThread。HanlderThre    ad的实现也很简单，完全可以模仿它实现一个自己的带有消息循环的Thread，或者实现一个集成HandlerThread的子类。</p>
<p><em>frameworks/base/core/java/android/os/HandlerThread.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Handy class for starting a new thread that has a looper. The looper can then be</div><div class="line"> * used to create handler classes. Note that start() must still be called.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mPriority;</div><div class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</div><div class="line">    Looper mLooper;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Constructs a HandlerThread.</div><div class="line">     * <span class="doctag">@param</span> name</div><div class="line">     * <span class="doctag">@param</span> priority The priority to run the thread at. The value supplied must be from</div><div class="line">     * &#123;<span class="doctag">@link</span> android.os.Process&#125; and not from java.lang.Thread.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        mPriority = priority;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Call back method that can be explicitly overridden if needed to execute some</div><div class="line">     * setup before Looper loops.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        mTid = Process.myTid();</div><div class="line">        <span class="comment">//准备了looper</span></div><div class="line">        Looper.prepare();</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">//获得自己的looper</span></div><div class="line">            mLooper = Looper.myLooper();</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">        Process.setThreadPriority(mPriority);</div><div class="line">        onLooperPrepared();</div><div class="line">        <span class="comment">//进入消息循环</span></div><div class="line">        Looper.loop();</div><div class="line">        mTid = -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This method returns the Looper associated with this thread. If this thread not been started</div><div class="line">     * or for any reason is isAlive() returns false, this method will return null. If this thread</div><div class="line">     * has been started, this method will block until the looper has been initialized.</div><div class="line">     * <span class="doctag">@return</span> The looper.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    wait();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mLooper;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Quits the handler thread's looper.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Causes the handler thread's looper to terminate without processing any</div><div class="line">     * more messages in the message queue.</div><div class="line">     * &lt;/p&gt;&lt;p&gt;</div><div class="line">     * Any attempt to post messages to the queue after the looper is asked to quit will fail.</div><div class="line">     * For example, the &#123;<span class="doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</div><div class="line">     * &lt;/p&gt;&lt;p class="note"&gt;</div><div class="line">     * Using this method may be unsafe because some messages may not be delivered</div><div class="line">     * before the looper terminates.  Consider using &#123;<span class="doctag">@link</span> #quitSafely&#125; instead to ensure</div><div class="line">     * that all pending work is completed in an orderly manner.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> True if the looper looper has been asked to quit or false if the</div><div class="line">     * thread had not yet started running.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #quitSafely</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper looper = getLooper();</div><div class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</div><div class="line">            looper.quit();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Quits the handler thread's looper safely.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Causes the handler thread's looper to terminate as soon as all remaining messages</div><div class="line">     * in the message queue that are already due to be delivered have been handled.</div><div class="line">     * Pending delayed messages with due times in the future will not be delivered.</div><div class="line">     * &lt;/p&gt;&lt;p&gt;</div><div class="line">     * Any attempt to post messages to the queue after the looper is asked to quit will fail.</div><div class="line">     * For example, the &#123;<span class="doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</div><div class="line">     * &lt;/p&gt;&lt;p&gt;</div><div class="line">     * If the thread has not been started or has finished (that is if</div><div class="line">     * &#123;<span class="doctag">@link</span> #getLooper&#125; returns null), then false is returned.</div><div class="line">     * Otherwise the looper is asked to quit and true is returned.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> True if the looper looper has been asked to quit or false if the</div><div class="line">     * thread had not yet started running.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper looper = getLooper();</div><div class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</div><div class="line">            looper.quitSafely();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the identifier of this thread. See Process.myTid().</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mTid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>   </p>
<p>从HandlerThread的源码可以看出它提供了基本的开关功能，使用起来也很简单方便。具体如何使用如下：</p>
<p>首先实例化一个HandlerThread对象，然后启动这个thread。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HandlerThread handleThread = <span class="keyword">new</span> HandlerThread(<span class="string">"Handler Thread"</span>);</div><div class="line"><span class="comment">//然后启动它，因为HandlerThread是Thread的子类，所以启动方法并无差异</span></div><div class="line">handleThread.start();</div></pre></td></tr></table></figure></p>
<p>然后创建一个实现了Runnable接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//重写该方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">	   <span class="comment">//你的任务</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个Runnable的实例对象，然后丢给HandleThread来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ThreadTask threadTask = <span class="keyword">new</span> ThreadTask();</div><div class="line"><span class="comment">//为HandlerThread的Looper创建一个Handler</span></div><div class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper);</div><div class="line"><span class="comment">//通过Handler将任务给HandlerThread来执行</span></div><div class="line">handler.post(threadTask);</div></pre></td></tr></table></figure>
<p>在消息队列处理到该任务时，threadTask的run函数就会被调用执行。</p>
<h2 id="3-异步任务AsyncTask"><a href="#3-异步任务AsyncTask" class="headerlink" title="3. 异步任务AsyncTask"></a>3. 异步任务AsyncTask</h2><p>一个AsyncTask的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//这一步是在主线程中被调用的  </span></div><div class="line">    <span class="comment">//onPreExecute方法用于在执行后台任务前做一些UI操作  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;  </div><div class="line">        Log.i(TAG, <span class="string">"onPreExecute() called"</span>);  </div><div class="line">        textView.setText(<span class="string">"loading..."</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">//这一步是异步线程的主要过程</span></div><div class="line">    <span class="comment">//doInBackground方法内部执行后台任务,不可在此方法内修改UI  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;  </div><div class="line">        Log.i(TAG, <span class="string">"doInBackground(Params... params) called"</span>);  </div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(baos.toByteArray(), <span class="string">"gb2312"</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">//这一步是在主线程中调用</span></div><div class="line">    <span class="comment">//onProgressUpdate方法用于更新进度信息  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progresses)</span> </span>&#123;  </div><div class="line">        Log.i(TAG, <span class="string">"onProgressUpdate(Progress... progresses) called"</span>);  </div><div class="line">        progressBar.setProgress(progresses[<span class="number">0</span>]);  </div><div class="line">        textView.setText(<span class="string">"loading..."</span> + progresses[<span class="number">0</span>] + <span class="string">"%"</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">//主线程调用</span></div><div class="line">    <span class="comment">//onPostExecute方法用于在执行完后台任务后更新UI,显示结果  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;  </div><div class="line">        Log.i(TAG, <span class="string">"onPostExecute(Result result) called"</span>);  </div><div class="line">        textView.setText(result);  </div><div class="line">  </div><div class="line">        execute.setEnabled(<span class="keyword">true</span>);  </div><div class="line">        cancel.setEnabled(<span class="keyword">false</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">//主线程调用</span></div><div class="line">    <span class="comment">//onCancelled方法用于在取消执行中的任务时更改UI  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;  </div><div class="line">        Log.i(TAG, <span class="string">"onCancelled() called"</span>);  </div><div class="line">        textView.setText(<span class="string">"cancelled"</span>);  </div><div class="line">        progressBar.setProgress(<span class="number">0</span>);  </div><div class="line">  </div><div class="line">        execute.setEnabled(<span class="keyword">true</span>);  </div><div class="line">        cancel.setEnabled(<span class="keyword">false</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div></pre></td></tr></table></figure></p>
<p>子线程如果想向主线程发送消息，则需要通过主线程的Handler。这里AsyncTask运行于子线程，但是无需Handler也可以向主线程发送消息。AsyncTask类的具体实现如下。</p>
<p><em>frameworks/base/core/java/android/os/AsyncTask.java</em>  :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="comment">//负责创建线程，放入sPoolWorkQueue中</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//任务队列</span></div><div class="line">    <span class="comment">//如果队列已空，则试图获取任务的线程则会阻塞</span></div><div class="line">    <span class="comment">//如果队列已满，试图向其中加入任务的线程也会阻塞</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * An &#123;<span class="doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel.</div><div class="line">     * 一个线程池，用来执行sPoolWorkQueue中的任务，下面看其如何执行线程</div><div class="line">     * 这里设置了核心线程数，最大线程数等参数</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * An &#123;<span class="doctag">@link</span> Executor&#125; that executes tasks one at a time in serial</div><div class="line">     * order.  This serialization is global to a particular process.</div><div class="line">     * 该线程执行器是顺序执行</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_RESULT = <span class="number">0x1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_PROGRESS = <span class="number">0x2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line">    <span class="comment">//创建当前线程的一个handler，如主线程</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>sThreadFactory，sPoolWorkQueue和THREAD_POOL_EXECUTOR都是全局静态变量。在一个App进程中，因此，所有使用AsyncTask的异步线程使用的是同一个线程池，这样可以避免创建多个线程池占用资源。</p>
<p>ThreadPoolExecutor在执行任务时，会根据实际情况选择是否创建线程，具体如下：   </p>
<ol>
<li>线程池中的线程数量小于核心线程数，则会创建新的线程来执行新添加的任务。</li>
<li>如果大于核心线程数，小于最大线程数，则<ul>
<li>sPoolWorkQueue未满，则将新任务保存在队列中</li>
<li>如果已满，则创建一个新的线程来执行新的任务</li>
</ul>
</li>
<li>如果线程池中线程数已经大于/等于最大线程数，如果队列不满，则放入队列；如果已满，则拒绝新任务。</li>
</ol>
<p>InternalHandler类的实例对象sHandler是创建AsyncTask的线程的Handler，这里假设是主线程。</p>
<p><em>frameworks/base/core/java/android/os/AsyncTask.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="comment">//这个函数是运行在主线程中</span></div><div class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                    <span class="comment">// There is only one result</span></div><div class="line">                    <span class="comment">//异步任务执行结束后发送结果，这里处理这个结果</span></div><div class="line">                    result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                    <span class="comment">//异步任务实行过程中，会使用publishProgress来发布中间结果</span></div><div class="line">                    <span class="comment">//这一步就是主线程处理该中间结果</span></div><div class="line">                    result.mTask.onProgressUpdate(result.mData);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中result是一个AsyncTaskResult，里面保存了结果信息和其对应的AsyncTask。</p>
<p><em>frameworks/base/core/java/android/os/AsyncTask.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">    <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">        mTask = task;</div><div class="line">        mData = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WorkerRunnable类的实例mWorker实现如下，保存了异步任务的输入数据：</p>
<p><em>frameworks/base/core/java/android/os/AsyncTask.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</div><div class="line">    Params[] mParams;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>了解了AsyncTask的成员变量后，下面看一个异步任务创建的完整过程。</p>
<h3 id="3-1-AsyncTask的构造函数"><a href="#3-1-AsyncTask的构造函数" class="headerlink" title="3.1 AsyncTask的构造函数"></a>3.1 AsyncTask的构造函数</h3><p><em>frameworks/base/core/java/android/os/AsyncTask.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</div><div class="line"> * 看来AsyncTask只能在主线程中创建啊！</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//这里实现了一个WorkerRunnable的匿名类，同时实例化了一个对象mWorker</span></div><div class="line">    <span class="comment">//这里面封装了所要执行的任务</span></div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="comment">//异步线程里执行的任务</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">            <span class="comment">//noinspection unchecked</span></div><div class="line">            <span class="comment">//这里有用户定义的所要执行的任务</span></div><div class="line">            Result result = doInBackground(mParams);</div><div class="line">            Binder.flushPendingCommands();</div><div class="line">            <span class="keyword">return</span> postResult(result);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">//又将mWorker封装如FutureTask，同样封装了要执行的任务</span></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure> </p>
<h3 id="3-2-AsyncTask的执行"><a href="#3-2-AsyncTask的执行" class="headerlink" title="3.2 AsyncTask的执行"></a>3.2 AsyncTask的执行</h3><p>在主线程中运行AsyncTask时，需要调用execute来执行该任务，该方法又会调用如下函数来执行任务。这里需要注意的是execute函数是运行在主线程中的，异步任务还没开始。</p>
<p><em>frameworks/base/core/java/android/os/AsyncTask.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">          Params... params) &#123;</div><div class="line">      <span class="comment">//...</span></div><div class="line">      mStatus = Status.RUNNING;</div><div class="line">      <span class="comment">//在主线程里运行执行前的任务</span></div><div class="line">      onPreExecute();</div><div class="line"></div><div class="line">      mWorker.mParams = params;</div><div class="line">      <span class="comment">//exec是一个SerialExecute</span></div><div class="line">      exec.execute(mFuture);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>SerialExecutor执行器的执行过程。<br><em>frameworks/base/core/java/android/os/AsyncTask.java</em> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">        Runnable mActive;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">            <span class="comment">//把mFuture封装入Runnable，然后放在队列mTasks中</span></div><div class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        r.run();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="comment">//在结束该任务之前，把队列的下一个任务放入线程池</span></div><div class="line">                        scheduleNext();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//开始执行队列中的第一个任务</span></div><div class="line">                scheduleNext();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//第一个任务放入线程池执行</span></div><div class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>到这里已经将任务交给线程池来启动，用户定义的doInBackground已经开始运行。</p>
<h3 id="3-3-异步线程发送消息"><a href="#3-3-异步线程发送消息" class="headerlink" title="3.3 异步线程发送消息"></a>3.3 异步线程发送消息</h3><p>异步线程可以通过publishProgress发送消息，具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@WorkerThread</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isCancelled()) &#123;</div><div class="line">            <span class="comment">//获得主线程的handler--sHandler，通过它向主线程发送消息</span></div><div class="line">            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</div><div class="line">                    <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>主线程通过sHandler的handleMessage函数来处理该消息，然后调用用户自己实现的onProgressUpdate函数来实现UI的更新。</p>
<h3 id="3-4-异步任务结束"><a href="#3-4-异步任务结束" class="headerlink" title="3.4 异步任务结束"></a>3.4 异步任务结束</h3><p>在异步线程执行完任务后，会调用FutureTask的done函数来处理结束事件。这里主要处理的就是异步任务处理完成后，最后的返回值。最后的结果通过如下函数发送给主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">               <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">       message.sendToTarget();</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>前面已经讲过，主线程会调用handler里的result.mTask.finish(result.mData[0])来处理结果。finish函数实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">            <span class="comment">//这些都是用户可以重写的</span></div><div class="line">            <span class="comment">//来实现自己的功能</span></div><div class="line">            onCancelled(result);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">            onPostExecute(result);</div><div class="line">      &#125;</div><div class="line">      mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>这里主要介绍了android应用里的几种线程的运行机制。</p>
<p>普通java线程Thread是最简单的一种方法，但是比较难管理，与主线程通信主要靠handler。而且，该中线程只能向主线程发消息，而主线程无法向子线程发消息。</p>
<p>HandlerThread则是可以有自己的looper和消息队列，将任务发送入消息队列来实现异步任务的处理，同时还方便管理。主线程和子线程可以通过对方的Handler相互发送消息。</p>
<p>AsyncTask是比较适用于Android应用的一种异步任务实现方式。虽然归根结底还是通过handler来向主进程发消息，但是整个异步任务执行过程的划分和管理更为科学，屏蔽了内部实现的复杂，为用户提供了更为简单实用的接口。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/14/Android系统源码阅读-17-Android应用的安装/" class="prev">PREV</a><a href="/2017/02/14/Android系统源码阅读-15-Android应用进程的启动/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://itanch.github.io">Tian chi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>