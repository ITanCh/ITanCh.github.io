[{"title":"Java容器类源码研究:Collection","date":"2017-09-06T07:48:58.000Z","path":"2017/09/06/Java容器类源码研究-Collection/","text":"集合类关系：Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap Collectionjava.util.Collection Collection是List和Set的父接口。它继承了Iterable接口，所以每个Collection的子类应该是可以迭代访问其中的元素的。 我注意到一个有意思的函数，该函数在Java1.8中引入。该函数的功能是从集合中删除所有满足条件的元素，代码实现平平无奇，主要是函数有一个default修饰。Java8提供了default让接口中也可以实现方法体，目的是为了让开发者在修改interface时，不必再一一修改实现该接口的类，这些类可以使用默认的方法实现。 123456789101112default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed;&#125; Collection的equals方法的重写需要小心谨慎。简单的使用引用比较还是比较简单安全的，值比较则会变复杂。相等必须是对称的，约定List只能和其它List相等，Set亦然。所以你自己实现的Collection类在和List、Set比较时应该返回false，因为即使你定制的Collection可以返回true，但是从List的视角来比较，返回的是false，不满足对称性。因此，也无法正确的实现一个既有List接口，又有Set接口的类。 遵照约定，如果你重写了equals方法，那么你要同时重写hashCode方法。c1.equals(c2)成立，则c1.hashCode()==c2.hashCode()。 Spliterator接口在Java8中引入，这个单词是Split和iterator的合成，用来分割集合以给并行处理提供方便。看个例子： 12345678910111213141516171819202122public class Ripper &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; numbers.add(i); &#125; Spliterator&lt;Integer&gt; sp = numbers.spliterator(); System.out.println(sp.characteristics()); System.out.println(sp.estimateSize()); Spliterator&lt;Integer&gt; sp2=sp.trySplit(); System.out.println(sp.estimateSize()); System.out.println(sp2.estimateSize()); Spliterator&lt;Integer&gt; sp3=sp.trySplit(); System.out.println(sp.estimateSize()); System.out.println(sp3.estimateSize()); sp3. &#125;&#125; 运行结果： 12345616464105532 相较于传统的iterator，spliterator可以递归的对集合进行划分，每个spliterator管理了原来集合中的部分元素。但是，每个spliterator并不是线程安全的，所以并行处理时，要保证每一个划分在同一个线程中进行处理。 Collection提供Stream对元素进行流处理，其中用到了spliterator。看个例子： 12345678910111213141516171819public class Ripper &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; numbers.add(i); &#125; Stream&lt;Integer&gt; stream = numbers.stream(); List&lt;Integer&gt; filterNum=stream.filter(item -&gt; item &gt; 5).collect(Collectors.toList()); for(Integer i:filterNum)&#123; System.out.print(i+\" \"); &#125; filterNum.set(0,100); System.out.println(); for(Integer i:numbers)&#123; System.out.print(i+\" \"); &#125; &#125;&#125; 结果：126 7 8 9 0 1 2 3 4 5 6 7 8 9 集合经过两步处理，过滤出了所有符合条件的元素。Stream整体处理过程分为两步：1.Configuration，2.Processing。Filter是Configuration，collect是Processing。还可以看出一点，最后获取的结果List是一个新建的List，并不和原List共享内存中的元素。 再看一个reduce的例子：123456789101112public class Ripper &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; numbers.add(i); &#125; Stream&lt;Integer&gt; stream = numbers.stream(); int result=stream.reduce(0, (acc, item) -&gt; acc + item); System.out.println(result); &#125;&#125; 结果是：45。这是一个求和运算，其中第一个参数0是acc的初始值，acc表示上一步(acc, item) -&gt; acc + item的结果，item是每次从stream中取的值。这些Configuration并不立即执行，而是等到最后一个Processing函数，统一执行。 在Collection中有parallelStream提供并行运算，并且使用了默认的spliterator对集合进行划分。例子如下： 1234567891011121314public class Ripper &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; numbers.add(i); &#125; Stream&lt;Integer&gt; stream = numbers.parallelStream(); stream.forEach(item -&gt; System.out.print(item+\" \")); System.out.println(); stream=numbers.stream(); stream.forEach(item -&gt; System.out.print(item+\" \")); &#125;&#125; 结果：121 2 6 8 0 4 3 5 9 7 0 1 2 3 4 5 6 7 8 9 可见，并行运算无法保证每个元素被处理的顺序。","tags":[{"name":"Java","slug":"Java","permalink":"http://itanch.github.io/tags/Java/"},{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"}]},{"title":"你的名字观感","date":"2017-09-05T07:16:14.000Z","path":"2017/09/05/你的名字观感/","text":"你的名字，一种高端的爱情表达形式。 彗星来临致使时空错乱，与他人产生跨越时空的交流，这个设定很多电影中已经用过。 美国人可能会以此来写一个儿子与父亲跨越时空对话，一同破案的故事，见“黑洞频率（2000）”。 也可能会搞一个时空重叠，挖掘人性的悲剧，比如“彗星来的那一夜”。 新海诚却用此来表现爱情。 我在“秒速五厘米”和这个故事中感觉是相似的。 青春期的爱情，就像一场梦，醒来后只剩下模糊的记忆。 自己在青春期时对爱情的感觉，被新海诚的动画讲述出来，这种感觉是畅快的。 青春期时的爱情是无所畏惧的寻找，是一时的冲动与盲目。 是两个人相见时的热泪，是无法相见的挂念。 是错过，是遗憾。 是错过后，不经意间的再次相遇。","tags":[{"name":"记录","slug":"记录","permalink":"http://itanch.github.io/tags/记录/"}]},{"title":"spring学习_bean的装配","date":"2017-06-25T11:48:39.000Z","path":"2017/06/25/spring学习-1/","text":"装配beanDI可以降低模块之间的耦合性，一个类通过定义接口来被注入依赖。配置文件描述了对象之间的依赖关系，Spring容器会根据配置文件装配bean。 有三种装配bean的方式： 在java中现式配置； 在XML文件中现式配置； 隐式bean发现和装配。 项目实践针对上述三种装配bean的方式，我创建了一个简单的项目进行学习。 首先创建了maven项目，并且pom.xml加入所需的依赖： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.pache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.tc&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 自动化装配bean示例中有两个bean，其中CDPlayer需要装配CompactDisk。 12345678910111213141516171819package com.tc;import org.springframework.stereotype.Component;//注解指明了需要被自动发现的bean@Componentpublic class CompactDisc &#123; private String title = \"Sgt\"; private String artist = \"Beatles\"; static int count = 0; public CompactDisc() &#123; count++; &#125; public String play() &#123; return \"Playing \" + title + \" by \" + artist + \" \" + count; &#125;&#125; 12345678910111213141516171819package com.tc;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CDPlayer &#123; private CompactDisc cd; //自动装配依赖的bean @Autowired public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; public String play() &#123; return cd.play(); &#125;&#125; 通过配置文件指明自动扫描 package com.tc; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; //指明该class是一个配置，并且采用自动扫描 @Configuration @ComponentScan public class CDPlayerConfig { } 进行测试： package com.tc; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = CDPlayerConfig.class) public class CDPlayerTest { @Autowired private CompactDisc cd; @Autowired private CDPlayer player; //cd会被自动装配，不会为null @Test public void cdShouldNotBeNull() { assertNotNull(cd); } @Test public void playIsRight() { assertEquals(\"Playing Sgt by Beatles 1\", player.play()); } //CompactDisc实例只被创建了一次，spring默认bean是单例模式 @Test public void cdIsSingle() { assertEquals(cd.play(), player.play()); } } 通过java装配bean通过java装配bean和自动装配CompactDisc与CDPlayer的区别在于，去掉了@Component和@Autowired标注，将这些类变成了普通的类。 而在配置文件中，需要如下修改： package com.tc; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class CDPlayerConfig { @Bean public CompactDisc compactDisc(){ return new CompactDisc(); } @Bean public CDPlayer cdPlayer(CompactDisc cd){ return new CDPlayer(cd); } } 使用原来的测试代码，可以发现测试可以成功的通过。 通过XML装配bean创建xml配置文件src\\main\\resources\\play.xml，并填入如下配置内容： &lt;?xml version = \"1.0\" encoding = \"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"compactDisc\" class=\"com.tc.CompactDisc\"/&gt; &lt;bean id=\"cdPlayer\" class=\"com.tc.CDPlayer\"&gt; &lt;constructor-arg ref=\"compactDisc\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 把原来的java配置文件CDPlayerConfig.java删除，可以运行测试，结果依然正确。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"java","slug":"java","permalink":"http://itanch.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://itanch.github.io/tags/spring/"}]},{"title":"Netty入门-架构","date":"2017-05-30T12:48:48.000Z","path":"2017/05/30/Netty入门-2/","text":"循环加消息队列是实现异步和事件驱动的有效方式。在Android框架和Nodejs框架中，都采用了类似的架构。 这篇文章主要介绍 整体架构 一个EventLoopGroup包含一个或者多个EventLoop； 一个EventLoop在它的生命周期内只和一个Thread绑定； 一个Channel在生命周期内只和一个EventLoop绑定； EventLoop可以被分配给多个Channel； 一个Channel有一个ChannelPipeline； ChannelPipeline中有双向的入站/出站的Channelhandler链。 基于NIO异步模型《Netty实战》中画的已经非常清楚，这里我照搬了下来。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Netty","slug":"Netty","permalink":"http://itanch.github.io/tags/Netty/"},{"name":"java","slug":"java","permalink":"http://itanch.github.io/tags/java/"}]},{"title":"Netty入门-简介","date":"2017-05-29T02:49:38.000Z","path":"2017/05/29/Netty入门-1/","text":"Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients. 这里通过实现一个简单的Echo服务器和客户端来演示Netty的使用。参考《Netty实战》。 环境java version “1.8.0_121”Java(TM) SE Runtime Environment (build 1.8.0_121-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode) Maven: 3.5.0 Netty: 4.1.11.Final 文件结构123456789101112131415161718192021222324252627282930.echo├── Client│ ├── pom.xml│ ├── src│ │ ├── main│ │ │ ├── java│ │ │ │ └── com│ │ │ │ └── tc│ │ │ │ └── echo│ │ │ │ ├── EchoClient.java│ │ │ │ └── EchoClientHandler.java│ │ │ └── resources│ │ └── test│ │ ├── java│ │ └── resources│ └── target├── Server│ ├── pom.xml│ ├── src│ │ ├── main│ │ │ └── java│ │ │ └── com│ │ │ └── tc│ │ │ └── echo│ │ │ ├── EchoServer.java│ │ │ └── EchoServerHandler.java│ │ └── test│ │ └── java│ └── target└── pom.xml 首先主目录中有一个pom.xml文件，同时有两个子模块Server和Client，每个子模块又有自己的pom.xml文件。 根pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.tc&lt;/groupId&gt; &lt;artifactId&gt;echo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;echo&lt;/name&gt; &lt;description&gt; Build an Echo Server and Client &lt;/description&gt; &lt;modules&gt; &lt;module&gt;Client&lt;/module&gt; &lt;module&gt;Server&lt;/module&gt; &lt;/modules&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;echo-server.hostname&gt;localhost&lt;/echo-server.hostname&gt; &lt;echo-server.port&gt;8888&lt;/echo-server.port&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.11.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;2.18.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.18.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 注意根pom.xml是一个pom项目，并且定义了两个module：Client，Server。根目录下只有一个pom文件和两个子模块项目，没有具体的代码。 这里先声明了整个项目的所需的依赖netty-all，同时声明了一下后续需要使用的插件。 Server12345678910111213141516171819202122232425262728293031323334353637&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.tc&lt;/groupId&gt; &lt;artifactId&gt;echo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;Server&lt;/artifactId&gt; &lt;name&gt;Echo Server&lt;/name&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;run-server&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;com.tc.echo.EchoServer&lt;/mainClass&gt; &lt;arguments&gt; &lt;argument&gt;$&#123;echo-server.port&#125;&lt;/argument&gt; &lt;/arguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Server的pom继承了上一根项目echo的pom，所以echo中pom的内容也会应用于Server。同时这里还定义了执行方法，指定的主函数入口，并且设置了需要传入的参数。 EchoServerHandler.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.tc.echo;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFutureListener;import io.netty.channel.ChannelHandler.Sharable;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;/** * 代码清单 2-1 EchoServerHandler * * @author &lt;a href=\"mailto:norman.maurer@gmail.com\"&gt;Norman Maurer&lt;/a&gt; *///标示一个ChannelHandler可以被多个 Channel 安全地共享@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ByteBuf in = (ByteBuf) msg; //将消息记录到控制台 System.out.println( \"Server received: \" + in.toString(CharsetUtil.UTF_8)); //将接收到的消息写给发送者，而不冲刷出站消息 ctx.write(in); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //将未决消息冲刷到远程节点，并且关闭该 Channel ctx.writeAndFlush(Unpooled.EMPTY_BUFFER) .addListener(ChannelFutureListener.CLOSE); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; //打印异常栈跟踪 cause.printStackTrace(); //关闭该Channel ctx.close(); &#125;&#125; 创建一个handler来处理网络链接中的事务。 EchoServer:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.tc.echo;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import java.net.InetSocketAddress;/** * 代码清单 2-2 EchoServer 类 * * @author &lt;a href=\"mailto:norman.maurer@gmail.com\"&gt;Norman Maurer&lt;/a&gt; */public class EchoServer &#123; private final int port; public EchoServer(int port) &#123; this.port = port; &#125; public static void main(String[] args) throws Exception &#123; if (args.length != 1) &#123; System.err.println(\"Usage: \" + EchoServer.class.getSimpleName() + \" &lt;port&gt;\" ); return; &#125; //设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException） int port = Integer.parseInt(args[0]); //调用服务器的 start()方法 new EchoServer(port).start(); &#125; public void start() throws Exception &#123; final EchoServerHandler serverHandler = new EchoServerHandler(); //(1) 创建EventLoopGroup EventLoopGroup group = new NioEventLoopGroup(); try &#123; //(2) 创建ServerBootstrap ServerBootstrap b = new ServerBootstrap(); b.group(group) //(3) 指定所使用的 NIO 传输 Channel .channel(NioServerSocketChannel.class) //(4) 使用指定的端口设置套接字地址 .localAddress(new InetSocketAddress(port)) //(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; //EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例 //这里对于所有的客户端连接来说，都会使用同一个 EchoServerHandler，因为其被标注为@Sharable， //这将在后面的章节中讲到。 ch.pipeline().addLast(serverHandler); &#125; &#125;); //(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成 ChannelFuture f = b.bind().sync(); System.out.println(EchoServer.class.getName() + \" started and listening for connections on \" + f.channel().localAddress()); //(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成 f.channel().closeFuture().sync(); &#125; finally &#123; //(8) 关闭 EventLoopGroup，释放所有的资源 group.shutdownGracefully().sync(); &#125; &#125;&#125; 启动Server。 Clientpom.xml:123456789101112131415161718192021222324252627282930313233343536&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.tc&lt;/groupId&gt; &lt;artifactId&gt;echo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;Client&lt;/artifactId&gt; &lt;name&gt;Echo Client&lt;/name&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;run-client&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;com.tc.echo.EchoClient&lt;/mainClass&gt; &lt;arguments&gt; &lt;argument&gt;$&#123;echo-server.hostname&#125;&lt;/argument&gt; &lt;argument&gt;$&#123;echo-server.port&#125;&lt;/argument&gt; &lt;/arguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; EchoClientHandler.java:123456789101112131415161718192021222324252627282930313233343536373839package com.tc.echo;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandler.Sharable;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.CharsetUtil;/** * 代码清单 2-3 客户端的 ChannelHandler * * @author &lt;a href=\"mailto:norman.maurer@gmail.com\"&gt;Norman Maurer&lt;/a&gt; */@Sharable//标记该类的实例可以被多个 Channel 共享public class EchoClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123; @Override public void channelActive(ChannelHandlerContext ctx) &#123; //当被通知 Channel是活跃的时候，发送一条消息 ctx.writeAndFlush(Unpooled.copiedBuffer(\"Netty rocks!\", CharsetUtil.UTF_8)); &#125; @Override public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) &#123; //记录已接收消息的转储 System.out.println( \"Client received: \" + in.toString(CharsetUtil.UTF_8)); &#125; @Override //在发生异常时，记录错误并关闭Channel public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; EchoClient.java:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.tc.echo;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import java.net.InetSocketAddress;/** * 代码清单 2-4 客户端的主类 * * @author &lt;a href=\"mailto:norman.maurer@gmail.com\"&gt;Norman Maurer&lt;/a&gt; */public class EchoClient &#123; private final String host; private final int port; public EchoClient(String host, int port) &#123; this.host = host; this.port = port; &#125; public void start() throws Exception &#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; //创建 Bootstrap Bootstrap b = new Bootstrap(); //指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现 b.group(group) //适用于 NIO 传输的Channel 类型 .channel(NioSocketChannel.class) //设置服务器的InetSocketAddress .remoteAddress(new InetSocketAddress(host, port)) //在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例 .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast( new EchoClientHandler()); &#125; &#125;); //连接到远程节点，阻塞等待直到连接完成 ChannelFuture f = b.connect().sync(); //阻塞，直到Channel 关闭 f.channel().closeFuture().sync(); &#125; finally &#123; //关闭线程池并且释放所有的资源 group.shutdownGracefully().sync(); &#125; &#125; public static void main(String[] args) throws Exception &#123; if (args.length != 2) &#123; System.err.println(\"Usage: \" + EchoClient.class.getSimpleName() + \" &lt;host&gt; &lt;port&gt;\" ); return; &#125; final String host = args[0]; final int port = Integer.parseInt(args[1]); new EchoClient(host, port).start(); &#125;&#125; 运行构建1mvn clean package 到两个模块的目录下，分别运行：1mvn exec:java 遇到的坑创建子模块。手动创建子目录和pom是可行的，但是比较麻烦。在eclipse中，可以右键点击echo项目，然后新建一个module类型的maven工程即可，这样会自动构建相应的文件目录和基本的pom文件。 Netty库解析失败。虽然Netty已经通过maven构建添加入classpath，但是import时会出现错误，当你点击开Maven Dependences会发现，里面的class文件是打不开的。这是因为maven仓库出现的问题，里面有内容错误。我通过删除Home下的.m下的仓库，然后右键项目&gt;Maven&gt;Update Project。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Netty","slug":"Netty","permalink":"http://itanch.github.io/tags/Netty/"},{"name":"java","slug":"java","permalink":"http://itanch.github.io/tags/java/"}]},{"title":"kubernetes入门-安装","date":"2017-05-16T11:55:41.000Z","path":"2017/05/16/kubernetes入门_1/","text":"运行环境ubuntu 14.04minikube version: v0.19.0Docker version 1.12.1 安装minikubeminikube是kubernetes的单机试玩版。 Step 1 首先需要安装一个虚拟机软件，这里采用了VirtualBox。 Step 2 安装kubernetes的命令行工具kubectl。 下载kubectl: 1curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl 配置到环境中： 12chmod +x ./kubectlsudo mv ./kubectl /usr/local/bin/kubectl 检查是否正常运行： 1kubectl cluster-info Step 3 下载并安装minikube: 1curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.19.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ deploymentDeployment可以来创建和更新一个app。 1kubectl run kubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootcamp:v1 --port=8080 Pod和NodePod 表示了一组关系密切的容器，这些容器之间会共享一些资源，如存储资源、网络、端口等。 Pod运行在一个Node上，Node指一个物理机器或者一个虚拟机。Master负责管理Node，将Pod分配到Node上。Kubelet负责Master和Node之间的通信。Container runtime (like Docker, rkt)负责获取容器镜像和运行容器。 ServiceService定义了一组pod的逻辑关系，并且设置了访问这些pod的策略。Pod拥有独立的IP，不对外暴露，Service负责将对外暴露地址。根据不同的暴露方式，Service被分为如下几类： ClusterIP(默认)：在集群中暴露一个内容IP，所以只有在集群内部可以访问service。 NodePort：使用NAT，暴露与集群中所选的Node的port相同的port。让外部可以通过集群IP的超集访问Service。 LoadBalancer：在当前云中创建一个负载平衡器，并且给定一个外部IP给这个service。 ExternalName：Exposes the Service using an arbitrary name (specified by externalName in the spec) by returning a CNAME record with the name. No proxy is used. This type requires v1.7 or higher of kube-dns. A Kubernetes Service sis an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods. Service使用label和selector来匹配一组pod。label是一组key/value对，可以标记对象是开发版、测试版还是发布版，还可以标记版本号等。label可以在创建是赋予，也可以后随时更改。 假设集群中已经有一个deployment kubernetes-bootcamp。 添加service：1kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080 给pod打标签：1kubectl label pod kubernetes-bootcamp-3271566451-ddvkt app=v1 通过标签获取pod1kubectl get pods -l app=v1 删除services：1kubectl delete service -l run=kubernetes-bootcamp app扩展和缩减前面的例子中，一个app只有一个pod和一个容器。有时候，我们会根据需要，扩展和缩减一个app的规模。 将原来的deployment扩展到4个副本：1kubectl scale deployments/kubernetes-bootcamp --replicas=4 Deployment数量发生变化：1234$ kubectl get deploymentsNAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEhello-minikube 1 1 1 1 1dkubernetes-bootcamp 4 4 4 4 1d Pod数量也发生改变：1234567$ kubectl get pods -o wideNAME READY STATUS RESTARTS AGE IP NODEhello-minikube-938614450-wn1r7 1/1 Running 0 1d 172.17.0.2 minikubekubernetes-bootcamp-3271566451-2cjjl 1/1 Running 0 4m 172.17.0.6 minikubekubernetes-bootcamp-3271566451-ddvkt 1/1 Running 0 1d 172.17.0.5 minikubekubernetes-bootcamp-3271566451-nnwq8 1/1 Running 0 4m 172.17.0.7 minikubekubernetes-bootcamp-3271566451-vtnzw 1/1 Running 0 4m 172.17.0.8 minikube 通过定义的service暴露的端口，可以访问kubernetes-bootcamp应用，可以发现请求被发送到不同的pod上，从而体现了负载均衡的实现。1234$ curl nodeip:31645Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-3271566451-2cjjl | v=1$ curl nodeip:31645Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-3271566451-vtnzw | v=1 将app实例缩减到2个：1kubectl scale deployments/kubernetes-bootcamp --replicas=2 app更新Rolling updates可以增量的将pod更新到新版本，并且app不会因此中断。 在更新的时候，service会将业务负载平衡到可获得的pod上面。Rolling updates支持以下操作： Promote an application from one environment to another (via container image updates) Rollback to previous versions Continuous Integration and Continuous Delivery of applications with zero downtime 下面来更新kubernetes-bootcamp应用的版本来体会一下更新的过程。 1kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=docker.io/jocatalin/kubernetes-bootcamp:v2 可以观察到如下更新过程： 1234567891011121314151617181920212223$ kubectl get podsNAME READY STATUS RESTARTS AGEhello-minikube-938614450-wn1r7 1/1 Running 0 2dkubernetes-bootcamp-3271566451-ddvkt 1/1 Running 0 1dkubernetes-bootcamp-3369739380-fbdtm 0/1 ContainerCreating 0 35skubernetes-bootcamp-3369739380-v98xt 0/1 ContainerCreating 0 35s//一段时间后$ kubectl get podsNAME READY STATUS RESTARTS AGEhello-minikube-938614450-wn1r7 1/1 Running 0 2dkubernetes-bootcamp-3271566451-ddvkt 1/1 Terminating 0 2dkubernetes-bootcamp-3369739380-fbdtm 1/1 Running 0 4mkubernetes-bootcamp-3369739380-v98xt 1/1 Running 0 4m//一段时间后$ kubectl get podsNAME READY STATUS RESTARTS AGEhello-minikube-938614450-wn1r7 1/1 Running 0 2dkubernetes-bootcamp-3369739380-fbdtm 1/1 Running 0 5mkubernetes-bootcamp-3369739380-v98xt 1/1 Running 0 5m 如果新pod更新失败，则旧pod不会被全部杀死，至少会保留一个维持正常运行。docker pull jocatalin/kubernetes-bootcamp 测试更新后的效果。 首先获取service暴露的端口，31645:123$ kubectl get servicesNAME CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes-bootcamp 10.0.0.127 &lt;nodes&gt; 8080:31645/TCP 1h 获取节点IP：123456$ kubectl describe pods -l run=kubernetes-bootcamp//...关键内容Name: kubernetes-bootcamp-3369739380-v98xtNamespace: defaultNode: minikube/192.168.99.100//... 发送请求，可以看到app服务版本确实更新了：12$ curl 192.168.99.100:31645Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-3369739380-fbdtm | v=2 回滚，恢复到更新之前。 1kubectl rollout undo deployments/kubernetes-bootcamp","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"docker","slug":"docker","permalink":"http://itanch.github.io/tags/docker/"},{"name":"kubernetes","slug":"kubernetes","permalink":"http://itanch.github.io/tags/kubernetes/"}]},{"title":"Eclipse架构","date":"2017-04-11T09:24:23.000Z","path":"2017/04/11/eclipse架构/","text":"矫情的话在前一篇文章已经说了，迁移完这篇文章就把github上的这个仓库删了。 an integrated development environment(IDE) for anything and nothing in particular.eclipse是一个集成开发环境，它既是所有事物的开发环境，又不为某一特定事物的开发环境。 最初的愿景eclispe 不仅仅局限于一个工具集合，而是一个框架。作为一个框架，它应该具有模块化和可扩展的特点。eclipse 是想作为一个基于组件的平台，一个可以为其他开发者建立自己的工具而服务的平台。 Early eclipse早期的eclispe是为了将开发者从繁琐的开发过程中解放出来，从而开发者可以更加专注于开发新的工具。早期主要有三大元素：Platform JDT(Java Development Tools) PDE(Plug-in Development Environment) 1.PlatformPlatform 是由plugin组成的。plugin是Eclipse组件模型的基础，它是由一个JAR文件和manifest描述文件组成。manifest存在plug-in.xml文件里。 requiresplugin通过requires来说明对其他plugin的依赖。 extension vs extension point开发者可以通过extension和extension point 机制来对Ecipse进行功能上的扩展。它们之间的关系可以用插座和插头来比喻。详细参考1 2。 extension point插座：如果一个plugin希望其它plugin能够对其进行扩展，则需要定义extension point。extension point说明了对其扩展的extension需要遵守的规约。只有特定的插头才能符合条件。 种类：说明性的，没有具体代码；提供可被重写的接口；将关联的元素组织在一起，例如org.eclipse.ui.viewsextension point将view组织在一起管理。extension插头：为某个plugin特定的extension point扩展功能。例如org.eclipse.ui.viewsextension point下，定义的一些view。 plugin的激活过程当Eclipse启动的时候，runtime platform会扫描你安装的所有plugin的manifest，在内存里建立plugin注册表，并且该信息会存在硬盘中，下次启动可以直接加载。plugin通过注册被发现，但是直到它们被使用的时候才真的被激活加载，这种方式叫做lazy activation。 早期Eclipse架构 everything is a plugin workbenchworkbench是组织Eclipse怎么样在桌面上进行显示的UI元素。它由perspective views editors组成。Eclipse workbench是建立在Standard Widget Toolkit(SWT)和JFace之上。 SWTWidget toolkits被分为两类：1.native:使用系统调用来实现UI组件。“像素优先”，和桌面上得其他应用看上去很和谐。但是随着系统的不断变化，widget更新起来很困难，并且造成不一致性，导致程序可移植性也很差。2.emulated:独立于操作系统。试图模仿操作系统的风格，很大的灵活性。但是运行很慢，和系统风格不协调。 Abstract Window Toolkit(AWT)是Java提供的一个native的WT库,但是错误百出，饱受诟病。然后又出现了Swing，一个emulated的WT，同样也是有很多错误，耗费时间和内存。所以这些都不是理想的选择。 最后选择了SWT，SWT在当时比较成功。SWT是native的，它画质精良，让人不禁惊叹：“I can’t believe it’s a Java program.”。 JFaceJFace 是建立在SWT上的UI组件，但是它是纯JAVA代码，没有使用系统的代码。 Help可以扩展org.eclipse.help.toc来写自己的help。 Team代码库支持等。 Eclipse 的一个目的就是鼓励开发人员来扩展eclipse 的功能，实现自己的工具，所以一个稳定的API是十分必要的，所以有句话说的好：“API is forever”。 2.Java Development Tools(JDT)JDT 提供了Java编辑器，导航，重构，debugger，编译和增量编译等功能。 其中为了摆脱命令行编译的繁琐，所以eclipse团队写了一个独立的编译器，并且该编译器可以进行增量编译。通过一个队列，将所有有变化的类进行重新编译，然后因为该变化而牵连的类也要放入队列等待重新编译，最后直到队列为空为止。 3.Plug-in Development Environment(PDE)PDE提供了开发、建立、配置和测试plugin的工具。eclipse团队自己写了PDE Build来创建plugin。 Eclipse 3.0:Runtime,RCP and Robots1.Runtime该版本对原来的requires,extensions和extension points组件模型进行了改进，决定用一个现有的方案来替代旧的方法，最后选择了OSGi。 OSGi(Open Service Gateway Initiative)为什么选择OSGi?1.OSGi拥有语义上的版本控制策略来处理依赖问题。对外的接口也是明确指明的。2.拥有自己的类加载器。3.可以被广泛的接受。4.OSGi社区也是充满活力的。5.这个框架实现了一个优雅、完整和动态的组件模型。应用程序（称为bundle）无需重新引导可以被远程安装、启动、升级和卸载（其中Java包／类的管理被详细定义）。 选择OSGi后Eclipse plugin被称为bundle。plugin.xml仍然保留extensions和extension points这些信息，其他的信息被转移到META-INF/MANIFEST.MF。 依赖问题OSGI框架会通过检测bundle的manifest里的依赖信息来生成该bundle的classpath。同样，manifest中会指明哪些package是对外开放的。 生命周期OSGi是一个动态框架，依旧保持原来Eclipse中的lazy activation，需要的时候类才会被加载。 版本命名一套规范的四部分命名规则。 Service提供了进一步的bundle之间的解耦。extension是被启动时就注册，而service是动态注册。使用service的bundle需要import该package，并且由框架决定该service的启用。 workbenchEclipse 启动自己的extensin是org.eclipse.ui.ide.workbench，是对extension pointorg.eclipse.core.runtime.application的扩展。 2.Rich Client Platform(RCP)因为RCP不需要所有的IDE功能，所以对Eclipse进行了重构，将一些bundle分割，方便开发RCP应用。 Eclipse 3.4Featurefeature是一组被打包的bundle,它们能够被统一的建立和安装。update manager对一个bundle的升级需要升级整个feature。feature.xml中说明了包含的bundle和一些性质。 p2 Conceptsp2是关于installation units(IU)的概念。IU说明了安装组件的名字、id、组件的功能和它的依赖。它可以对安装的组件进行版本控制，并且方便的让组件从一个版本更新到另一个版本。将冲突在安装时发现，而不是在运行时发现。 profile你现有的安装组件的清单。说明了一些运行环境，安装位置等。director执行版本控制。planner检测现有的profile，决定更新一个安装组件的必须要执行的操作。engine执行把新的组件安装到硬盘上。touchpoint处理运行环境。 Eclipse 4.0新版本的目的是简化Eclipse模型，吸引新的社区加入，让平台能够利用新的网络技术。 Model Workbenchmodel的变化会立即在workbench中展现出来。 Cascading Style Sheet Sytling可以使用CSS stylesheets来展现界面。 Dependency Injection服务编程模型包含：producer，consumer，broker。中间人是负责管理生产者和消费者。生产者向context中添加service和对象。service向消费者注入context。消费者声明自己的需求。 Application Services为用户提供更加简单独立的API，让服务也可以用于其他语言。 Conclusion基于组件架构的Eclipse不断吸收新的技术来发展，并且兼顾旧的版本。所以Eclipse社区不断壮大，用户也不断增加。","tags":[{"name":"记录","slug":"记录","permalink":"http://itanch.github.io/tags/记录/"},{"name":"架构","slug":"架构","permalink":"http://itanch.github.io/tags/架构/"},{"name":"eclipse","slug":"eclipse","permalink":"http://itanch.github.io/tags/eclipse/"}]},{"title":"Git架构","date":"2017-04-11T09:08:21.000Z","path":"2017/04/11/Git架构/","text":"文章写于2014年11月，当时的自己本科四年级，导师让我翻译一个叫The Architecture of Open Source Applications的书，然后就有了这两篇文章。至于为什么就翻译了两篇，因为翻译到第二篇的时候导师告诉我是叫我看，不是让我翻译。是不是我真的听错了已经不得而知，也许是看到我翻译的这么烂也不想让我继续下去了😂。两篇文章已经丢在github上有些年头了，本来是想翻译完所有的文章，搞个大新闻，结果就这两片孤零零的在仓库里。现在回想起来本科即将毕业的自己，雄心勃勃的要干一番大事业，如今读研到了找工作的时节却又多些心酸和迷茫。往前走终会有路，热血不会冷却。 6.1 Git简介Git能够让合作者们使用一个p2p的网络仓库来维护工作的电子文档部分（不仅仅局限于代码）。Git支持分布式的工作流程，允许部分工作暂时的分散，最后再聚集一起。 这一章节将会阐明Git用来实现这些功能的许多不为人知的方面，并且会提及Git与其它版本控制系统（VCSs）的不同之处。 6.2 Git起源为了更好地理解Git的设计哲学，首先你要知道在Linux内核社区中Git项目是在什么样的环境下启动的。 Linux内核相对于那时的其它商业软件项目而言是特立独行的，因为Linux内核的贡献者数量庞大，并且贡献者的参与程度和对现有代码库的了解程度参差不齐。几年来，内核一直是利用打包工具和打补丁来维护，所以核心开发社区一直在竭力寻求一个能够满足他们大部分需求的VCS。 为了解决这些需求和在2005年遇到的困境，Git作为一个开源项目诞生了。在当时，核心开发成员们使用了两种VCS:BitKeeper和CVS来管理Linux内核代码库。其中BitKeeper提出了一个与众不同的设计理念，深受Linus喜欢。 在BitKeeper的开发商BitMover宣布要撤销一些Linux内核核心开发者的许可证之后不久，Linus Torvalds急忙地着手开发一个自己的VCS，也就是后来的Git。他开始时写了一组脚本来帮助他管理邮件补丁，然后逐渐应用于管理其它软件补丁。原始脚本的目的是能够快速地终止合并，所以维护人员可以把中期补丁流修改成手动合并，然后继续合并后续的补丁。 从表面上来看，对于Git，Torvals有一个哲学目标–反CVS–加上三个实用的设计目标： 和BitKeeper类似，Git要能够支持分布式工作流(distributed workflows) 提供避免内容错误的安全保障 具有高性能 在某种程度上，这些设计目标已经被实现并将保持下去，就像下面我要展现的一样。接下来会我说明Git如何利用有向无环图（DAG）来处理内容存储，头部指针的引用，对象模型的表现和远程协议；最后会说到Git如何追踪树的合并。 尽管BitKeeper对Git的早期设计产生了影响，但是Git的实现使用了根本不同的方法，并且Git能允许用户分布式地增加更多的本地工作流，这一点是BitKeeper无法做到的。Monotone，一个在2003年启动的开源分布式VCS，可能是早期Git开发的另一个灵感来源。 分布式的版本控制系统通常能花费很小的代价提供很好的工作流的灵活性。分布式模型有如下优点： 让合作者能够线下工作并且递增的提交 让某个合作者自己决定他何时分享他的工作 让合作者能够在线下访问仓库历史 允许被管理的工作发布到多样的仓库中去，发布的工作中潜在的含有分支和细小的变化 在Git项目开始的时期，三个其它的开源分布式VCS（dVCS）也被发起。（其中有一个在The Architecture of Open Source Applications 的第一卷中被讨论过。）所有的这些分布式VCS都用了稍微不同的方法来提供具有很大的灵活性工作流，这一点将它们从其它VCS中分离出来。注意：SubVersion有一个被不同开发者维护着的叫SVK的扩展，它用来支持服务器到服务器的同步。 如今，比较流行的并且被积极维护着的dVCS有：Bazaar，Darcs，Fossil，Git，Mercurial和Veracity。 6.3 版本控制系统设计现在让我们回顾一下在开发Git时可选择的VCS解决方案。了解它们的不同之处，有利于我们探究在Git开发时面临的架构选择。 一个版本控制系统通常有三个核心需求，分别是： 存储内容 追踪内容变化（含有合并信息的历史记录） 在合作者之间分布式的管理内容和历史记录 注意：不是所有的VCS都要求第三点。 内容的存储在版本控制系统界里，为了实现存储内容功能，最一般的选择是利用基于delta的变化集合，或者利用有向无环图（DAG）的内容表示。 基于Delta的变化集合会将两个版本的扁平化内容的相异点封装进来，同时附加一些元数据，这种方式只关心具体的差异。 Git用有DAG来表示文件，关心的是文件的整体变化，用层次结构的对象关系来表示树状结构的文件系统，不同的文件类型用不同的对象来表示。为了提高性能，只有变化的文件才新建立快照并保存在仓库里，没有修改的文件则会利用原来的快照做一个引用。 提交（commit）与合并（merge）历史记录在历史记录和向前变更追踪方面，大部分VCS软件使用了下列方法之一： 线性历史记录 用有向无环图表示的历史记录 Git再一次使用了DAG，不过这次是使用在存储历史记录方面。每一个commit都包含了它的祖先的元数据；Git中一次commit可能有零个或者多个（理论上可以有无限个）父节点。例如，在Git仓库里的第一次commit就没有父节点，然而通过三路合并而来的commit就有三个父节点。 Git和Subversion（使用的是线性历史祖先）另一个重要的区别是，Git能够直接地支持分支，并且分支能够记录大部分的历史事件。 Git通过DAG存储内容可以充分的发挥分支的能力。一个文件的历史记录是连续不断的。从该文件到根目录都是连着的，根目录又连着一个提交节点。这个提交节点，依次又有一个或多个父节点。这样，Git就有两个很好的特性，利用这两个特性我们就能够确切地推断出历史记录和内容，比从RCS发展而来的一些VCS更为准确，具体是： 如果图中的一个内容节点与其它提交中的某个节点有相同的引用ID（在Git使用SHA），则这两个节点一定含有相同的内容，这样Git就有效地缩短了内容的差异对比过程。 当合并两个分支的时候，我们合并的是DAG中两个节点的内容。DAG使得Git可以“高效地”（相对于RCS家族的那些VCS）判定出这些节点的共同祖先。 分布VCS用如下三种方法中的一种来处理一项工作在合作者之间的分配： 仅本地：作为一个VCS解决方法，没有满足上面提到的第三个需求。 中心服务器：所有对仓库的改变必须由一个特定的仓库来记录。 分布式模型：在该模型中，一般合作者会有一个可访问的公共仓库来进行“推送”，但是可以在本地提交并且在稍后推送，允许离线工作。 为了阐明每个关键的设计选择的优点与局限，我们将含有同样内容的SubVersion仓库和Git仓库进行对比（例如,Git仓库默认分支的HEAD上的内容与Subversion仓库主干上最新版本的内容相同）。一个叫Alex的开发者，签出（checkout）一个Subversion的本地仓库，同时克隆（clone）了一个Git的本地仓库。 我们假设，在本地的Subversion仓库中，Alex改变了一个1MB大小的文件，并且提交了这个改变。在本地，签出的这个文件会做出相应的改变并且本地的元数据也会更新。在Alex提交到中心Subversion代码库中的时候，会将旧文件的快照和新的改变进行对比，生成一个对比文件，该对比文件会存在仓库中。 下面和Git的工作过程对比一下。当Alex在本地的Git仓库中对同一个文件做了相同的修改后，修改首先会存储在本地，然后Alex“推送”本地待定的提交到公共仓库里，以便该项目的其他合作者能够分享。最后该内容变化会一致的存储在每一个含有这次提交的Git仓库里。在本地提交时（最简单的情况下），本地的Git仓库会创建一个新的对象表示一个新的文件，而新文件表示这次修改后的文件（新文件包含了所有的内容）。对被修改文件上面的每一层目录（包括根目录），都会创建一个具有新ID的新对象。从新的根节点到新的叶节点，一个新的DAG被创建出来了（对于在本次提交中没有修改的文件，它们的叶节点引用会被再利用），新DAG会引用新建的叶节点，而不是被修改文件在原来那棵树中的旧叶节点。（叶节点表示存在仓库里的文件。） 在这时，这次提交还在Alex的本地设备中的Git仓库里。当Alex“推送”这次提交后，这次提交才算进入公共Git仓库里。在公共仓库核定这次提交适用于该分支后，在本地仓库中创建的那些对象才被存储在公共仓库中。 Git的解决方案更加灵活，它们既是底层的，又是用户层的。这些功能让用户能够明确地表达出是想在远程仓库里分享修改还是仅仅在本地提交。但是，增加这两个层次的复杂性可以为团队在工作流和发布能力上提供极大的灵活性，就像在“Git起源”中提到的一样。 在Subversion的解决方案中，合作者准好分享修改时，他没必要记得把修改推送到远程仓库中。当对大文件进行小的修改时，基于delta的存储比存储各个版本的整个文件更为有效。但是，就如我们将要看到的，Git在某些方面利用了变通的方案。 6.4 工具包（ToolKit）如今，Git生态系统中，有很多命令行和UI工具适用于各种操作系统（包括原来几乎不支持的Windows系统）。其中大部分工具都是建立在Git工具包之上的。 因为Git一开始是Linus写的，并且在Linux社区里启动，所以Git遵循的是Unix传统的命令行模式的工具设计哲学。 Git工具包分为两个部分：“铅（plumbing底层命令）”和“瓷（porcelain高层命令）”。plumbing是指一些底层的命令，这些命令可以提供基本的内容追踪和DAG操作功能。porcelain是较小的git命令集合，用户可能用这些命令来维护仓库和在各个仓库间进行交流。 尽管工具包已经为许多编码器提供了足够多的细小粒度的功能，但是应用开发者仍旧抱怨Git缺少一个可以链接的函数库。因为Git的可执行函数为die()，它不可重入并且没有界面，网络接口和长时间运行的服务器必须用fork/exec命令来调用Git的二进制文件，这样做十分低效。 为应用开发者改变这种状况的工作正在进行中；详情请看“现在和未来的动作”部分。 6.5 仓库，缓存区和工作区（The Repository, Index and Working Areas）git init会创建一个.git子文件，如下图所示。 tree .git/ .git/ |-- HEAD |-- index |-- config |-- description |-- hooks | |-- applypatch-msg.sample | |-- commit-msg.sample | |-- post-commit.sample | |-- post-receive.sample | |-- post-update.sample | |-- pre-applypatch.sample | |-- pre-commit.sample | |-- pre-rebase.sample | |-- prepare-commit-msg.sample | |-- update.sample |-- info | |-- exclude |-- objects | |-- info | |-- pack |-- refs |-- heads |-- tags Configuration:初步配置本地仓库。 .git/config repositoryformatversion:如果需要改变仓库在磁盘上的形式，就可以修改这个参数。 filemode: ture or false。是否注意文件的执行权限。false指当文件权限变化时，没有修改提示。 bare：ture是指该仓库没有工作目录，只有git的相关文件。 logallrefupdates: 记录所有的更新日志。 ignorecase: 是否对大小写敏感。 .git/info/exclude如果你不想提交一些在本地的文件，.gitignore文件是一个选择。但是exclude文件不会被分享给其他人。 Hooks.git/hooks一些常用的示例hooks被放在仓库里，它们只在特定的时刻触发，可以进行检查和提示。默认不生效，将“.sample”去掉可使其生效。 Staging Area.git/index缓冲区。在工作目录下的修改，使用git add命令后，可以将修改添加进缓冲区，这是并没有提交到仓库，使用git commit后才真正的提交到仓库中。这样方便多个修改一次性提交。 1. 运行 “git add README”. 这会导致 git: 1. 拷贝内容（ README ）到git对象存储区，并将其内容包含为一个blob. 2. 在git index中记录: 文件名 README 和存储于对象存储区的 README blob的哈希值. 3. 标记 (记住) 这个 README 现在在用户的工作目录中状态为 “追踪”. 2. 运行 “git commit” ，以 “git index” 中指代的文件为参数，创建commit对象，Tree对象，最后建立新的树（树中的对象也放在对象存储区），并将它们保存到git仓库里. 详情参考：git index Object Database.git/objects一个对象数据库，包含了所有的内容和指向内容的指针，对象一旦创建就不可变了。.git文件比较大，并且用.git文件可以恢复出所有的工作目录。 References.git/refs存储了本地和远程的branch、tag和commit。是一个指向一个对象的指针，一般是tag或者commit。 git checkout [branch]将本地仓库的HEAD引用变成branch的引用，用该branch的数据填充缓冲区，更新工作目录下的文件为该branch的内容。 git add [files]会将工作目录下的文件和index中的文件的校验和进行比较，看是否需要更新index中的文件，git仓库并没有改变。 6.6.对象数据库（The Object Database） 所有的对象都如下参数：类型，大小和内容。 Tree: 一般是表示一个目录。Blob: 用来表示一个存储在仓库里的文件。Commit: 指向一棵树，指向父commit，记录该次提交的一些信息。Tag: 标记一个commit，可以给某个时间点记录别名和附加信息。 对象使用SHA来引用，这是一个由40个十六进制的数字组成的ID。ID具有如下属性： 如果两个对象完全相同，则它们拥有相同的SHA。 不同对象有不同的SHA。 对象的缺失和错误会通过重新计算SHA发现。 6.7. 存储和压缩技术将对象打包，用压缩到的形式存储，用一个目录文件来索引某个对象。git add命令会将工作目录下的修改文件创建对象，放入对象数据库，是没有被打包的，松散的对象。git会周期的进行压缩，或者通过命令（git gc）直接压缩。.git/objects/pack/有两个文件，一个.idx文件和一个.pack文件,如图所示。 打包文件有两个版本，如图所示，详细解释。版本2包含了每个对象的CRC校验值, 因此在重打包的过程中, 压缩过的对象可以直接进行包间拷贝(from pack to pack)而不用担心数据损坏. 版本2的打包文件索引同时亦支持大于4G的打包文件。 在第1版中, offset(偏移)和SHA值存在在同一位置. 但是在第2版中, SHA值, CRC值和offset被放在不同的表中. 两个版本的文件最后都是索引文件以及指向的打包文件的CRC校验值。 很重要的一点是， 要从打包文件中提取(extract)出一个对象, 索引文件不是必不可少的. 索引文件的作用是帮助用户快速地从打包文件中提取对象。 那些”上传打包”(upload-pack)和”取回打包”(receive-pack)程序(译注: 实现push和fetch协议的程序)使用打包文件格式(packfile format)去传输对象, 但是没有使用索引–索引可以在上传或者取回打包文件之后通过扫描打包文件重新建立。 6.8. 历史记录合并（Merge Histories）Subversion这一类用线状历史的VCS，高版本的会取代它之前所有旧的版本，所以不直接支持分支。分支合并到主线后，无法知晓哪些变化来自哪些分支。 Git使用基于DAG的历史合并，某一分支的某次合并可以通过它父节点的SHA知道它由哪些分支合并而来。如图。 6.9. 接下来要做的事不仅要方便脚本使用，还需要进一步设计来方便地嵌入其它应用，方便的集成进开发环境。现在已经开发出了一些可以被其他语言调用的库，同时还有一些支持Git存储的后端被开发出来。 6.10. 经验和教训 In software, every design decision is ultimately a trade-off. 每一个设计策略的选择都最终是一个权衡的过程。 原来的Git工具包的设计为其它IDE的集成带来了麻烦。早期，命令行的形式导致Git的可移植性很差，特别是对Windows而言，导致受众范围很小。 Git命令也难记，错误信息也难以理解。","tags":[{"name":"记录","slug":"记录","permalink":"http://itanch.github.io/tags/记录/"},{"name":"git","slug":"git","permalink":"http://itanch.github.io/tags/git/"},{"name":"架构","slug":"架构","permalink":"http://itanch.github.io/tags/架构/"}]},{"title":"用React-Native写一个微博客户端(3)","date":"2017-04-10T13:21:46.000Z","path":"2017/04/10/用React-Native写一个微博客户端-3/","text":"用React-Native技术实现一个简单的微博客户端。项目开源地址：github。项目还在持续更新中😊。 这一章节主要讲一下在设计该app时遇到的一些问题。 导航Android应用在设计的时候，Activity之间的跳转形成了一个task，该task通过一个栈结构来体现。当用户点击back键，当前的activity会自然的销毁，同时位于栈顶的activity会占据屏幕。这种设计方式很符合用户的操作习惯，所以在通过react-native设计app时，也需要有组件来实现这种功能，所以这里就使用了Navigator组件。 在app中，当用户点击一个微博时，界面会跳进所点击微博的内容，显示微博内容详情，并且可以查看微博评论。当用户点击叉号，会退到浏览微博的页面。 再看一下写在android/welone/index.android.js中的导航组件。123456789101112131415161718192021222324252627282930313233343536373839404142export default class welone extends Component &#123; render() &#123; let mainComponent = MainTab; return ( &lt;Navigator //初始化route的属性 initialRoute=&#123;&#123; component: mainComponent &#125;&#125; //设置界面切换的动画效果 configureScene=&#123;(route) =&gt; &#123; return Navigator.SceneConfigs.VerticalDownSwipeJump; &#125;&#125; //根据route属性，渲染当前界面组件 renderScene=&#123;(route, navigator) =&gt; &#123; let Comp = route.component; return &lt;Comp &#123;...route.params&#125; navigator=&#123;navigator&#125; /&gt; &#125;&#125; /&gt; ); &#125;&#125;``` 这里将MainTab设置为当前初始的主界面，并且将`navigator`作为属性传递给MainTab，同时还传递了一个`route.params`属性，这里该属性为空，所以暂时没有什么作用，以后会用到。通过props，我将navigator对象依次传递到了`WeiboCard`，也就是显示每一个微博内容的卡片。当点击该卡片时，就会触发界面跳转的功能。```js //start the weibo content startWeiboContent(data) &#123; const &#123; navigator &#125; = this.props; if (navigator) &#123; //向导航栈中放入需要跳转的组件 navigator.push(&#123; component: WeiboContent, //将微博内容作为参数传递给了下一个界面，可以参考上一段代码 params: &#123; data: data &#125; &#125;) &#125; &#125; 这里调用了navigator的push函数，放入了需要占据屏幕的界面WeiboContent。这时，MainTab就会被覆盖，显示WeiboContent界面。 在WeiboContent界面，如果需要返回上一个界面MainTab，点击叉号，则会调用如下函数。 1234567//navigate to the parentpressBack() &#123; const &#123; navigator &#125; = this.props; if (navigator) &#123; navigator.pop(); &#125;&#125; navigator只需要pop一下就可以了。 数据传递在React中，父组件向子组件传递数据，主要的方式就是通过设置子组件的props，组件内部的状态通过states来保存。props是外部给组件的属性，states时组件自己的属性。数据流从父节点流向子节点。这种貌似完美的设计方式，在有些情况下会不方便。 比如，子节点需要更新父节点的状态、或者调用父亲节点的功能。则需要将函数通过props将函数传递到子节点。如下代码所示： 在父节点WeiboContent中，将函数getComments作为属性传递给了子组件WeiboCard。1&lt;WeiboCard weiData=&#123;this.props.data&#125; getComments=&#123;this.getComments.bind(this)&#125; /&gt; 在WeiboCard中，调用传入的getComments来更新评论内容.上段代码中的bind指明了该函数在当前组件的上下文中执行。 12345getComments() &#123; if (this.props.getComments) &#123; this.props.getComments(NEW_COMMENT); &#125;&#125; 如果父组件想要调用子组件的函数呢？这就用到ref属性。 在父节点MainTab中，保留了子组件的引用，如下所示。12345678910111213 &lt;WeiboList navigator=&#123;this.props.navigator&#125; ref=&#123;(weiboList) =&gt; &#123; this.weiboList = weiboList &#125;&#125; tab=&#123;this.state.activeTab&#125; /&gt;``` 将WeiboList组件保存在weibolist变量中，这样父组件就可以调用子节点的函数了。如下： ```js onPressTab(tab) &#123; if (this.weiboList != null) &#123; this.weiboList.getTimeLine(NEW_WEIBO); &#125; &#125; 显然这种设计方式是不优美的，破坏了组件之间的独立性。以后的章节中，我将会寻找更好的保存组件状态的方法。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"},{"name":"React Native","slug":"React-Native","permalink":"http://itanch.github.io/tags/React-Native/"}]},{"title":"用React-Native写一个微博客户端(2)","date":"2017-04-08T08:47:49.000Z","path":"2017/04/08/用React-Native写一个微博客户端-2/","text":"用React-Native技术实现一个简单的微博客户端。项目开源地址：github。项目还在持续更新中😊。 主界面设计进入应用，首先看到的就是主界面，这里采用了经典的底部3个tab的主界面设计风格，如下所示。 react-native 框架已经为我们生成了一个简单的主界面于index.android.js，代码如下： 123456789101112131415161718192021export default class welone extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; To get started, edit index.ios.js &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; Press Cmd+R to reload,&#123;'\\n'&#125; Cmd+D or shake for dev menu &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;//...AppRegistry.registerComponent('welone', () =&gt; welone); 这里我们所要做的就是将render()函数中的内容替换成我们的componet。这里我新建了一个MainTab组建，并且将它放置于./app/comp/MainTab.android.js中，android后缀表明编译android应用时选择该js文件作为编译对象，这样你也可以实现MainTab.ios.js，从而可以针对不同的系统采用不同的设计内容。这里我新建了一个app目录用来存放组件相关的代码和资源，我的文件组织目录如下图所示。 修改后的index.android.js如下： 123456789101112131415161718192021222324252627//...import MainTab from './app/comp/MainTab';export default class welone extends Component &#123; render() &#123; //主界面的MainTab组件 let mainComponent = MainTab; return ( //这里是用了Navigator组件，目的是为了以后的导航栏作用 &lt;Navigator initialRoute=&#123;&#123; component: mainComponent &#125;&#125; configureScene=&#123;(route) =&gt; &#123; return Navigator.SceneConfigs.VerticalDownSwipeJump; &#125;&#125; renderScene=&#123;(route, navigator) =&gt; &#123; //这里的组建就是MainTab let Comp = route.component; //MainTab return &lt;Comp &#123;...route.params&#125; navigator=&#123;navigator&#125; /&gt; &#125;&#125; /&gt; ); &#125;&#125;//... 先忽略Navigator组件在这里的作用，这里可以先理解为以MainTab作为当前的视图的根view： 123render() &#123; return &lt;MainTab /&gt;&#125; 在app/comp/MainTab.android.js里，我采用了同样经典的三段式配合3个tab来使用。 1234567891011121314151617181920212223242526272829303132333435//...export default class MainTab extends Component &#123; //... render() &#123; return ( &lt;Container theme=&#123;TianTheme&#125;&gt; //头部标题会跟着tab的切换变化 &lt;Header&gt; //标题内容 &lt;/Header&gt; //主体，显示内容 &lt;Content style=&#123;&#123; backgroundColor: '#f8f9f9' &#125;&#125;&gt; //... &lt;/Content&gt; //底部，显示3个tab &lt;Footer style=&#123;&#123; borderTopWidth: 1, borderTopColor: '#e5e8e8' &#125;&#125;&gt; &lt;FooterTab&gt; &lt;Button onPress=&#123;() =&gt; this.onPressTab(TAB_LOVE)&#125;&gt; &lt;Icon name='ios-heart' /&gt; &lt;/Button&gt; &lt;Button onPress=&#123;() =&gt; this.onPressTab(TAB_ME)&#125;&gt; &lt;Icon name='ios-chatbubbles' /&gt; &lt;/Button&gt; &lt;Button onPress=&#123;() =&gt; this.onPressTab(TAB_SET)&#125;&gt; &lt;Icon name='ios-settings' /&gt; &lt;/Button&gt; &lt;/FooterTab&gt; &lt;/Footer&gt; &lt;/Container&gt; ); &#125;&#125; 其中Container、Header、Content、Footer等组件皆来自于Native-Base。我的建议是能用原始的react-native的组建就用原始的，Native-Base提供的组件虽然美观，但是缺少了定制的灵活性。 当点击tab时，调用回调函数onPressTab()触发view的变化。根据传入的参数确定用户点击的哪一个tab，然后修改当前的状态。注意，这里涉及修改当前组件状态的操作this.setState({ activeTab: tab })，所以回调函数采用&lt;Button onPress={() =&gt; this.onPressTab(TAB_SET)}&gt;，这里是用箭头函数指明了该函数运行的上下文位于该组件中。在不涉及修改state时并无大碍，如果涉及修改state，一定要采用异步操作。记住千万不要在render函数中直接修改state。 1234onPressTab(tab) &#123; //... this.setState(&#123; activeTab: tab &#125;)&#125; 内容显示在MainTab组件中，显示内容的部分需要根据用户的选择依次显示“关注”、“消息”和“设置”三个板块，为此我设计了一个WeiboList组件来显示具体内容，并且作为Content的子组件镶嵌进MainTab。 1234567891011&lt;Content style=&#123;&#123; backgroundColor: '#f8f9f9' &#125;&#125;&gt; &lt;View style=&#123;&#123; marginHorizontal: 7 &#125;&#125;&gt; &lt;WeiboList navigator=&#123;this.props.navigator&#125; //保留weibolist组件的引用 ref=&#123;(weiboList) =&gt; &#123; this.weiboList = weiboList &#125;&#125; //指明当前用户选择的哪一个tab tab=&#123;this.state.activeTab&#125; /&gt; &lt;/View&gt;&lt;/Content&gt; 这里为WeiboList组件添加了属性tab，描述当前用户选择的tab类型。同时，为MainTab保留了一个weibolist的应用，为的是从MainTab组件中调用WeiboList的函数，当然这种设计方式不算优美，将来我会用其它方式进行改进。 在WeiboList组件中，实现render()函数如下： 123456789101112131415161718192021render() &#123; if (this.props.tab === TAB_LOVE) &#123; //关注人的微博列表 return ( &lt;ListView //设置数据源 dataSource=&#123;this.state.loveSource&#125; //列表中的子组件 renderRow=&#123;(rowData) =&gt; &lt;WeiboCard weiData=&#123;rowData&#125; navigator=&#123;this.props.navigator&#125; /&gt;&#125; //列表底部组件 renderFooter=&#123;() =&gt; this.getEnd(GET_MORE_WEIBO)&#125; /&gt; ); &#125; else if (this.props.tab === TAB_ME) &#123; //用户消息 //... &#125; else &#123; //用户设置 //... &#125; &#125; 根据用户选择的板块，返回不同的组件内容。这里主要介绍一下微博内容列表的实现，关于微博登录认证的模块，可以参考源代码。 为了显示列表结构的微博内容，使用了react-native自带的ListView组件，ListView可以滚动的现实View子组件列表。它需要设置两个重要属性，dataSource表示数据数组，renderRow则会将数组中的每一项取出来，渲染一个子组件。这里我设计了WeiboCard来显示微博的具体内容。 dataSourece的数据源来自this.state.loveSource，该状态在WeiboList中进行初始化。 123456789101112constructor(props) &#123; super(props); //创建一个DataSource，并且设置判断当前视图是否发生滚动的判断函数，以此来减少绘制列表的消耗。 let ds1 = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); this.state = &#123; loveSource: ds1, &#125;; //用来存储当前获取的微博内容数组 this.loveData = [];&#125; 到此为止，视图已经设计完毕，但是还没有数据。接下来需要完成获取数据的部分。 数据获取这里采用的微博api的Android版本，是一个java库，幸运的是react-native提供了接口让我们开发原生模块在js中调用。当然，也可以研究一下是否可以直接调用微博的js库。 先看一下微博api中提供了什么样的接口供开发者调用。在com/sina/weibo/sdk/openapi/StatusesAPI.java中，提供了一些与获取微博内容有关的函数，并且提供了详细的文档说明，这里需要使用的就是如下接口。 1234567891011121314151617181920212223/** * 获取当前登录用户及其所关注用户的最新微博。 * * @param since_id 若指定此参数，则返回ID比since_id大的微博（即比since_id时间晚的微博），默认为0 * @param max_id 若指定此参数，则返回ID小于或等于max_id的微博，默认为0。 * @param count 单页返回的记录条数，默认为50。 * @param page 返回结果的页码，默认为1。 * @param base_app 是否只获取当前应用的数据。false为否（所有数据），true为是（仅当前应用），默认为false。 * @param featureType 过滤类型ID，0：全部、1：原创、2：图片、3：视频、4：音乐，默认为0。 * &lt;li&gt;&#123;@link #FEATURE_ALL&#125; * &lt;li&gt;&#123;@link #FEATURE_ORIGINAL&#125; * &lt;li&gt;&#123;@link #FEATURE_PICTURE&#125; * &lt;li&gt;&#123;@link #FEATURE_VIDEO&#125; * &lt;li&gt;&#123;@link #FEATURE_MUSICE&#125; * @param trim_user 返回值中user字段开关，false：返回完整user字段、true：user字段仅返回user_id，默认为false。 * @param listener 异步请求回调接口 */public void friendsTimeline(long since_id, long max_id, int count, int page, boolean base_app, int featureType, boolean trim_user, RequestListener listener) &#123; WeiboParameters params = buildTimeLineParamsBase(since_id, max_id, count, page, base_app, trim_user, featureType); requestAsync(sAPIList.get(READ_API_FRIENDS_TIMELINE), params, HTTPMETHOD_GET, listener);&#125; 在Android项目文件夹下添加了微博模块：android/app/src/main/java/com/welone/weibo/WeiboModule.java。实现了如下函数： 123456789101112131415161718192021222324252627282930313233343536/** * get the status of your friends * * @param sinceId * @param maxId * @param successCallback * @param errorCallback */ @ReactMethod public void getTimeline(String sinceId, String maxId, Callback successCallback, Callback errorCallback) &#123; //获取认证token Oauth2AccessToken token = AccessTokenKeeper.getAccessToken(); if (token != null &amp;&amp; token.isSessionValid()) &#123; if (mStatusesAPI == null) &#123; mStatusesAPI = new StatusesAPI(getCurrentActivity(), Constants.APP_KEY, token); &#125; try &#123; long since = Long.parseLong(sinceId); long max = Long.parseLong(maxId); //调用了friendsTimeline的同步版本，因为该函数已经是异步调用, //没必要再嵌套一次异步调用 String info = mStatusesAPI.friendsTimelineSync(since, max, 20, 1, false, 0, false); if (info != null &amp;&amp; info.length() &gt; 0) &#123; //获取内容成功 successCallback.invoke(info); &#125; else &#123; //获取内容失败 errorCallback.invoke(\"Get weibo error..\"); &#125; &#125; catch (com.sina.weibo.sdk.exception.WeiboException e) &#123; errorCallback.invoke(\"Please open the Internet :)\"); &#125; &#125; else &#123; errorCallback.invoke(\"Get user information: token error..\"); &#125; &#125; 其中@ReactMethod标签指明该函数为一个react-native函数，将会暴露在js部分使用。设计好函数接口，需要讲模块添加到应用包里面。 在android/app/src/main/java/com/welone/weibo/WeiboPackage.java中，创建一个ReactPackage： 12345678910111213141516171819202122public class WeiboPackage implements ReactPackage &#123; //添加自己定制的原生功能模块 @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123; List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;(); //这里目前就一个weibo模块 modules.add(new WeiboModule(reactContext)); return modules; &#125; //可以添加js模块在原生代码中使用 @Override public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() &#123; return Collections.emptyList(); &#125; //定制原生view提供给js部分使用 @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; return Collections.emptyList(); &#125;&#125; 从上面代码可以看出，react-native不仅可以定制功能模块，还可以定制原生view给js使用。 在android/app/src/main/java/com/welone/MainApplication.java下添加ReactPackage： 123456789101112131415161718private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( //react-native自己的包 new MainReactPackage(), //因为使用native-base引入的包 new VectorIconsPackage(), //自己定义的微博包 new WeiboPackage() ); &#125;&#125;; 写好原生部分的模块，接下来考虑如何在js部分进行使用。首先创建文件app/comp/module/WeiboModule.android.js，将定义的模块引入并且暴露。 12345'use strict';import &#123; NativeModules &#125; from 'react-native';export default NativeModules.WeiboModule; 在WeiboList模块调用getTimeline函数： 12345678910111213141516171819202122232425262728293031323334//Get the weibo of the user's friendsgetTimeLine(type) &#123; let since = 0; let max = 0; //调用原生模块实现的函数，参数要一一对应 WeiboModule.getTimeline( since.toString(), max.toString(), //成功的回调函数 (success) =&gt; &#123; if (success.length &gt; 0) &#123; let tl = JSON.parse(success); let statuses = tl.statuses; if (statuses.length &gt; 0) &#123; //获取内容数组 this.loveData = statuses; ToastAndroid.showWithGravity(`有$&#123;statuses.length&#125;条新微博 :)`, ToastAndroid.SHORT, ToastAndroid.CENTER); //更新列表 this.setState(&#123; loveSource: this.state.loveSource.cloneWithRows(this.loveData) &#125;); &#125; &#125; &#125;, //失败的回调函数 (err) =&gt; &#123; ToastAndroid.showWithGravity(err, ToastAndroid.SHORT, ToastAndroid.CENTER); this.gettingTimeLine = false; &#125; );&#125; 实现getTimeLine函数后可以在适当的地方调用，获取微博内容。 到此为止，实现了应用获取微博内容，并且进行显示的功能。其它功能，比如获取评论等，实现过程类似。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"},{"name":"React Native","slug":"React-Native","permalink":"http://itanch.github.io/tags/React-Native/"}]},{"title":"2017书单","date":"2017-04-07T06:56:08.000Z","path":"2017/04/07/2017书单/","text":"书籍是人类退步的滑滑梯 1. 无声告 🏊 结束时间：01-05 推荐指数：🌟🌟🌟🌟 成为自己，还是成为别人期望的自己？ 2. 深入理解Java虚拟机 ☕️ 结束时间：01-29 推荐指数：🌟🌟🌟🌟🌟 了解jvm的设计原理。 3. 深入浅出nodejs 🚀 结束时间：02-15 推荐指数：🌟🌟🌟🌟🌟 了解nodejs的设计原理。 4. Android编程权威指南 ⛳ 结束时间：03-26 推荐指数：🌟🌟🌟🌟 从具体的项目学习Android开发中的组件使用技巧。 5. 程序员面试金典 🀄️ 结束时间：04-07 推荐指数：🌟🌟🌟🌟 很经典的面试指南，对经典的算法考题进行了层层深入的解析。","tags":[{"name":"记录","slug":"记录","permalink":"http://itanch.github.io/tags/记录/"}]},{"title":"用React-Native写一个微博客户端(1)","date":"2017-04-06T12:01:14.000Z","path":"2017/04/06/用React-Native写一个微博客户端-1/","text":"用React-Native技术实现一个简单的微博客户端。项目开源地址：github。项目还在持续更新中😊。 开发环境：macOS 部分效果： 安装如何安装官网很清楚，如果网页打不开可以参考国内文档。 首先安装node和watchman。 12brew install node brew install watchman 然后安装react native cli。 1npm install -g react-native-cli 安装Android开发环境就不再赘述。 创建项目、运行项目。 123react-native init AwesomeProject cd AwesomeProject react-native run-android 这样可以直接将应用在手机上运行起来，并且可以通过晃动手机（😓）来唤出命令界面，进行动态的更新js实现的功能。但是这样的运行的应用性能并不高，仅仅适用于调试，所以还是需要打包进行发布。 打包发布生成签名密钥。 12345678910111213keytool -genkey -v -keystore my-release-key.keystore -alias tianchi -keyalg RSA -keysize 2048 -validity 10000``` `-alias`后的参数你可以起个好听的名字，比如“tianchi”。这里设置了10000天的有效期。 设置gradle变量。多谢这些成熟的构建工具和框架，react-native在创建android项目时已经帮你生成了一个很完善的gradle配置文件，下面需要对其进行修改来满足自己的定制需求。把生成的`my-release-key.keystore`文件放到`android/app`下面，然后在用户Home下创建并且编辑`~/.gradle/gradle.properties`文件：```shMYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=tianchiMYAPP_RELEASE_STORE_PASSWORD=******MYAPP_RELEASE_KEY_PASSWORD=****** 添加签名文件到android/app/build.gradle： 12345678910111213141516//Attention!!! You shuld use your own release key!!!signingConfigs &#123; release &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125;&#125;buildTypes &#123; release &#123; ... signingConfig signingConfigs.release &#125;&#125; 混淆压缩apk。在android/app/build.gradle文件中，修改： 12//Run Proguard to shrink the Java bytecode in release builds.def enableProguardInReleaseBuilds = true 打包和安装。12./gradlew assembleRelease./gradlew installRelease 引入微博api进入微博开发平台，申请一个开发者账号，创建一个移动应用，关键是得到一个app key。然后研究weibo提供的android sdk文档。 这里需要特别注意的是，要想成功使用微博的api，你首先要在微博开发平台&gt;应用信息&gt;测试信息中填写你的测试账号，否则无法登陆。同时，将你的开发的app安装到手机上，用微博提供的app_signatures.apk获得该应用的Android签名，然后填写到微博开发平台&gt;应用信息&gt;基本信息中的Android包名：com.welone和Android签名:xxxx你获得的签名xxxxxxx。完成以上两个步骤才能正常使用微博的api，呵呵。 下面需要通过gradle引入微博的api，官网最近版本已经提供了gradle的引入方式，但是移除了open api的功能。因为我是用的是旧的版本，并且使用了open api，所以引入了一个其他开发者提供的微博api仓库。在android/app/build.gradle中修改如下： 123456789101112repositories &#123; jcenter() maven &#123; url \"https://jitpack.io\" &#125;&#125;//...dependencies &#123; //... compile 'com.github.8tory:weibo-android-sdk:-SNAPSHOT'&#125; 在构建的时候会自动的下载该库进行编译。 让你的UI更好看使用react-native提供的component比较朴素，当然自己可以通过调制创建出漂亮的组建。这里，有NativeBase已经帮我们创建好了，官网提供了很详细的安装教程，这里先安装好，我们将来要使用。其中react-native-vector-icons组件需要特殊的配置一下。 这里主要介绍了开始编写一个react-native的微博客户端的准备工作，下面一章将会详细介绍。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"},{"name":"React Native","slug":"React-Native","permalink":"http://itanch.github.io/tags/React-Native/"}]},{"title":"23个设计模式","date":"2017-02-15T06:10:00.000Z","path":"2017/02/15/32个设计模式/","text":"本篇文章是对Design Patterns: Elements of Reusable Object-Oriented Software的总结。 看完Design Patterns: Elements of Reusable Object-Oriented Software已经有些时日了，现在提笔将其概括总结一下，以备将来的参考。此书总结了23中不同的设计模式，并且将它们的设计目的、结构、用法等方面进行的很好的介绍，是一本值得放在手边随时查阅的工具书。 Creational Patterns 1. Abstract Factory目的为创建一组相关对象，Abstract Factory提供统一的接口，并且不需要指定它们具体是什么类型的。Abstract Factory是和Concrete Factory（简称Factory）相对的一个模式，Factory的功能是创建相关的一组对象，它是具体的。而Abstract Factory则是仅仅提供接口，具体如何创建、创建什么类型的对象由子类Factory来具体实现。也叫Kit。 结构 AbstractFactory: 声明了创建具体产品对象的接口。ConcreteFactory: 实现了创建具体产品对象的函数。AbstractProduct: 声明了某一种产品对象的接口。ConcreteProduct: 定义了具体被创建的一个产品对象。实现了AbstractProduct的接口。Client: 仅仅调用AbstractFactory创建产品，并且使用AbstractProduct的接口。用户无需关心具体使用了哪一个Factory和Product。 何时使用 一个系统需要和它的产品的创建、组成、表示相互独立时。 一个系统需要配置多种产品家族中的一个时。如结构图中所示，有1和2两个产品家族，client只需要配置其中的一个即可，如果配置了1，则client使用的所有product都是1类型的，有ProductA1、ProductB1等。 一族相关联的产品需要一起被使用，不可混用，你可以通过Abstract Factory来加强这种限制。client如果选择使用了1，则应该保证所有的产品都是1家族的产品。比如，一个应用的UI支持windows和mac两种风格，用户选择了windows风格的UI，则应该保证所有的按钮、菜单和边栏等都是windows风格。 你想提供一个product的库，同时你只想暴露它们的接口，而不是如何实现的。 2. Builder目的将一个复杂对象的构建和表示相分离，从而可以使得相同的构建过程创造出不同的表示。 结构 Builder: 声明了一个创建一个产品对象一部分的抽象接口。ConcreteBuilder: 实现Builder定义的接口，可以创建和组装产品的一部分。定义并且保存了它所创建产品的当前表示。同时，它还提供了一个可以获得所创建产品的接口。Director: 使用Builder的提供的接口创建产品对象。Product:表示正在被创建的一个复杂对象。ConcreteBuilder建造了它的内部表示，决定了它组装的过程。它包含了定义它组成部分的类，同时提供了接口让具体Builder来组装这些组成部分。 何时使用 创建一个复杂对象的算法需要独立于对象的组成部分的定义和组装方式。如Director中实现了一个创建产品对象的算法，而对象内部如何组装的则由Builder决定。 一个创建过程可以产生不同的对象表示。比如，Director可以采用不同的ConcreteBuilder来创建产品对象，在Director中创建的过程是相同的，但是由于Builder的不同，导致最后产品的内部结构可能差异很大。 3. Factory Method目的定义一个创建对象的接口，由子类去决定创建哪一个具体的对象。Factory Method可以将实例化对象的过程委派给子类。注意，这里Factory Method强调的是方法，并且该方法极有可能会被子类覆盖。在Abstract Factory中就使用了Factory Method来创建产品。 结构 Product: 定义了Factory method创建的对象的接口。ConcreteProduct: 实现了Product的接口。Creator:定义了Factory Method,factory method会创建某一个类型的产品。它有可能定义一个默认的factory method方法来创建一个具体的产品。ConcreteCreator: 重写factory method来实例化一个ConcreteProduct。 何时使用 一个类不能预料它必须创建的对象属于哪一类。 一个类希望它的子类来决定需要创建的对象。 一个类将责任委派给它的一个子类，你希望将哪一个类被委派的知识本地化。 4. Prototype目的通过一个原型实例来创建一类的对象，创建一个新对象的过程就是拷贝原型实例。这样做可以省去传入参数来创建对象的麻烦，保证每次创建的对象都具有相同的属性。即使需要相同类的不同属性的对象，也可以先进行拷贝，然后通过稍加修改，就可以得到我们想要的对象。 在Nodejs中有prototype的使用。 结构 Prototype: 定义了一个来拷贝自己的接口。ConretePrototype: 实现了克隆自己的操作。Client: 让Prototype克隆自己来创建一个新对象。 何时使用 系统需要独立于它的产品如何创建、组成和表示的时候。 当需要实例化的类在运行才决定时。 想要避免创建一个平行于产品类层次结构的factory层次结构。因为创建一个对象只需要通过原型拷贝，无需使用factory来创建。 当一个类的实例只有为数不多的几个状态组合中的一个时，可以先实例好几个不同状态的对象，每次只需要从这些原型对象中按需拷贝出来新对象即可。 5. Singleton目的保证一个类只有一个实例，并且提供一个可以访问它的全局切入点。 在Android系统中的ActivityManagerService就是一个单例模式。 结构 Singleton: 定义一个实例化函数，可以让用户通过该函数获取该独一无二的实例。Instrance是一个类函数。有些时候，它还要负责创建它独一无二的实例。 何时使用 一个类只能有一个实例对象时，并且需要提供一个公共接口给用户访问该独一无二的实例。 这个孤立的实例对象可以通过继承来扩展，并且用户可以无需修改原来的代码来使用该扩展的实例。 Structural Patterns6. Adapter目的将一个类的接口转化为用户想要的接口形式。Adapter可以让原来接口不相匹配的类进行合作。也叫Wrapper。 结构Adapter使用多继承来实现接口的适配。 Adapter通过组合来实现结构的匹配。 Target: 定义了用户想要使用的接口。Client: 调用目标接口来使用某些对象。Adaptee: 实现了client想要的功能，但是接口并不是client想要的，所以要进行适配。Adapter: 将Adaptee的接口适配成目标接口。 何时使用 你想使用一个现有的类，但是它的接口和你需要的不太匹配。 你想定义一个类，它可以和不相关、不可预见的其它类进行配合使用，这个时候你定义的类没必要适配所有的情况，根据具体情况配置适当的adapter就可以了。 你需要使用很多现成的子类，但是通过继承类修改每一个子类的接口是比较繁琐的，这时候你可以仅仅利用adapter适配它们的父类即可。 7. Bridge目的将一个类的抽象行为和具体实现进行解耦，从而可以使得这两个部分独立变化。也叫做Handle/Body。Bridge和Adapter都有给用户提供适配的接口的作用，但是Adapter更强调让原来不相干的类进行合作，往往类已经设计好了。而Bridge在设计之初，希望让抽象行为和具体实现进行分离。 结构 Abstraction: 定义抽象接口。有一个指向Implementor对象的引用。RefmedAbstraction: 扩展Abstraction的接口。Implementor: 定义了实现类的接口。这些接口没必要和Abstraction的接口保持一致，甚至可以完全不同。通常情况下，Implementor的接口提供的是基本的功能，Abstraction利用这些基本函数来构成更高级的函数功能。ConcreteImplementor: 具体实现了Implementor的接口，定义了具体的实现。 何时使用 你希望避免将抽象行为和具体实现进行永久的绑定在一起。例如，一个类提供的抽象行为没有变化，但是在运行时，这些行为的具体的实现却需要进行变动。 抽象行为和具体实现应该可以通过继承来进行扩展。Bridge可以让及将不同的抽象和实现进行组合，并且可以互不影响的进行扩展。 对具体实现的改变不会影响用户，因为抽象行为没有变化。 你希望对用户隐藏抽象行为的具体实现。 你想共享具体实现部分，并且这种共享对用户而言是透明的，因为用户只能看到抽象行为。 8. Composite目的将对象组合成树的结构来表现部分-整体的层次结构。Composite使得用户可以将个体对象和组合对象统一进行处理。 Android系统中Activity中存放View组件的RootView就是一个典型的Composite。 结构 Component: 为需要进行组合的对象定义了接口。适当的实现所有类共有的默认行为。定义访问、管理子组件的接口。也可以定义访问父节点的接口。Leaf: 表示叶子节点，叶子节点没有子节点。定义了组合中基本对象的函数。Composite: 定义有子节点的组件的行为。存储子节点。实现Component中定义的有关子节点操作的函数。Client: 通过Component提供的接口操作组合结构。 何时使用 你想表现一个部分-整体的层次结构时。 你希望让用户无法感知组合对象和孤立对象的区别，用户可以统一地处理composite结构中所有的对象。 9. Decorator目的动态的给一个对象添加功能。Decorators提供了一个灵活的选择来扩展功能。也叫做Wrapper。 结构 Component: 定义了基本组件的接口。ConcreteComponent: 定义了一个具体组件的类。Decorator: 有一个指向一个Compoent对象的应用，并且有着和Component一样的接口。这样可以保持给用户提供一致的接口，用户可以在不知不觉中使用已经扩展功能的对象。ConcreteDecorator: 给组件添加新的功能。并通过将Component的原始接口和新功能封装在重写的函数中实现行为的一致性。 何时使用 动态地、透明地、不影响其它对象地给某个对象添加新的功能。 可以撤销对象的新功能。 通过继承来实现功能的扩展不切实际时。有时大量的可以扩展的独立功能，但是直接通过继承来实现会导致子类的组合爆炸。继承是需要在编程时写死的，而采用Decorator则可以在运行时动态的组合新的功能。 10. Facade目的为一个子系统的一组接口提供一个统一地接口。Facade定义了一个更高层次的接口，是的子系统更加易于使用。 结构 Facade: 知道在子系统中哪一个类应该对一个请求进行处理，并且将适当的请求交给相应的类。subsystem classes: 实现子系统的功能，处理Facade交给的任务，但是它们并不知道Facade存在。 何时使用 你如果想给一个复杂的系统提供一个简单的接口，请用Facade。子系统会随着升级越来越复杂，可能会导致许多细粒度的类出现，虽然这增加了子系统的可定制性，但是对用户而说却越来越难使用。Facade可以给这些用户提供一个相对简单的视图，只有在用户需要定制子系统时，才需要越过Facade来观察子系统。 在传统的系统中，客户端和子系统之间会产生复杂的依赖关系，而Facade的引入可以很好的将用户和子系统进行解耦，因此可以提升子系统的独立性和可携带性。 将子系统进行层次化。用facade来定义每个子系统的接口，如果子系统之间有依赖关系，你就可以让这些子系统之间只通过他们的facade接口来进行交互，从而简化他们之间的依赖。 11. Flyweight目的通过分享的方式来高效的支持大量的细粒度的对象。 结构 Flyweight: 声明了用来接收和处理外部状态的接口。ConcreteFlyweight: 实现了Flyweight接口，并且有自己的内部状态。ConcreteFlyweight必须是可以共享的。它内部存储的状态必须是与上下文无关的。UnsharedConcreteFlyweight: 不是所有的Flyweight子类都需要被分享，Flyweight并不强制需要被共享。FlyweightFactory: 创建和管理flyweight对象。保证flyweight可以被适当的共享。当用户需要一个flyweight时，FlyweightFactory会根据是否已经有该flyweight而创建或者直接返回一个flyweight对象。Client: 有指向flyweight的引用，同时有flyweight的外部状态。 何时使用当满足一下所有条件时可以使用： 一个应用使用了大量的对象。 因为对象的数量庞大而导致耗费大量的存储资源。 大部分的对象状态可以提出来作为外部状态传入。 当外部状态被提取出来以后，大量的的对象可以被几个可以共享的对象替代。 应用不依赖于对象的独一无二性，因为对用户而言，它们表面上是不同的对象，但是实质上它们是被共享的。 12. Proxy目标为一个对象提供一个代理或者占位符来控制对它的访问。也被称作Surrogate。 在Android系统中，Activity与ActivityManagerService进行进程间通信时，Activity是与ActivityManagerService的Proxy进行直接打交道的。 结构 Proxy: 有着一个指向真正的主体引用。它会提供和主体一样的接口，所以它可以替代主体。控制对真正主体的访问，也可能负责主体的创建和删除。不同种类的proxy: 1. **remote porxy**: 负责对请求和参数进行编码，然后将请求发送给在其它地址空间的真正主体。 2. **virtual proxy**: 缓存部分真正主体的信息，因为它可以延缓访问主体。 3. **protection proxy**: 验证访问者是否有权限发送请求。 Subject: 定义了RealSubject和Proxy的统一接口，所以Proxy可以在任何地方替代RealSubject。RealSubject: 定义了Proxy需要代理的真正对象。 何时使用 remote proxy: 给不在本地空间的对象提供了一个本地表示。 virtual proxy: 在必要时才需求创建昂贵的对象，能拖就拖。 protection proxy: 控制访问原始对象。在一个对象有着不同等级的访问权限时，Protection proxy十分有用。 smart reference: 可以代替指针，在访问主体对象之前可以进行一些附加操作。比如统计有多少个引用指向该主体，在适当的时候可以释放主体；在第一访问时将主体加载到内存；对主体进行加锁等。 Behavioral Patterns13. Chain of Responsibility目的解耦请求的接收对象，使得一个请求可以被多个接收者处理。将这些接收对象串联成链，并且将请求依次传递过去，直到有接收者可以处理这个请求。 在Nodejs中有Connect模块负责在原始的http模块上进一步处理http请求，加入了session、Cookie、body解析等中间件来依次处理http请求。Connect的设计模式的就是典型的Chain of Responsibility。 结构 Handler: 定义了一个处理请求的接口。提供了后继的连接。ConcreteHandler: 处理它需要处理的请求，也可以将请求继续传递下去。Client: 创建一个请求给ConcreteHandler。 何时使用 当不止一个对象可以处理一个请求时，并且接收者的优先级不被告知，那就需要这些接收者自己确定优先级。 你想将一个请求发送给多个对象中的一个，但是不想指明接收者时。 那些可以处理对象的接收者可以动态的被决定。 14. Command目的将请求封装为一个对象，因此可以让你使用不同的请求参数化客户端、列出请求序列，还能够支持撤销等行为。也被称作Action、Transaction。 结构 Command: 声明一个接口来执行一个操作。ConcreteCommand: 定义一个Receiver和action之间的绑定关系。实现Execute函数来在Receiver上执行某些操作。实质上是将receiver和作用其上的Action封装成了一个command的对象，以便记录和撤销。Client: 创建一个ConcreteCommand并且制定它的receiver。Invoker: 让command执行请求。Receiver: 知道如何对请求进行具体的操作。 何时使用 通过一个action来参数化一个对象时。你可以在面向过程的语言中使用回调函数来实现这种定制，回调函数就是先在某些地方注册，在以后某个时间点执行的函数。Command是在面向对象的语言中一种回调函数的替代方式。 在不同的时刻指定、放入队列，和执行请求。如果一个请求的接收者可以在不同的地址空间中，那么你可以将请求封装成command给不同的进程，并且在这些进程中执行这个command。 支持撤销动作。Command可以存储装状态用来撤销自己执行的动作所产生的效果。所有执行过的动作应该放在一个列表中，使用该列表可以实现撤销和重做一系列动作的功能。 可以记录行为日志，可以在crash发生时恢复系统状态。 Command可以让系统建立在由基本操作组成的高级操作之上。在信息系统中，将基本操作封装为高级操作–“事务“是很常见的一种模式。 15. Interpreter目的给定一种语言，在interpreter中定义该语言的语法表示来翻译该语言。 结构 AbstractExpression: 给抽象语法树种所有节点声明抽象的公共翻译接口。TerminalExpression: 实现一个和语法中终结符号相关的的翻译函数。每个语法中的终结符都需要有一个对应的实例。NonterminalExpression: 非终结符表达式。有着一组类型为AbstractExpression的变量，这些变量是该表达式的子表达式。它会提供接口来递归的翻译所有子表达式。Context: 给Interpreter提供上下文环境。Client: 建造一个抽象语法树来表现某一种语法定义的语言。抽象语法树由NonterminalExpression和TerminalExpression构成。Client负责调用翻译函数。 何时使用在需要翻译一种语言时使用Interpreter模式，并且该语言中的语句可以使用抽象语法树来表示。下列情况下使用最佳： 语法比较简单。对于较为复杂的语法，用来表现语法的类的层次结构变得很庞大和不好管理。在语法复杂的时候解析生成器更为适合。他们可以不使用抽象语法树来翻译语句，因此可以节省空间和时间。 效率不是特别的重要的时候。最有效的翻译方式通常不是直接翻译语法树，而是首先将它们转化为其它的形式。例如，正则表达式经常首先被转化成一个状态机。 16. Iterator目的提供了一个可以按序访问集合对象元素的方式，并且无需暴露集合的内部实现。 结构 Iterator: 定义一个访问和遍历元素的接口。ConcreteIterator: 实现Iterator接口，保存当前遍历到的位置。Aggregate: 定义了一个创建Iterator对象的接口。ConcreteAggregate: 实现了穿件Iterator的接口来返回一个合适的ConcreteIterator。 何时使用 访问一个集合的内容，并且无需暴露集合的内部表示。 可以支持多种遍历方式。 可以提供统一的接口来遍历不同的接口（因此可以支持多态的迭代）。 17. Mediator目的定义一个对象来封装一组对象之间的交互。Mediator让对象之间不通过指明的互相引用来减轻它们之间的耦合度，从而可以让你互不影响的变化它们之间的交互。 结构 Mediator: 定义了一个和同伴交流的接口。ConcreteMediator: 实现合作的接口来让这些伙伴对象可以相互协作。它知道并且维护着它的同伴对象。Colleague classes: 每个Colleague类都知道它的Mediator对象。当它想和同伴对象交流的时候，它会通过它的mediator来进行间接的交流。 何时使用 一组对象通过定义良好但方式复杂的方式来交流合作。结果就导致它们之间的依赖结构混乱并且难以理解。 重新使用一个对象是比较困难的，因为它引用着许多其它对象。 一个分布在多个类之间的行为应该很容易被定制，而不需要搞出来很多的子类。 18. Memento目的不用破坏对象的封装性质，获取一个对象的内部状态以便该对象可以恢复原来的状态。也可以被作token。在Android系统中，Activity可以通过savedInstanceState来保存和恢复一个Activity的状态。 结构 Memento：存储Originator对象的内部状态。有originator自己决定需要保存多少的内部状态。它应该保护存储的状态只由originator自己访问。Memento最好有两种接口，Caretaker只能看到一个“狭窄”的接口，它只能将Memento传给其他对象。相反的，Originator应该可以看到一个“宽广”的接口，从而可以让它访问存储的状态，从而恢复到原来的状态。理想情况下，只有产生memento的originator才可以访问memento的内部状态。Originator：创建一个memento来保存它的内部状态快照。使用Memento来恢复它的状态。Caretaker: 安全的保存着memento。不会操作和访问memento的内部状态。 何时使用 一个对象的状态快照需要被保存下来，以后可以用来恢复状态。 直接访问一个对象的内部状态会导致破坏一个对象的封装性，暴露对象的实现细节。 19. Observer目的定义一个一对多的对象之间的依赖关系，因此当一个对象发生改变，所有依赖于它的对象会收到提醒，并且自动的改变状态。可以称作Dependents，Publish-Subscribe模式。在Android系统中，有broadcast/broadcast receiver机制，在nodejs中，同样有event emmiter/listen机制。 结构 Subject: 知道所有的observer，observer的数量时不固定的。提供接口来添加或者移除所有的observer对象。Observer: 给那些需要观察subject变化的对象提供了一个update的接口。ConcreteSubject: 存储了ConcreteObserver感兴趣的状态，当它的状态发生变化时，提醒它的观察者。ConcreteObserver: 有一个指向ConcreteSubject对象的引用，存储了应该和subject一致的状态。实现了Observer的更新接口，来保持与subject状态的一致。 目前，很多使用该模式的系统会进一步解耦合，使得subject和observer相互透明。 何时使用 一个抽象结构中有两个部分，一个依赖于另一个。将这两个部分封装成独立的对象，可以让你独立的修改和重复使用它们。 当一个对象的变化需要需要其他对象跟着变化，但是你不知道有多少对象需要被修改的时候。 当你想让一个对象通知其它对象，而无需关心这些被通知的对象是谁时。一句话，你不想让这些对象紧密耦合的时候。 20. State目的让一个对象可以在它的状态改变时，改变它的行为。使得对象看上去改变了自己的类。也被称作Object for States。 结构 Context: 定义了用户需要的接口。保存着一个定义了当前状态的ConcreteState子类实例。State: 定义了一个用来封装与之对应的行为的接口。ConcreteState subclasses: 每个subclass实现了与状态对应的行为。 何时使用 一个对象的行为依赖于它的状态，它必须在运行时刻根据它的状态改变它的行为。 一个对象的操作有着大量的条件语句依赖于对象的状态。这些状态通常只有可数的几种组合。通常，很多函数含有重复的条件结构。State可以将这些不同的条件分支放到不同的类中。从而，你可以将对象的状态看成独立的对象，这些状态可以相互独立的进行切换。 21. Strategy目的定义了一组算法，并且对每个算法进行了封装，并且他们之间是可以相互切换的。Strategy 让算法可以独立于用户变化。也可以称作Policy。 结构 Strategy: 定义了所有支持的算法的通用接口。Context使用该接口来调用ConcreteStrategy提供的算法。ConcreteStrategy: 使用Strategy定义的接口实现了具体的算法。Context: 它会配置一个ConcreteStrategy对象。保存一个对Strategy对象的引用。提供了可以让Strategy访问数据的接口。 何时使用 一些类只有他们的行为不同，使用Strategy可以让一个类配置多种行为。 你需要不同算法。比如，你可能定义了一些有着不同的时间／空间复杂度的算法。 用户无需知道算法如何使用数据。使用Strategy可以避免暴露复杂的，算法特定的数据结构。 一个类定义了多种行为，导致在函数中有多种条件语句来选择这些行为。为了避免这种繁杂的条件语句，将相关的分支封装成不同的Strategy对象。 22. Template Method目的在函数中定义了算法的骨架，将具体某些步骤交给子类来实现。Template Method让子类重定义部分步骤，而不用改变整个算法的结构。 结构 AbstractClass: 定义了抽象的primitive函数，让子类来具体实现这几步。实现了一个模版方法，决定了算法的骨架。template method 调用了primitive方法，还有一些其他方法。ConcreteClass: 实现了primitive方法，从而达到定制算法某些步骤的目的。 何时使用 实现算法中不可变的部分，将可变的部分交给子类去实现。 当几个子类的函数中有着共同部分行为，可以将这共同的部分在父类中实现，避免代码的重复。有一种通过重构达到一般化的目的。 控制子类的扩展。你可以定义一个template方法在指定位置调用“hook”操作，从而限制子类只能在这些hook的位置进行扩展。 23. Visitor目的表示一个可以对结构体中的元素进行操作的模式。可以对其中的元素添加新的操作，而无需修改该元素对应的类。 结构 Visitor: 给每个结构中的类定义了一个访问函数。函数名指明了它能能够访问的对象。Visitor决定了自己可以访问的元素，通过特定的参数，visitor能够直接的访问这些元素。Concrete Visitor: 实现Visitor声明的每个操作，每个操作位结构中对应的元素实现了算法的一个片段，Concrete Visitor提供了算法的上下文，并且存储了本地状态，可以加速遍历。Element: 定义了可以接受Visitor的接口。ConcreteElement: 实现了接受接口。ObjectStructure: 可以列举自己的element。提供了一个更高层次的接口来让visitor来访问它的元素。可以是一个composite结构，也可以是一个列表、集合等。 何时使用 一个结构体中有着很多接口不同的元素对象，同时你希望对其中的这些元素进行操作。 你需要对一个结构体中的对象进行很多不同的，并且不相关的操作，同时你不希望“污染”这些原有的类。Visitor可以让你将这些无关的操作定义在一个类中。 结构体中对象的类很少变化，但是你常常想对结构添加新的操作。修改结构体中的类的接口，会导致需要重新定义visitor的接口，这些代价很大。所以如果结构体中的类如果常常变化，那么最好还是将操作定义在这些类中，而不要用visitor。 整理完了23个设计模式，经常回顾，必将会受益匪浅。 本文可以转载，但请注明文章来自：http://itanch.github.io/","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://itanch.github.io/tags/设计模式/"}]},{"title":"写在2017的开始","date":"2017-02-14T08:02:40.000Z","path":"2017/02/14/写在2017的开始/","text":"博客的一次搬迁 博客搬迁历史一年前，在依靠github搭建了个人博客后，写了一些文章。一年后liutianchi.com域名没有续费，就被阿里云封掉，所以在github上的博客暂时无法访问。所以，暂时将博客迁移到CSDN继续我的博客之旅。 现在，我放弃购买域名，采用github默认域名继续在http://itanch.github.io/记录我的学习点滴，并且将部分自己认为有价值的文章从CSDN上迁移了过来。 希望新的一年有更多的收获:)。情人节快乐！ 2017博客计划 重新整理一遍32种设计模式 重新整理一遍Android四大组件的运行框架 其它","tags":[{"name":"记录","slug":"记录","permalink":"http://itanch.github.io/tags/记录/"}]},{"title":"Android系统源码阅读(18):Android应用的显示","date":"2017-02-14T07:04:48.000Z","path":"2017/02/14/Android系统源码阅读-18-Android应用的显示/","text":"1. 启动ActivityManagerService在前面第14章讲到，在System进程启动时，会启动系统的一些基本服务。启动就有ActivityManagerService和PackageManagerService。在SystemServer中如下启动ActivityManagerService。 frameworks/base/services/java/com/android/server/SystemServer.java :12// Activity manager runs the show.mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService(); startService就是创建了ActivityManagerService的实例对象mActivityManagerService，然后启动了ActivityManagerService的looper线程。在SystemServer启动了基本服务后，就会调用mActivityManagerService的systemReady函数来启动HomeActivity。 2. 启动HomeActivity目前仍在SystemServer主线程中调用的systemReady函数。该函数又会接着调用startHomeActivityLocked函数来启动HomeActivity，具体如下： frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java :123456789101112131415161718192021222324boolean startHomeActivityLocked(int userId, String reason) &#123; //... //先创建一个启动Home的Intent，Intent的category为android.intent.category.home Intent intent = getHomeIntent(); ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName( aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being // instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); //因为是第一次启动home，所以还没有相应的进程，所以app为null ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //这里开始启动HomeActivity mStackSupervisor.startHomeActivity(intent, aInfo, reason); &#125; &#125; return true; &#125; 这里交给了mStackSupervisor.startHomeActivity函数来启动HomeActivity，然后就会调用startActivityLocked函数。到这里，就开始重复第2章中，启动普通应用的activity的过程了，不再赘述。其中，在Launcher的Manifest中指明了它的类型为android.intent.category.home，所以启动的就是Laucher应用。 3. Launcher展示应用下面从Launcher的onCreate函数开始讲起，部分代码如下： packages/apps/Launcher3/src/com/android/launcher3/Launcher.java :12345678910111213141516LauncherAppState app = LauncherAppState.getInstance();//将该launcher设置为mModel的callback函数mModel = app.setLauncher(this);if (!mRestoring) &#123; if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) &#123; // If the user leaves launcher, then we should just load items asynchronously when // they return. mModel.startLoader(PagedView.INVALID_RESTORE_PAGE); &#125; else &#123; // We only load the page synchronously if the user rotates (or triggers a // configuration change) while launcher is in the foreground //开始加载应用信息 mModel.startLoader(mWorkspace.getRestorePage()); &#125;&#125; 其中mModel是一个LauncherModel对象，它负责加载应用信息。在重载的startLoader函数中： 12345678910111213141516171819202122public void startLoader(int synchronousBindPage, int loadFlags) &#123; //... synchronized (mLock) &#123; //... // Don't bother to start the thread if we know it's not going to do anything if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) &#123; //需要重新加载了，所以先把原来的加载任务停了 // If there is already one running, tell it to stop. stopLoaderLocked(); //创建了一个加载任务 mLoaderTask = new LoaderTask(mApp.getContext(), loadFlags); if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE //... &#125; else &#123; //交给workThread来处理这个任务 sWorkerThread.setPriority(Thread.NORM_PRIORITY); //sWorker是sWorkerThread的Handler sWorker.post(mLoaderTask); &#125; &#125; &#125; &#125; 因为加载所有安装的应用信息是一个比较耗时的过程，所以应该交给一个异步线程来处理。这里先创建了一个加载任务mLoaderTask，然后将它交给sWorkerThread来处理。sWorkerThread是一个HandlerThread，我们知道HandlerThread是一个独立的线程，并且有着自己的looper。mLoaderTask加载任务执行一次就可以结束，但是为什么需要用一个HandlerThread在这里不断等待着其它任务呢？因为桌面上应用可以动态的添加和删除，所以应用的加载可能是频繁的。这里使用HandlerThread可以避免重复的创建加载线程。 下面我们就看LoaderTask.run函数中具体做了哪些任务。 packages/apps/Launcher3/src/com/android/launcher3/LauncherModel.java :12345678910111213141516171819202122232425public void run() &#123; synchronized (mLock) &#123; if (mStopped) &#123; return; &#125; mIsLoaderTaskRunning = true; &#125; // Optimize for end-user experience: if the Launcher is up and // running with the // All Apps interface in the foreground, load All Apps first. Otherwise, load the // workspace first (default). keep_running: &#123; if (DEBUG_LOADERS) Log.d(TAG, \"step 1: loading workspace\"); //启动workspace loadAndBindWorkspace(); if (mStopped) &#123; break keep_running; &#125; waitForIdle(); // second step if (DEBUG_LOADERS) Log.d(TAG, \"step 2: loading all apps\"); //加载应用 loadAndBindAllApps(); &#125; //... &#125; WorkSpace就是Android桌面中的分屏，每个分屏有若干应用。先加载工作区，再加载应用更符合用户的心理预期？函数loadAndBindAllApps会判断是否已经加载过应用，如果已经加载过信息，则直接将app显示在桌面上即可；如果没有，则需要先调用函数loadAllApps，具体内容如下： packages/apps/Launcher3/src/com/android/luancher3/LauncherModel.java :1234567891011121314151617181920212223242526272829303132333435363738394041private void loadAllApps() &#123; final Callbacks oldCallbacks = mCallbacks.get(); // Clear the list of apps mBgAllAppsList.clear(); for (UserHandleCompat user : profiles) &#123; // Query for the set of apps //获取所有的app信息，这里最终还是从PackageManagerService获取的应用信息 final List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user); // Create the ApplicationInfos for (int i = 0; i &lt; apps.size(); i++) &#123; LauncherActivityInfoCompat app = apps.get(i); //把每个应用信息封装成AppInfo // This builds the icon bitmaps. mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache)); &#125; &#125; //... // Huh? Shouldn't this be inside the Runnable below? final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added; mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;(); //这里一直运行在Launcher中创建的一个HandlerThread子线程中 //获取了应用信息后，需要通知主线程进行ui更新，mHandler是主线程的Handler // Post callback on main thread mHandler.post(new Runnable() &#123; public void run() &#123; //这个callback就是launcher final Callbacks callbacks = tryGetCallbacks(oldCallbacks); if (callbacks != null) &#123; //显示所有应用 callbacks.bindAllApplications(added); //... &#125; else &#123; //... &#125; &#125; &#125;); //... &#125; mLauncherApps.getActivityList获取app信息的方法是通过向PackageManager发送请求的方式实现的。下面回到Launcher主线程，开始显示应用图标。首先看一眼这个回调函数： packages/apps/Launcher3/src/com/android/launcher3/Launcher.java :12345678910111213/** * Add the icons for all apps. * * Implementation of the method from LauncherModel.Callbacks. */ public void bindAllApplications(final ArrayList&lt;AppInfo&gt; apps) &#123; //... if (mAppsView != null) &#123; //mAppsView管理着所有应用的view mAppsView.setApps(apps); &#125; //... &#125; mAppsView是一个view的容器，维持了一个AlphabeticalAppsList列表，保存应用的信息。当向其中添加新的应用信息后，会对home上的应用进行更新。当home上的图标被点击后，会触发启动该应用。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(17):Android应用的安装","date":"2017-02-14T07:00:58.000Z","path":"2017/02/14/Android系统源码阅读-17-Android应用的安装/","text":"学到的才是自己的，干活都是扯淡 1. 应用的安装PackageManagerService负责管理应用的安装。在第14章中讲到，SystemService会启动PackageManagerService，那么我们就从SystemService启动PackageManagerService开始分析。 1.1 PackageManagerService.main创建PackageManagerService对象。 frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java :1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; //先创建一个PackageManagerService对象 PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); //将他注册到ServiceManager里面 ServiceManager.addService(\"package\", m); return m; &#125; 1.2 PackageManagerService.PackageManagerServicePackageManagerService的构造函数。 frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186 public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; //... mSettings = new Settings(mPackages);//... synchronized (mInstallLock) &#123; // writer synchronized (mPackages) &#123; //一个PackageManagerService自己的Looper mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/); //线程启动，开启自己的消息循环队列 mHandlerThread.start(); //并且创建了一个Handler该线程 mHandler = new PackageHandler(mHandlerThread.getLooper()); //获取文件路径 File dataDir = Environment.getDataDirectory(); mAppDataDir = new File(dataDir, \"data\"); mAppInstallDir = new File(dataDir, \"app\"); mAppLib32InstallDir = new File(dataDir, \"app-lib\"); mAsecInternalPath = new File(dataDir, \"app-asec\").getPath(); mUserAppDataDir = new File(dataDir, \"user\"); mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\"); sUserManager = new UserManagerService(context, this, mInstallLock, mPackages); // 获取权限配置文件的中的权限 // Propagate permission configuration in to package manager. ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig = systemConfig.getPermissions(); for (int i=0; i&lt;permConfig.size(); i++) &#123; SystemConfig.PermissionEntry perm = permConfig.valueAt(i); BasePermission bp = mSettings.mPermissions.get(perm.name); if (bp == null) &#123; bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN); mSettings.mPermissions.put(perm.name, bp); &#125; if (perm.gids != null) &#123; bp.setGids(perm.gids, perm.perUser); &#125; &#125; //获取共享库 ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries(); for (int i=0; i&lt;libConfig.size(); i++) &#123; mSharedLibraries.put(libConfig.keyAt(i), new SharedLibraryEntry(libConfig.valueAt(i), null)); &#125; //恢复上一次应用安装信息，见1.3 mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false), mSdkVersion, mOnlyCore); /** * Add everything in the in the boot class path to the * list of process files because dexopt will have been run * if necessary during zygote startup. */ final String bootClassPath = System.getenv(\"BOOTCLASSPATH\"); final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\"); File frameworkDir = new File(Environment.getRootDirectory(), \"framework\"); // Gross hack for now: we know this file doesn't contain any // code, so don't dexopt it to avoid the resulting log spew. alreadyDexOpted.add(frameworkDir.getPath() + \"/framework-res.apk\"); // Gross hack for now: we know this file is only part of // the boot class path for art, so don't dexopt it to // avoid the resulting log spew. alreadyDexOpted.add(frameworkDir.getPath() + \"/core-libart.jar\"); /** * 将一些应用dexopt转化 * There are a number of commands implemented in Java, which * we currently need to do the dexopt on so that they can be * run from a non-root shell. */ //... //设备厂商提供的应用 // Collect vendor overlay packages. // (Do this before scanning any apps.) // For security and version matching reason, only consider // overlay packages if they reside in VENDOR_OVERLAY_DIR. File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR); scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0); // 资源型的程序 // Find base frameworks (resource packages without code). scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0); //特权应用 // Collected privileged system packages. final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\"); scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0); // Collect ordinary system packages. final File systemAppDir = new File(Environment.getRootDirectory(), \"app\"); scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all vendor packages. File vendorAppDir = new File(\"/vendor/app\"); try &#123; vendorAppDir = vendorAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all OEM packages. final File oemAppDir = new File(Environment.getOemDirectory(), \"app\"); scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); if (DEBUG_UPGRADE) Log.v(TAG, \"Running installd update commands\"); mInstaller.moveFiles(); // Prune any system packages that no longer exist. final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;(); //... //look for any incomplete package installations ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr(); //clean up list for(int i = 0; i &lt; deletePkgsList.size(); i++) &#123; //clean up here cleanupInstallFailedPackage(deletePkgsList.get(i)); &#125; //delete tmp files deleteTempPackageFiles(); // Remove any shared userIDs that have no associated packages mSettings.pruneSharedUsersLPw(); //... // Now that we know all the packages we are keeping, // read and update their last usage times. mPackageUsage.readLP(); // If the platform SDK has changed since the last time we booted, // we need to re-grant app permission to catch any new ones that // appear. This is really a hack, and means that apps can in some // cases get permissions that the user didn't initially explicitly // allow... it would be nice to have some better way to handle // this situation. int updateFlags = UPDATE_PERMISSIONS_ALL; if (ver.sdkVersion != mSdkVersion) &#123; Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \" + mSdkVersion + \"; regranting permissions for internal storage\"); updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL; &#125; //为申请了特定资源的访问权限的应用分配用户组id updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags); ver.sdkVersion = mSdkVersion; //将应用安装信息保存到本地的配置文件 // can downgrade to reader mSettings.writeLPr(); &#125; // synchronized (mPackages) &#125; // synchronized (mInstallLock) // Now after opening every single application zip, make sure they // are all flushed. Not really needed, but keeps things nice and // tidy. Runtime.getRuntime().gc(); // Expose private service for system components to use. LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl()); &#125; 1.3 Settings.readLPw读取保存的应用信息。frameworks/base/services/core/java/com/android/server/pm/Settings.java :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061boolean readLPw(PackageManagerService service, List&lt;UserInfo&gt; users, int sdkVersion, boolean onlyCore) &#123; FileInputStream str = null; if (mBackupSettingsFilename.exists()) &#123; try &#123; //获取/data/system/packages-backup.xml文件 str = new FileInputStream(mBackupSettingsFilename); //如果backup不存在，则获取/data/system/packages.xml文件 //... &#125; catch (java.io.IOException e) &#123; // We'll try for the normal settings file. &#125; &#125; //... try &#123; if (str == null) &#123; //... str = new FileInputStream(mSettingsFilename); &#125; //用parser解析xml文件 XmlPullParser parser = Xml.newPullParser(); parser.setInput(str, StandardCharsets.UTF_8.name()); //... int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; //获取应用的各项参数 String tagName = parser.getName(); if (tagName.equals(\"package\")) &#123; //获取上次分配给他的应用用户ID，见1.4 readPackageLPw(parser); &#125; else if (tagName.equals(\"permissions\")) &#123; readPermissionsLPw(mPermissions, parser); &#125; else if (tagName.equals(\"permission-trees\")) &#123; readPermissionsLPw(mPermissionTrees, parser); &#125; else if (tagName.equals(\"shared-user\")) &#123; //获取上次分配的共享用户ID，见1.6 readSharedUserLPw(parser); &#125; else if &#123; //... &#125; else &#123; Slog.w(PackageManagerService.TAG, \"Unknown element under &lt;packages&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; str.close(); &#125; catch (XmlPullParserException e) &#123; //... &#125; catch (java.io.IOException e) &#123; //.... &#125; //... return true; &#125; 1.4 Settings.readPackageLPw读取package信息。 frameworks/base/services/core/java/com/android/server/pm/Settings.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void readPackageLPw(XmlPullParser parser) throws XmlPullParserException, IOException &#123; String name = null; //... String idStr = null; String sharedIdStr = null;//... try &#123; name = parser.getAttributeValue(null, ATTR_NAME); realName = parser.getAttributeValue(null, \"realName\"); idStr = parser.getAttributeValue(null, \"userId\"); //... //名字不能为null if (name == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;package&gt; has no name at \" + parser.getPositionDescription()); &#125; else if (codePathStr == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;package&gt; has no codePath at \" + parser.getPositionDescription()); &#125; else if (userId &gt; 0) &#123; //该应用上次已经分配过ID，所以这次还使用该id,见1.5 packageSetting = addPackageLPw(name.intern(), realName, new File(codePathStr), new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags, pkgPrivateFlags); //... &#125; else if (sharedIdStr != null) &#123; userId = sharedIdStr != null ? Integer.parseInt(sharedIdStr) : 0; if (userId &gt; 0) &#123; //如果上次使用的是共享id，则说明上次该app没有独立的id //所以这次不能直接将该id分配给他，要先将其保存起来以后处理 packageSetting = new PendingPackage(name.intern(), realName, new File( codePathStr), new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags, pkgPrivateFlags); //... mPendingPackages.add((PendingPackage) packageSetting); //... &#125; else &#123; //... &#125; &#125; else &#123; //... &#125; &#125; catch (NumberFormatException e) &#123; //... &#125; //... &#125; 1.5 Setttings.addPackageLPw为该package分配UID，创建保存package信息的PackageSetting对象。 frameworks/base/services/core/java/com/android/server/pm/Settings.java :123456789101112131415161718192021222324252627PackageSetting addPackageLPw(String name, String realName, File codePath, File resourcePath, String legacyNativeLibraryPathString, String primaryCpuAbiString, String secondaryCpuAbiString, String cpuAbiOverrideString, int uid, int vc, int pkgFlags, int pkgPrivateFlags) &#123; //每一个app的信息都保存于一个PackageSetting对象中 PackageSetting p = mPackages.get(name); if (p != null) &#123; //该应用已经有对应的PackageSetting对象了，无需再次添加 if (p.appId == uid) &#123; return p; &#125; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate package, keeping first: \" + name); return null; &#125; //为该app创建一个PackageSetting p = new PackageSetting(name, realName, codePath, resourcePath, legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString, vc, pkgFlags, pkgPrivateFlags); p.appId = uid; //在系统中保留值为uid的Linux用户ID，会在下面详解 if (addUserIdLPw(uid, p, name)) &#123; //mPackages保存创建的app PackageSetting对象 mPackages.put(name, p); return p; &#125; return null;&#125; 在系统中保留指定的UID。这里可以看出，一共可以分配10000个uid给应用程序，小于10000的uid是分配给特权用户的。这些特权用户的uid可以通过共享的形式给其它应用使用。例如，一个想修改系统时间的的应用可以共享”android.uid.system”的特权用户的uid，即在配置文件中将它的android:sharedUserId的属性设置为“android.uid.system”。uid不能重复，但是shareduid是可以共享的。 frameworks/base/services/core/java/com/android/server/pm/Settings.java :12345678910111213141516171819202122232425262728293031private boolean addUserIdLPw(int uid, Object obj, Object name) &#123; //分配的uid不能超过LAST_APPLICATION_UID，19999 if (uid &gt; Process.LAST_APPLICATION_UID) &#123; return false; &#125; //分配的uid应该大于等于FIRST_APPLICATION_UID，10000 if (uid &gt;= Process.FIRST_APPLICATION_UID) &#123; int N = mUserIds.size(); final int index = uid - Process.FIRST_APPLICATION_UID; while (index &gt;= N) &#123; //将中间没分配的uid先置为空 mUserIds.add(null); N++; &#125; if (mUserIds.get(index) != null) &#123; //该uid重复了，分配失败 return false; &#125; //正式分配uid，所有的uid被mUserIds管理 mUserIds.set(index, obj); &#125; else &#123; //这里是特权用户的uid if (mOtherUserIds.get(uid) != null) &#123; //uid已经分配过，返回失败 return false; &#125; mOtherUserIds.put(uid, obj); &#125; return true;&#125; 到这里，应用的uid已经分配完成。下面回到1.3，看如何读取shareduid。 1.6 Setttings.readSharedUserLPw读取共享uid。 frameworks/base/services/core/java/com/android/server/pm/Settings.java :123456789101112131415161718192021222324252627282930313233private void readSharedUserLPw(XmlPullParser parser) throws XmlPullParserException,IOException &#123; String name = null; String idStr = null; int pkgFlags = 0; int pkgPrivateFlags = 0; SharedUserSetting su = null; try &#123; name = parser.getAttributeValue(null, ATTR_NAME); idStr = parser.getAttributeValue(null, \"userId\"); int userId = idStr != null ? Integer.parseInt(idStr) : 0; //该共享id是系统应用还是用户类型的应用 if (\"true\".equals(parser.getAttributeValue(null, \"system\"))) &#123; pkgFlags |= ApplicationInfo.FLAG_SYSTEM; &#125; if (name == null) &#123; //... &#125; else if (userId == 0) &#123; //... &#125; else &#123; //在系统中为该应用申请该userId，见1.7 if ((su = addSharedUserLPw(name.intern(), userId, pkgFlags, pkgPrivateFlags)) == null) &#123; //... &#125; &#125; &#125; catch (NumberFormatException e) &#123; //... &#125;//.... &#125; else &#123; XmlUtils.skipCurrentTag(parser); &#125;&#125; 1.7 Settings.addSharedUserLPw添加共享用户。 frameworks/base/services/core/java/com/android/server/pm/Settings.java :1234567891011121314151617181920SharedUserSetting addSharedUserLPw(String name, int uid, int pkgFlags, int pkgPrivateFlags) &#123; SharedUserSetting s = mSharedUsers.get(name); if (s != null) &#123; if (s.userId == uid) &#123; return s; &#125; //添加uid和已经添加的不同，则失败返回 return null; &#125; //mSharedUsers中没有该共享用户id，则创建一个SharedUserSetting s = new SharedUserSetting(name, pkgFlags, pkgPrivateFlags); s.userId = uid; //在系统中为它分配该uid，重复1.6 if (addUserIdLPw(uid, s, name)) &#123; //分配成功，记录下来 mSharedUsers.put(name, s); return s; &#125; return null; &#125; 在1.4中，mPendingPackages保存了一些使用共享用户id的package。现在已经解析完毕共享用户的信息，在1.3 readLPw函数中将会处理这些package了。 frameworks/base/services/core/java/com/android/server/pm/Settings.java :12345678910111213141516171819202122for (int i = 0; i &lt; N; i++) &#123; final PendingPackage pp = mPendingPackages.get(i); Object idObj = getUserIdLPr(pp.sharedId); if (idObj != null &amp;&amp; idObj instanceof SharedUserSetting) &#123; //获得共享用户信息，说明该package使用的共享用户id是有效的，将在下面小节分析 PackageSetting p = getPackageLPw(pp.name, null, pp.realName, (SharedUserSetting) idObj, pp.codePath, pp.resourcePath, pp.legacyNativeLibraryPathString, pp.primaryCpuAbiString, pp.secondaryCpuAbiString, pp.versionCode, pp.pkgFlags, pp.pkgPrivateFlags, null, true /* add */, false /* allowInstall */); if (p == null) &#123; //... continue; &#125; p.copyFrom(pp); &#125; else if (idObj != null) &#123; //该package使用了一个非共享的id &#125; else &#123; //使用的共享id不存在 &#125; &#125; mPendingPackages.clear(); 1.8 PackageManagerService.scanDirLI到此，PackageManagerService已经将上一次保存的应用信息恢复完毕，在1.2中接下来需要进一步安装各个目录下的应用。 frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java :123456789101112131415161718192021222324252627private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) &#123; final File[] files = dir.listFiles(); //依次访问文件夹中的每个apk文件 for (File file : files) &#123; final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) &#123; // Ignore entries which are not packages continue; &#125; try &#123; scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null); &#125; catch (PackageManagerException e) &#123; //删除无效的文件 // Delete invalid userdata apps if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp; e.error == PackageManager.INSTALL_FAILED_INVALID_APK) &#123; if (file.isDirectory()) &#123; mInstaller.rmPackageDir(file.getAbsolutePath()); &#125; else &#123; file.delete(); &#125; &#125; &#125; &#125;&#125; 1.9 PackageManagerService.scanPackageLIframeworks/base/services/core/java/com/android/server/pm/PackageManagerService.java :1234567891011121314 private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; //... PackageParser pp = new PackageParser(); //... final PackageParser.Package pkg; try &#123; //解析目标文件 pkg = pp.parsePackage(scanFile, parseFlags); &#125; catch (PackageParserException e) &#123; //... &#125; //...&#125; 1.10 PackageParser.parsePackageframeworks/base/core/java/android/content/pm/PackageParser.java :123456789public Package parsePackage(File packageFile, int flags) throws PackageParserException &#123; if (packageFile.isDirectory()) &#123; //一个目录下是一个应用 return parseClusterPackage(packageFile, flags); &#125; else &#123; //一个整体的应用 return parseMonolithicPackage(packageFile, flags); &#125; &#125; 1.11 PackageParser.parseMonolithicPackageframeworks/base/core/java/android/content/pm/PackageParser.java :1234567891011 public Package parseMonolithicPackage(File apkFile, int flags) throws PackageParserException &#123; //... final AssetManager assets = new AssetManager(); try &#123; final Package pkg = parseBaseApk(apkFile, assets, flags); pkg.codePath = apkFile.getAbsolutePath(); return pkg; &#125; finally &#123; IoUtils.closeQuietly(assets); &#125;&#125; 1.12 PackageParser.parseBaseApkframeworks/base/core/java/android/content/pm/PackageParser.java :1234567891011121314151617181920212223242526private Package parseBaseApk(File apkFile, AssetManager assets, int flags) throws PackageParserException &#123; //... final String apkPath = apkFile.getAbsolutePath(); mArchiveSourcePath = apkFile.getAbsolutePath(); final int cookie = loadApkIntoAssetManager(assets, apkPath, flags); Resources res = null; XmlResourceParser parser = null; try &#123; res = new Resources(assets, mMetrics, null); assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Build.VERSION.RESOURCES_SDK_INT); //获取AndroidManifest.xml文件 parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME); //解析AndroidManifest.xml文件 final Package pkg = parseBaseApk(res, parser, flags, outError); //... return pkg; &#125; catch (PackageParserException e) &#123; //... &#125; finally &#123; IoUtils.closeQuietly(parser); &#125;&#125; frameworks/base/core/java/android/content/pm/PackageParser.java :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; final boolean trustedOverlay = (flags &amp; PARSE_TRUSTED_OVERLAY) != 0; AttributeSet attrs = parser; final String pkgName; final String splitName; try &#123; Pair&lt;String, String&gt; packageSplit = parsePackageSplitNames(parser, attrs, flags); //获取package名称 pkgName = packageSplit.first; splitName = packageSplit.second; &#125; catch (PackageParserException e) &#123; //... &#125; //创建Package对象 final Package pkg = new Package(pkgName); boolean foundApp = false; TypedArray sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifest); //应用版本信息 pkg.mVersionCode = pkg.applicationInfo.versionCode = sa.getInteger( com.android.internal.R.styleable.AndroidManifest_versionCode, 0); //... //用户共享id String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifest_sharedUserId, 0); if (str != null &amp;&amp; str.length() &gt; 0) &#123; String nameError = validateName(str, true, false); if (nameError != null &amp;&amp; !\"android\".equals(pkgName)) &#123; outError[0] = \"&lt;manifest&gt; specifies bad sharedUserId name \\\"\" + str + \"\\\": \" + nameError; mParseError = PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID; return null; &#125; //设置共享id后表示要和其它应用共享一个id pkg.mSharedUserId = str.intern(); pkg.mSharedUserLabel = sa.getResourceId( com.android.internal.R.styleable.AndroidManifest_sharedUserLabel, 0); &#125; //... while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"application\")) &#123; //... //进一步解析application项的内容 if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123; return null; &#125; //... &#125; else if (tagName.equals(\"uses-permission\")) &#123; //获取申请的权限 if (!parseUsesPermission(pkg, res, parser, attrs)) &#123; return null; &#125; &#125; //...&#125; return pkg; &#125; 一个应用可以申请多个权限，应用权限是和用户组ID对应的。应用申请权限就是获得该用户组id的过程。 1.13framework/base/core/java/android/content/pm/PackageParser.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private boolean parseBaseApplication(Package owner, Resources res, XmlPullParser parser, AttributeSet attrs, int flags, String[] outError) throws XmlPullParserException, IOException &#123; final int innerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); //解析出activity if (tagName.equals(\"activity\")) &#123; Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.activities.add(a); &#125; else if (tagName.equals(\"receiver\")) &#123; //解析出receiver Activity a = parseActivity(owner, res, parser, attrs, flags, outError, true, false); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.receivers.add(a); &#125; else if (tagName.equals(\"service\")) &#123; //解析service Service s = parseService(owner, res, parser, attrs, flags, outError); if (s == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.services.add(s); &#125; else if (tagName.equals(\"provider\")) &#123; //解析provider Provider p = parseProvider(owner, res, parser, attrs, flags, outError); if (p == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.providers.add(p); &#125; &#125; //... return true; &#125; 1.14 下面步骤笼统讲一下到这里，PackageManagerService已经解析完成一个apk文件。下面回到1.9 scanPackageLI中，继续下面的工作。1.9步中会调用重载函数scanPackageLI继续解析获得的package。重载函数会调用scanPackageDirtyLI来分析package。 这一步会为package分配id，当然该package可能使用的是一个共享id。首先，每个package信息会被保存在一个PackageSetting对象中，然后将其放到mPackages这个HashMap中。 因为在前面步骤中已经从上一次安装的应用信息中读取了一些package信息，所以需要先在HashMap中确定一下这个新解析的应用是否是已经在mPackages中。如果已经存在，说明这是一个老应用，就直接将PackageSetting 返回。如果不在，则新建一个PackageSetting，下面开始为它分配uid： 1. 使用共享id。将pkg的uid设置为想要共享的uid。 2. 使用原来的uid。禁用的系统程序使用它原来的uid。 3. 使用新的uid。创建一个新的uid给pkg。 4. 使用first application uid。所有应用使用同一个uid。 下面来看一下如何为新的应用分配新uid。mUserIds管理了所有的分配给用户的uid，这里会在规定的范围内找到一个uid分配。 到此为止，所有的安装了应用都存在PackageManagerService的mPackages中，下面需要依次为这些应用分配权限。在设备/system/etc/permissions/platform.xml文件中，表述了该设备的资源访问权限列表。如： 123&lt;permission name=\"android.permission.BLUETOOTH\" &gt; &lt;group gid=\"net_bt\" /&gt;&lt;/permission gid指明了该资源权限所在的用户组，当然一个权限可以拥有多个用户组。应用获取权限就是加入相应的用户组。Package的申请的权限已经保存到它对应的PackageSetting对象中，如果当前package使用的是共享uid，则它获得权限与它共享的linux用户的资源权限相同。对于有自己独立uid的应用，它会首先获得一组默认的用户权限，这是所有应用都具有的基本权限。然后会一一验证应用申请的权限是否合法，如果合法，则会为其增加该项权限。 现在，应用已经被安装、分配uid和分配权限，接下来需要将这些应用的信息保存下来以备下次使用。保存的位置就是/data/system/packages.xml。注意，在保存uid时，userId和sharedUserId只能有一个。 Android系统就是通过用户id和用户组id来限制应用的资源访问权限，防止破坏其它应用的数据。分配的uid和gid会在创建应用进程时使用，是该进程在特定的用户组下运行。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(16):Android应用线程的消息循环模型","date":"2017-02-14T06:53:14.000Z","path":"2017/02/14/Android系统源码阅读-16-Android应用线程的消息循环模型/","text":"读书不宜拖沓 0. 背景Android应用的主线程为ActivityThread，在第（10）章已经讲过，它主要负责处理界面事件，所以开发者应该避免在主线程中处理耗时的任务。为了减轻主线程的负担，开发者应该启用多线程来处理耗时的任务。在Android中可以创建多种线程，有的线程可以有自己的消息循环，有的线程则可以向主线程发送消息来使得界面发生改变。 ##1. 主线程的消息循环 应用程序的主线程创建过程如下：ActivityManagerService线程请求Zygote进程创建应用进程；Zygote通过fork来创建一个新进程，新进程将ActivityThread的main作为入口进入Looper循环；Looper会调用静态成员函数prepareMainLooper创建一个Looper对象，并且在该应用进程中，该方法只会调用一次，因为只有一个主线程。 2. 子线程HandlerThreadAndroid应用中，创建子线程可以和java桌面应用一样，创建一个Thread子类，实现run函数，然后start即可。但是这种方式是没有消息循环的，是一种比较简单的方法。 另一种则是使用Android定制版的Thread–HandlerThread。HanlderThre ad的实现也很简单，完全可以模仿它实现一个自己的带有消息循环的Thread，或者实现一个集成HandlerThread的子类。 frameworks/base/core/java/android/os/HandlerThread.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/** * Handy class for starting a new thread that has a looper. The looper can then be * used to create handler classes. Note that start() must still be called. */public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; /** * Constructs a HandlerThread. * @param name * @param priority The priority to run the thread at. The value supplied must be from * &#123;@link android.os.Process&#125; and not from java.lang.Thread. */ public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; /** * Call back method that can be explicitly overridden if needed to execute some * setup before Looper loops. */ protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); //准备了looper Looper.prepare(); synchronized (this) &#123; //获得自己的looper mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); //进入消息循环 Looper.loop(); mTid = -1; &#125; /** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason is isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */ public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; /** * Quits the handler thread's looper. * &lt;p&gt; * Causes the handler thread's looper to terminate without processing any * more messages in the message queue. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p class=\"note\"&gt; * Using this method may be unsafe because some messages may not be delivered * before the looper terminates. Consider using &#123;@link #quitSafely&#125; instead to ensure * that all pending work is completed in an orderly manner. * &lt;/p&gt; * * @return True if the looper looper has been asked to quit or false if the * thread had not yet started running. * * @see #quitSafely */ public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; /** * Quits the handler thread's looper safely. * &lt;p&gt; * Causes the handler thread's looper to terminate as soon as all remaining messages * in the message queue that are already due to be delivered have been handled. * Pending delayed messages with due times in the future will not be delivered. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p&gt; * If the thread has not been started or has finished (that is if * &#123;@link #getLooper&#125; returns null), then false is returned. * Otherwise the looper is asked to quit and true is returned. * &lt;/p&gt; * * @return True if the looper looper has been asked to quit or false if the * thread had not yet started running. */ public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; /** * Returns the identifier of this thread. See Process.myTid(). */ public int getThreadId() &#123; return mTid; &#125;&#125;``` 从HandlerThread的源码可以看出它提供了基本的开关功能，使用起来也很简单方便。具体如何使用如下：首先实例化一个HandlerThread对象，然后启动这个thread。```javaHandlerThread handleThread = new HandlerThread(\"Handler Thread\");//然后启动它，因为HandlerThread是Thread的子类，所以启动方法并无差异handleThread.start(); 然后创建一个实现了Runnable接口的类。 12345678public class ThreadTask implements Runnable&#123; public ThreadTask()&#123; &#125; //重写该方法 public void run()&#123; //你的任务 &#125;&#125; 创建一个Runnable的实例对象，然后丢给HandleThread来处理。 12345ThreadTask threadTask = new ThreadTask();//为HandlerThread的Looper创建一个HandlerHandler handler = new Handler(handlerThread.getLooper);//通过Handler将任务给HandlerThread来执行handler.post(threadTask); 在消息队列处理到该任务时，threadTask的run函数就会被调用执行。 3. 异步任务AsyncTask一个AsyncTask的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private class MyTask extends AsyncTask&lt;String, Integer, String&gt; &#123; //这一步是在主线程中被调用的 //onPreExecute方法用于在执行后台任务前做一些UI操作 @Override protected void onPreExecute() &#123; Log.i(TAG, \"onPreExecute() called\"); textView.setText(\"loading...\"); &#125; //这一步是异步线程的主要过程 //doInBackground方法内部执行后台任务,不可在此方法内修改UI @Override protected String doInBackground(String... params) &#123; Log.i(TAG, \"doInBackground(Params... params) called\"); //... return new String(baos.toByteArray(), \"gb2312\"); &#125; //这一步是在主线程中调用 //onProgressUpdate方法用于更新进度信息 @Override protected void onProgressUpdate(Integer... progresses) &#123; Log.i(TAG, \"onProgressUpdate(Progress... progresses) called\"); progressBar.setProgress(progresses[0]); textView.setText(\"loading...\" + progresses[0] + \"%\"); &#125; //主线程调用 //onPostExecute方法用于在执行完后台任务后更新UI,显示结果 @Override protected void onPostExecute(String result) &#123; Log.i(TAG, \"onPostExecute(Result result) called\"); textView.setText(result); execute.setEnabled(true); cancel.setEnabled(false); &#125; //主线程调用 //onCancelled方法用于在取消执行中的任务时更改UI @Override protected void onCancelled() &#123; Log.i(TAG, \"onCancelled() called\"); textView.setText(\"cancelled\"); progressBar.setProgress(0); execute.setEnabled(true); cancel.setEnabled(false); &#125; &#125; 子线程如果想向主线程发送消息，则需要通过主线程的Handler。这里AsyncTask运行于子线程，但是无需Handler也可以向主线程发送消息。AsyncTask类的具体实现如下。 frameworks/base/core/java/android/os/AsyncTask.java :1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; //... //负责创建线程，放入sPoolWorkQueue中 private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125; &#125;; //任务队列 //如果队列已空，则试图获取任务的线程则会阻塞 //如果队列已满，试图向其中加入任务的线程也会阻塞 private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); /** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. * 一个线程池，用来执行sPoolWorkQueue中的任务，下面看其如何执行线程 * 这里设置了核心线程数，最大线程数等参数 */ public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); /** * An &#123;@link Executor&#125; that executes tasks one at a time in serial * order. This serialization is global to a particular process. * 该线程执行器是顺序执行 */ public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static final int MESSAGE_POST_RESULT = 0x1; private static final int MESSAGE_POST_PROGRESS = 0x2; private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; //创建当前线程的一个handler，如主线程 private static InternalHandler sHandler; private final WorkerRunnable&lt;Params, Result&gt; mWorker; private final FutureTask&lt;Result&gt; mFuture; //...&#125; sThreadFactory，sPoolWorkQueue和THREAD_POOL_EXECUTOR都是全局静态变量。在一个App进程中，因此，所有使用AsyncTask的异步线程使用的是同一个线程池，这样可以避免创建多个线程池占用资源。 ThreadPoolExecutor在执行任务时，会根据实际情况选择是否创建线程，具体如下： 线程池中的线程数量小于核心线程数，则会创建新的线程来执行新添加的任务。 如果大于核心线程数，小于最大线程数，则 sPoolWorkQueue未满，则将新任务保存在队列中 如果已满，则创建一个新的线程来执行新的任务 如果线程池中线程数已经大于/等于最大线程数，如果队列不满，则放入队列；如果已满，则拒绝新任务。 InternalHandler类的实例对象sHandler是创建AsyncTask的线程的Handler，这里假设是主线程。 frameworks/base/core/java/android/os/AsyncTask.java :123456789101112131415161718192021222324private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; //这个函数是运行在主线程中 AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result //异步任务执行结束后发送结果，这里处理这个结果 result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: //异步任务实行过程中，会使用publishProgress来发布中间结果 //这一步就是主线程处理该中间结果 result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 其中result是一个AsyncTaskResult，里面保存了结果信息和其对应的AsyncTask。 frameworks/base/core/java/android/os/AsyncTask.java :12345678910@SuppressWarnings(&#123;\"RawUseOfParameterizedType\"&#125;)private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; WorkerRunnable类的实例mWorker实现如下，保存了异步任务的输入数据： frameworks/base/core/java/android/os/AsyncTask.java :123private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams;&#125; 了解了AsyncTask的成员变量后，下面看一个异步任务创建的完整过程。 3.1 AsyncTask的构造函数frameworks/base/core/java/android/os/AsyncTask.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. * 看来AsyncTask只能在主线程中创建啊！ */ public AsyncTask() &#123; //这里实现了一个WorkerRunnable的匿名类，同时实例化了一个对象mWorker //这里面封装了所要执行的任务 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; //异步线程里执行的任务 public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked //这里有用户定义的所要执行的任务 Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); &#125; &#125;; //又将mWorker封装如FutureTask，同样封装了要执行的任务 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125;``` ### 3.2 AsyncTask的执行在主线程中运行AsyncTask时，需要调用execute来执行该任务，该方法又会调用如下函数来执行任务。这里需要注意的是execute函数是运行在主线程中的，异步任务还没开始。*frameworks/base/core/java/android/os/AsyncTask.java* :```java @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; //... mStatus = Status.RUNNING; //在主线程里运行执行前的任务 onPreExecute(); mWorker.mParams = params; //exec是一个SerialExecute exec.execute(mFuture); return this; &#125; SerialExecutor执行器的执行过程。frameworks/base/core/java/android/os/AsyncTask.java :1234567891011121314151617181920212223242526272829private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; //把mFuture封装入Runnable，然后放在队列mTasks中 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; //在结束该任务之前，把队列的下一个任务放入线程池 scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; //开始执行队列中的第一个任务 scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; //第一个任务放入线程池执行 THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 到这里已经将任务交给线程池来启动，用户定义的doInBackground已经开始运行。 3.3 异步线程发送消息异步线程可以通过publishProgress发送消息，具体实现如下：12345678@WorkerThread protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; //获得主线程的handler--sHandler，通过它向主线程发送消息 getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; 主线程通过sHandler的handleMessage函数来处理该消息，然后调用用户自己实现的onProgressUpdate函数来实现UI的更新。 3.4 异步任务结束在异步线程执行完任务后，会调用FutureTask的done函数来处理结束事件。这里主要处理的就是异步任务处理完成后，最后的返回值。最后的结果通过如下函数发送给主线程。 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; 前面已经讲过，主线程会调用handler里的result.mTask.finish(result.mData[0])来处理结果。finish函数实现如下： 12345678910private void finish(Result result) &#123; if (isCancelled()) &#123; //这些都是用户可以重写的 //来实现自己的功能 onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 4. 总结这里主要介绍了android应用里的几种线程的运行机制。 普通java线程Thread是最简单的一种方法，但是比较难管理，与主线程通信主要靠handler。而且，该中线程只能向主线程发消息，而主线程无法向子线程发消息。 HandlerThread则是可以有自己的looper和消息队列，将任务发送入消息队列来实现异步任务的处理，同时还方便管理。主线程和子线程可以通过对方的Handler相互发送消息。 AsyncTask是比较适用于Android应用的一种异步任务实现方式。虽然归根结底还是通过handler来向主进程发消息，但是整个异步任务执行过程的划分和管理更为科学，屏蔽了内部实现的复杂，为用户提供了更为简单实用的接口。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(15):Android应用进程的启动","date":"2017-02-14T06:46:42.000Z","path":"2017/02/14/Android系统源码阅读-15-Android应用进程的启动/","text":"自己开心就好，何必管他人烦恼 1. 应用进程创建ActivityManagerService负责管理应用进程的创建。这一节会讲述如何从ActivityManagerService申请创建一个app进程，然后从zygote克隆一个进程的过程。 1.1 ActivityManagerService.startProcessLockedframeworks/base/services/core/java/com/android/server/am/ActivityManagerService.java :12345678910111213141516171819202122232425262728 private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;//... try &#123; //... int uid = app.uid; int[] gids = null; int mountExternal = Zygote.MOUNT_EXTERNAL_NONE; //... app.gids = gids; app.requiredAbi = requiredAbi; app.instructionSet = instructionSet; // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. boolean isActivityProcess = (entryPoint == null); //Android应用的进程入口android.app.ActivityThread if (entryPoint == null) entryPoint = \"android.app.ActivityThread\"; //启动app进程 Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); //... &#125; catch (RuntimeException e) &#123; // XXX do better error recovery. //... &#125; &#125; 1.2 Process.start这一步直接交给下一步来处理。 1.3 Process.startViaZygoteframeworks/base/core/java/android/os/Process.java :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Starts a new process via the zygote mechanism. * * @param processClass Class name whose static main() to run * @param niceName 'nice' process name to appear in ps * @param uid a POSIX uid that the new process should setuid() to * @param gid a POSIX gid that the new process shuold setgid() to * @param gids null-ok; a list of supplementary group IDs that the * new process should setgroup() to. * @param debugFlags Additional flags. * @param targetSdkVersion The target SDK version for the app. * @param seInfo null-ok SELinux information for the new process. * @param abi the ABI the process should use. * @param instructionSet null-ok the instruction set to use. * @param appDataDir null-ok the data directory of the app. * @param extraArgs Additional arguments to supply to the zygote process. * @return An object that describes the result of the attempt to start the process. * @throws ZygoteStartFailedEx if process start failed for any reason */private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); //设置一些基本参数 // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(\"--runtime-args\"); argsForZygote.add(\"--setuid=\" + uid); argsForZygote.add(\"--setgid=\" + gid); //... argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion); // --setgroups is a comma-separated list if (gids != null &amp;&amp; gids.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"--setgroups=\"); int sz = gids.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(gids[i]); &#125; argsForZygote.add(sb.toString()); &#125; if (niceName != null) &#123; argsForZygote.add(\"--nice-name=\" + niceName); &#125; if (seInfo != null) &#123; argsForZygote.add(\"--seinfo=\" + seInfo); &#125; if (instructionSet != null) &#123; argsForZygote.add(\"--instruction-set=\" + instructionSet); &#125; if (appDataDir != null) &#123; argsForZygote.add(\"--app-data-dir=\" + appDataDir); &#125; argsForZygote.add(processClass); if (extraArgs != null) &#123; for (String arg : extraArgs) &#123; argsForZygote.add(arg); &#125; &#125; //继续交给下一步处理，这里通过函数openZygoteSocketIfNeeded和Zygote建立了连接 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125; 函数openZygoteSocketIfNeeded会在zygote地址上建立一个socket连接，然后创建一个input stream和output stream。 1.4 Process.zygoteSendArgsAndGetResultframeworks/base/core/java/android/os/Process.java :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Sends an argument list to the zygote process, which starts a new child * and returns the child's pid. Please note: the present implementation * replaces newlines in the argument list with spaces. * * @throws ZygoteStartFailedEx if process start failed for any reason */private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; //直接用已经建立好的input stream writer.write(Integer.toString(args.size())); writer.newLine(); //依次写入每个参数 int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); if (arg.indexOf('\\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx( \"embedded newlines not allowed\"); &#125; writer.write(arg); writer.newLine(); &#125; writer.flush(); //获取创建进程的结果，如果进程pid小于0，则说明没有创建成功 // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); result.pid = inputStream.readInt(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; result.usingWrapper = inputStream.readBoolean(); return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125;&#125; ###1.5 ZygoteInit.runSelectLoopActivityManagerService通过socket将参数传递给zygote进程后，创建app进程的任务就交给zygote继续实现了。让我们再次回到zygote的循环中。 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java ：123456789101112131415161718192021222324252627282930313233343536373839private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; //ActivityManagerService和我建立连接 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; //处理ActivityManagerService发送的请求 boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 1.6 ZygoteConnection.runOnceframeworks/base/core/java/com/android/internal/os/ZygoteConnection.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Reads one start command from the command socket. If successful, * a child is forked and a &#123;@link ZygoteInit.MethodAndArgsCaller&#125; * exception is thrown in that child while in the parent process, * the method returns normally. On failure, the child is not * spawned and messages are printed to the log and stderr. Returns * a boolean status value indicating whether an end-of-file on the command * socket has been encountered. * * @return false if command socket should continue to be read from, or * true if an end-of-file has been encountered. * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main() * method in child process */boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; //读取传入的参数 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; //... &#125; if (args == null) &#123; // EOF reached. closeSocket(); return true; &#125; /** the stderr of the most recent request, if avail */ PrintStream newStderr = null; if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123; newStderr = new PrintStream( new FileOutputStream(descriptors[2])); &#125; int pid = -1; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; try &#123; //... //fork一个进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (ErrnoException ex) &#123; //... &#125; try &#123; if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; //在子进程中进一步处理 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 1.7 ZygoteConnection.handleChildProcframeworks/base/core/java/com/android/internal/os/ZygoteConnection.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Handles post-fork setup of child proc, closing sockets as appropriate, * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller * if successful or returning if failed. * * @param parsedArgs non-null; zygote args * @param descriptors null-ok; new file descriptors for stdio if available. * @param pipeFd null-ok; pipe for communication back to Zygote. * @param newStderr null-ok; stream to use for stderr until stdio * is reopened. * * @throws ZygoteInit.MethodAndArgsCaller on success to * trampoline to code that invokes static main. */ private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; /** * By the time we get here, the native code has closed the two actual Zygote * socket connections, and substituted /dev/null in their place. The LocalSocket * objects still need to be closed properly. */ closeSocket(); ZygoteInit.closeServerSocket(); if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; // End of the postFork event.//... if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); &#125; else &#123; //继续初始化进程 RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125; &#125; 1.8 RuntimeInit.zygoteInit这里开始调用android.app.ActivityThread的main函数。 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java :12345678910111213public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); //启动Binder线程池，将在下面详细分析native部分 nativeZygoteInit(); //这里调用的不再是system的main函数了，而是ActivityThread的main函数，将在下面章节分析 applicationInit(targetSdkVersion, argv, classLoader);&#125; 到这里一个Android app的进程就已经创建好了。 2. Binder线程池的启动App进程创建过程中会建立一个Binder线程池，用来处理进程间的Binder通信。 2.1 RuntimeInit.nativeZygoteInitframeworks/base/core/jni/AndroidRuntime.cpp : 这里直接调用了一个AndroidRuntime全局对象gCurRuntime的onZygoteInit函数。这个全局对象是在zygote进程中创建了，这里是通过复制zygote的进程获得的该对象。 2.2 AppRuntime.onZygoteInitframeworks/base/cmds/app_main.cpp :123456virtual void onZygoteInit() &#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV(\"App process: starting thread pool.\\n\"); proc-&gt;startThreadPool(); &#125; 2.3 ProcessState.startThreadPool启动Binder线程池线程， app进程从而具有进程间binder通信的能力。frameworks/native/libs/binder/PorcessState.cpp :123456789void ProcessState::startThreadPool()&#123; AutoMutex _l(mLock); if (!mThreadPoolStarted) &#123; mThreadPoolStarted = true; //启动一个Binder线程池的线程，从而可以支持Binder进程间通信了 spawnPooledThread(true); &#125;&#125; 3. App进程消息循环的创建在1.8中，RuntimeInit调用函数applicationInit来启动ActivityThread的main函数。 3.1 RuntimeInit.applicationInit设置了heap的目标使用率，然后调用了下一步的静态函数。 3.2 RuntimeInit.invokeStaticMain这一步终于开始从这个创建的新进程中调用ActivityThread的main函数了。不过调用的方式有点奇怪，这里是通过抛出一个异常的形式，来清空当前栈中的积压的函数，直到回退到ZygoteInit.main函数中。因为该app进程是从zygote进程中fork出来的，所以栈的内容也是相同的，所以可以会退到ZygoteInit.main函数。 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java :12345678910111213141516171819202122232425262728293031323334353637/** * Invokes a static \"main(argv[]) method on class \"className\". * Converts various failing exceptions into RuntimeExceptions, with * the assumption that they will then cause the VM instance to exit. * * @param className Fully-qualified class name * @param argv Argument vector for main() * @param classLoader the classLoader to load &#123;@className&#125; with */ private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; //通过类名加载该类，这里就是ActivityThread类 cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; //... &#125; Method m; try &#123; //获得ActivityThread的main方法 m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; //... &#125;//... /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. * 这里通过抛出异常来回到stack中的某一个函数的做法还真是头一次见 */ throw new ZygoteInit.MethodAndArgsCaller(m, argv); &#125; 3.3 ZygoteInit.main在Zygote进程里，会进入无限的循环。但是，在app进程里，进入这个循环是没有作用，所以需要跳出循环，继续前进。123456789101112131415161718public static void main(String argv[]) &#123; try &#123; //... Log.i(TAG, \"Accepting command socket connections\"); //Zygote进程会一直在循环中 //虽然app进程在这个循环里创建，但是它需要跳出这个循环，才能继续执行 runSelectLoop(abiList); closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; //所以app进程就跳到了这里 caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125;&#125; 3.4 MethodAndArgsCaller.run这里就是回到ZygoteInit.main里调用ActivityThread的main函数，目的就是清理准备app进程中形成的调用堆栈。 12345678public void run() &#123; try &#123; //就是调用了ActivityThread的main函数 mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; //... &#125;&#125; ActivityThread.main这里就是回到我们熟悉的剧情了，不再赘述。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(14):Zygote和System进程的启动","date":"2017-02-14T06:33:16.000Z","path":"2017/02/14/Android系统源码阅读-14-Zygote和System进程的启动/","text":"再不学习我们就老了 0. Zygote有什么卵用？Zygote是进程孵化器，Android系统中其他服务进程都是拷贝于它。Zygote在设计模式中对应于prototype，这样做的好处是可以通过拷贝Zygote来快速创建一个进程。 1. Zygote脚本启动在开机时，init进程会调用如下脚本启动进程。 system/core/rootdir/init.zygote32_64.rc :12345678service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks service表明该进程是作为一个服务来启动的，--start-system-server指明了该进程启动后，需要启动system服务。该进程对应的端口权限660，名字为zygote，其它进程可以通过该端口和它进行通信。 1.1 init进程创建新的app_process在init进程中，启动service进程的过程如下。 system/core/init/init.cpp :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void service_start(struct service *svc, const char *dynamic_args) //... NOTICE(\"Starting service '%s'...\\n\", svc-&gt;name); //创建新进程 pid_t pid = fork(); //在新建的进程中 if (pid == 0) &#123; struct socketinfo *si; struct svcenvinfo *ei; char tmp[32]; int fd, sz; //依次创建service中的socket for (si = svc-&gt;sockets; si; si = si-&gt;next) &#123; int socket_type = ( !strcmp(si-&gt;type, \"stream\") ? SOCK_STREAM : (!strcmp(si-&gt;type, \"dgram\") ? SOCK_DGRAM : SOCK_SEQPACKET)); //创建socket int s = create_socket(si-&gt;name, socket_type, si-&gt;perm, si-&gt;uid, si-&gt;gid, si-&gt;socketcon ?: scon); if (s &gt;= 0) &#123; //发布socket publish_socket(si-&gt;name, s); &#125; &#125; //... //将参数拷贝进svc结构体中 if (!dynamic_args) &#123; //没有参数的情况 //svc-&gt;args[0]对应于/system/bin/app_process32 //下一步会加载该程序，并且传入参数 if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) &#123; ERROR(\"cannot execve('%s'): %s\\n\", svc-&gt;args[0], strerror(errno)); &#125; &#125; else &#123; char *arg_ptrs[INIT_PARSER_MAXARGS+1]; int arg_idx = svc-&gt;nargs; char *tmp = strdup(dynamic_args); char *next = tmp; char *bword; /* Copy the static arguments */ memcpy(arg_ptrs, svc-&gt;args, (svc-&gt;nargs * sizeof(char *))); while((bword = strsep(&amp;next, \" \"))) &#123; arg_ptrs[arg_idx++] = bword; if (arg_idx == INIT_PARSER_MAXARGS) break; &#125; arg_ptrs[arg_idx] = NULL; execve(svc-&gt;args[0], (char**) arg_ptrs, (char**) ENV); &#125; _exit(127); &#125; //...&#125; 1.2 socket创建和发布下面主要分析一下create_socket和publish_socket两个函数，来说明zygote的socket如何创建的。 创建socket。system/core/init/util.cpp :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * create_socket - creates a Unix domain socket in ANDROID_SOCKET_DIR * (\"/dev/socket\") as dictated in init.rc. This socket is inherited by the * daemon. We communicate the file descriptor's value via the environment * variable ANDROID_SOCKET_ENV_PREFIX&lt;name&gt; (\"ANDROID_SOCKET_foo\"). */int create_socket(const char *name, int type, mode_t perm, uid_t uid, gid_t gid, const char *socketcon)&#123; struct sockaddr_un addr; int fd, ret; char *filecon; if (socketcon) setsockcreatecon(socketcon); //创建一个socket fd = socket(PF_UNIX, type, 0); if (fd &lt; 0) &#123; ERROR(\"Failed to open socket '%s': %s\\n\", name, strerror(errno)); return -1; &#125; if (socketcon) setsockcreatecon(NULL); //创建一个socket地址addr memset(&amp;addr, 0 , sizeof(addr)); addr.sun_family = AF_UNIX; //设置地址的文件位置，这里就是/dev/socket/zygote snprintf(addr.sun_path, sizeof(addr.sun_path), ANDROID_SOCKET_DIR\"/%s\", name); ret = unlink(addr.sun_path); if (ret != 0 &amp;&amp; errno != ENOENT) &#123; ERROR(\"Failed to unlink old socket '%s': %s\\n\", name, strerror(errno)); goto out_close; &#125; filecon = NULL; if (sehandle) &#123; ret = selabel_lookup(sehandle, &amp;filecon, addr.sun_path, S_IFSOCK); if (ret == 0) setfscreatecon(filecon); &#125; //将想要存储socket的文件地址addr和socket文件描述符fd绑定起来 ret = bind(fd, (struct sockaddr *) &amp;addr, sizeof (addr)); if (ret) &#123; ERROR(\"Failed to bind socket '%s': %s\\n\", name, strerror(errno)); goto out_unlink; &#125; setfscreatecon(NULL); freecon(filecon); //设置用户组root system chown(addr.sun_path, uid, gid); //设置权限660 chmod(addr.sun_path, perm); INFO(\"Created socket '%s' with mode '%o', user '%d', group '%d'\\n\", addr.sun_path, perm, uid, gid); return fd;out_unlink: unlink(addr.sun_path);out_close: close(fd); return -1;&#125; 发布socket。1234567891011121314151617static void publish_socket(const char *name, int fd)&#123; //前缀为ANDROID_SOCKET_ char key[64] = ANDROID_SOCKET_ENV_PREFIX; char val[64]; //拼接出key strlcpy(key + sizeof(ANDROID_SOCKET_ENV_PREFIX) - 1, name, sizeof(key) - sizeof(ANDROID_SOCKET_ENV_PREFIX)); //将fd写入val snprintf(val, sizeof(val), \"%d\", fd); //将key，value写入环境变量中，以便其他进程访问 add_environment(key, val); /* make sure we don't close-on-exec */ fcntl(fd, F_SETFD, 0);&#125; 2. Zygote进程启动过程Zygote 进程的启动从app_process的main函数开始。 2.1 app_process.main判断需要启动的进程的种类。 frameworks/base/cmds/app_process/app_main.cpp :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126int main(int argc, char* const argv[])&#123; //针对旧内核做的处理... //创建AppRuntime对象 AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] argc--; argv++; // Everything up to '--' or first non '-' arg goes to the vm. // // The first argument after the VM args is the \"parent dir\", which // is currently unused. // // After the parent dir, we expect one or more the following internal // arguments : // 不同的进程类型 // --zygote : Start in zygote mode // --start-system-server : Start the system server. // --application : Start in application (stand alone, non zygote) mode. // --nice-name : The nice name for this process. // // For non zygote starts, these arguments will be followed by // the main class name. All remaining arguments are passed to // the main method of this class. // // For zygote starts, all remaining arguments are passed to the zygote. // main function. // // Note that we must copy argument string values since we will rewrite the // entire argument block when we apply the nice name to argv0. int i; for (i = 0; i &lt; argc; i++) &#123; if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; runtime.addOption(strdup(argv[i])); &#125; // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; //判断需要创建何种类型的进程 ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; //这里是Zygote进程 zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; //同时需要开启SystemServer startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; // We're not in zygote mode, the only argument we need to pass // to RuntimeInit is the application argument. // // The Remainder of args get passed to startup class main(). Make // copies of them before we overwrite them with the process name. args.add(application ? String8(\"application\") : String8(\"tool\")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; // We're in zygote mode. maybeCreateDalvikCache(); if (startSystemServer) &#123; //作为参数传递给Zygote进程 args.add(String8(\"start-system-server\")); &#125; //... String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; if (!niceName.isEmpty()) &#123; //这里进程名字就是zygote runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); &#125; if (zygote) &#123; //启动Zygote，接下来会主要分析start函数 runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 2.2 AndroidRuntime.start创建虚拟机，运行java函数。 frameworks/base/core/jni/AndroidRuntime.cpp :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* * Start the Android runtime. This involves starting the virtual machine * and calling the \"static void main(String[] args)\" method in the class * named by \"className\". * * Passes the main function two arguments, the class name and the specified * options string. */void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; //创建一个虚拟机实例 /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; onVmCreated(env); /* * Register android functions. */ //注册JNI方法 if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; /* * 将参数转化为java对象 * We want to call main() with a String array with arguments in it. * At present we have two arguments, the class name and an option string. * Create an array to hold them. */ jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass(\"java/lang/String\"); assert(stringClass != NULL); strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //找到main函数 jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //调用com.android.internal.os.ZygoteInit类的main函数 //参数放在strArray里 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif &#125; &#125; free(slashClassName); ALOGD(\"Shutting down VM\\n\"); if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(\"Warning: unable to detach main thread\\n\"); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(\"Warning: VM did not shut down cleanly\\n\");&#125; 2.3 ZygoteInit.mainframeworks/base/core/java/com/android/internal/os/Zygoteinit.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void main(String argv[]) &#123; try &#123; //解析参数 RuntimeInit.enableDdms(); // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = \"zygote\"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; if (abiList == null) &#123; throw new RuntimeException(\"No ABI list supplied.\"); &#125; //注册Socket，创建一个socket服务端 registerZygoteSocket(socketName); //... // Do an initial gc to clean up after startup gcAndFinalize(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); if (startSystemServer) &#123; //启动系统服务 startSystemServer(abiList, socketName); &#125; Log.i(TAG, \"Accepting command socket connections\"); //循环等待其他服务向zygote socket发送请求 runSelectLoop(abiList); closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125; &#125; 2.4 ZygoteInit.registerZygoteSocket创建了zygote socket的server端。 123456789101112131415161718192021222324252627282930/** * Registers a server socket for zygote command connections * * @throws RuntimeException when open fails */ private static void registerZygoteSocket(String socketName) &#123; if (sServerSocket == null) &#123; int fileDesc; //拼接出socket名称ANDROID_SOCKET_zygote final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; //环境变量中在上面存储了该key下对应的value String env = System.getenv(fullSocketName); //获取socket的文件描述符 fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(fullSocketName + \" unset or invalid\", ex); &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); //创建socket server，并且保留在一个静态变量sServerSocket中 sServerSocket = new LocalServerSocket(fd); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"Error binding to local socket '\" + fileDesc + \"'\", ex); &#125; &#125; &#125; 2.5 ZygoteInit.startSystemServer从zygote中fork一个新的进程来单独处理system server。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 /** * Prepare the arguments and fork for the system server process. */ private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123;//... /* Hardcoded command line to start the system server */ String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", //这就是System server的类名 &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); //从zygote中fork出一个进程 /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //在子进程中启动System server,在第3节中详细分析 handleSystemServerProcess(parsedArgs); &#125;//父进程返回 return true; &#125; 2.6 ZygoteInit.runSelectLoopZygote启动无限循环，等待请求。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /** * Runs the zygote process's select loop. Accepts new connections as * they happen, and reads commands from connections one spawn-request's * worth at a time. * * @throws MethodAndArgsCaller in a child process when a main() should * be executed. */ private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();//一个zygote socket文件描述符 fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; //将现有的fd先存入pollFds StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; //一次循环最多让一个peer接入，但是可能会处理多个peer的请求 for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; //是否有请求写入，没有就继续 continue; &#125; if (i == 0) &#123; //有人在zygote上写入请求，获得该peer //这一步只是peer和zygote建立连接，peer还未发送具体请求 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); //将其加入文件描述符fds中，该peer会向其对应的fd写入请求 //这一步不会处理，因为该peer没有在pollFds中 fds.add(newPeer.getFileDesciptor()); &#125; else &#123; //有peer向其fd写入请求,这里开始处理这个请求，处理完毕后删除 boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125; &#125; 3. System进程的启动接着2.5，Zygote fork出一个新的进程来启动System server。接下来看在这个新进程中如何启动的System server。 3.1 ZygoteInit.handleSystemServerProcessframeworks/base/core/java/com/android/internal/os/ZygoteInit.java :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /** * Finish remaining work for the newly forked system server process. */ private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; //因为fork了Zygote的进程，所以会复制它的socket //SystemServer用不着这个socket，先关了再说 closeServerSocket(); // set umask to 0077 so new files and directories will default to owner-only permissions. Os.umask(S_IRWXG | S_IRWXO);//设置进程名 if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125;//获取system server类的路径 final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); if (systemServerClasspath != null) &#123; performSystemServerDexOpt(systemServerClasspath); &#125; if (parsedArgs.invokeWith != null) &#123; String[] args = parsedArgs.remainingArgs; // If we have a non-null system server class path, we'll have to duplicate the // existing arguments and append the classpath to it. ART will handle the classpath // correctly when we exec a new process. if (systemServerClasspath != null) &#123; String[] amendedArgs = new String[args.length + 2]; amendedArgs[0] = \"-cp\"; amendedArgs[1] = systemServerClasspath; System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length); &#125; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args); &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader()); Thread.currentThread().setContextClassLoader(cl); &#125; /* * 进一步启动System server * Pass the remaining arguments to SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; /* should never reach here */ &#125; 3.2 RuntimeInit.zygoteInitframeworks/base/core/java/com/android/internal/os/RuntimeInit.java :123456789101112131415161718192021222324252627/** * The main function called when started through the zygote process. This * could be unified with main(), if the native code in nativeFinishInit() * were rationalized with Zygote startup.&lt;p&gt; * * Current recognized args: * &lt;ul&gt; * &lt;li&gt; &lt;code&gt; [--] &amp;lt;start class name&amp;gt; &amp;lt;args&amp;gt; * &lt;/ul&gt; * * @param targetSdkVersion target SDK version * @param argv arg strings */public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); //做一些基本的初始化，比如时间、log等 commonInit(); //进入native部分，将来章节再讲 nativeZygoteInit(); //进一步启动system applicationInit(targetSdkVersion, argv, classLoader);&#125; 3.3 RuntimeInit.applicationInit这一步开始调用SystemServer的main函数。 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java :123456789101112131415161718192021222324252627282930 private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; // If the application calls System.exit(), terminate the process // immediately without running any shutdown hooks. It is not possible to // shutdown an Android application gracefully. Among other things, the // Android runtime shutdown hooks close the Binder driver, which can cause // leftover running threads to crash before the process actually exits. nativeSetExitWithoutCleanup(true); // We want to be fairly aggressive about heap utilization, to avoid // holding on to a lot of memory that isn't needed. VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); // let the process exit return; &#125; // The end of of the RuntimeInit event (see #zygoteInit). Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);//启动需要启动的类的main函数，这里就是com.android.server.SystemServer // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs, classLoader); &#125; 3.4 SystemServer.main这里直接new了一个SystemServer，然后调用它的run函数。 3.5 SystemService.run这一步开始依次启动各种service。 frameworks/base/services/java/com/android/server/SystemServer.java :1234567891011121314151617181920212223242526272829303132333435363738394041 private void run() &#123; //... //设置系统时间、语言等 if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) &#123; final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(\"persist.sys.locale\", languageTag); SystemProperties.set(\"persist.sys.language\", \"\"); SystemProperties.set(\"persist.sys.country\", \"\"); SystemProperties.set(\"persist.sys.localevar\", \"\"); &#125;//... //一些虚拟机内存，堆栈的设置 //该线程就是主线程 // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper();//...//创建SystemServiceManager // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try &#123; //开始依次启动各种服务，下一节详细解释 startBootstrapServices(); startCoreServices(); startOtherServices(); &#125; catch (Throwable ex) &#123; //... &#125; //永远的循环.. // Loop forever. Looper.loop(); &#125; 3.6 各种service启动startBootstrapServices这里面启动的服务有：Installer，ActivityManagerService，PowerManagerService，LightsService，DisplayManagerService，PackageManagerService，SensorService（非具体）。 这些service有的会创建自己独立的ServiceThread，是HandlerThread的子类，它们有着自己的looper循环。startService函数将所有的service的启动过程统一管理，抽象为注册、启动两步骤。 frameworks/base/services/java/com/android/server/SystemServer.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Starts the small tangle of critical services that are needed to get * the system off the ground. These services have complex mutual dependencies * which is why we initialize them all in one place here. Unless your service * is also entwined in these dependencies, it should be initialized in one of * the other functions. */ private void startBootstrapServices() &#123; // Wait for installd to finish starting up so that it has a chance to // create critical directories such as /data/user with the appropriate // permissions. We need this to complete before we initialize other services. Installer installer = mSystemServiceManager.startService(Installer.class); // Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); // Power manager needs to be started early because other services need it. // Native daemons may be watching for it to be registered so it must be ready // to handle incoming binder calls immediately (including being able to verify // the permissions for those calls). mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // Now that the power manager has been started, let the activity manager // initialize power management features. mActivityManagerService.initPowerManagement(); // Manages LEDs and display backlight so we need it to bring up the display. mSystemServiceManager.startService(LightsService.class); // Display manager is needed to provide display metrics before package manager // starts up. mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); // We need the default display before we can initialize the package manager. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); // Only run \"core\" apps if we're encrypting the device. String cryptState = SystemProperties.get(\"vold.decrypt\"); if (ENCRYPTING_STATE.equals(cryptState)) &#123; Slog.w(TAG, \"Detected encryption in progress - only parsing core apps\"); mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; Slog.w(TAG, \"Device encrypted - only parsing core apps\"); mOnlyCore = true; &#125; // Start the package manager. Slog.i(TAG, \"Package Manager\"); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); Slog.i(TAG, \"User Service\"); ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); // Initialize attribute cache used to cache resources from packages. AttributeCache.init(mSystemContext); // Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); // The sensor service needs access to package manager service, app ops // service, and permissions service, therefore we start it after them. startSensorService(); &#125; startCoreServices这一步启动的serivce有：BatteryService，UsageStatsService，WebViewUpdateService。1234567891011121314151617/** * Starts some essential services that are not tangled up in the bootstrap process. */private void startCoreServices() &#123; // Tracks the battery level. Requires LightService. mSystemServiceManager.startService(BatteryService.class); // Tracks application usage stats. mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); // Update after UsageStatsService is available, needed before performBootDexOpt. mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); // Tracks whether the updatable WebView is in a ready state and watches for update installs. mSystemServiceManager.startService(WebViewUpdateService.class);&#125; startOtherService这一步启动service又多又杂，主要有如下这些，其它还有不再一一列举。 1234567891011121314151617181920212223AccountManagerService accountManager = null; ContentService contentService = null; VibratorService vibrator = null; IAlarmManager alarm = null; IMountService mountService = null; NetworkManagementService networkManagement = null; NetworkStatsService networkStats = null; NetworkPolicyManagerService networkPolicy = null; ConnectivityService connectivity = null; NetworkScoreService networkScore = null; NsdService serviceDiscovery= null; WindowManagerService wm = null; UsbService usb = null; SerialService serial = null; NetworkTimeUpdateService networkTimeUpdater = null; CommonTimeManagementService commonTimeMgmtService = null; InputManagerService inputManager = null; TelephonyRegistry telephonyRegistry = null; ConsumerIrService consumerIr = null; AudioService audioService = null; MmsServiceBroker mmsService = null; EntropyMixer entropyMixer = null; CameraService cameraService = null; 4. 总结写到这里，有点凌乱，太多的进程和线程在这一过程中被创建。我用下图来梳理这部分进程之间的关系，希望让你一目了然吧。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(13):Input消息的分发过程","date":"2017-02-14T06:29:02.000Z","path":"2017/02/14/Android系统源码阅读-13-Input消息的分发过程/","text":"Android系统源码阅读（13）：Input消息的分发过程 请对照AOSP版本：6.0.1_r50。学校电脑好渣，看源码时卡半天 先回顾一下前两篇文章。在设备没有事件输入的时候，InputReader和InputDispatcher都处于睡眠状态。当输入事件发生，InputReader首先被激活，然后发送读取消息，激活Dispatcher。Dispatcher被激活以后，将消息发送给当前激活窗口的主线程，然后睡眠等待主线程处理完这个事件。主线程被激活后，会处理相应的消息，处理完毕后反馈给Dispatcher，从而Dispatcher可以继续发送消息。 1. InputReader获取事件回顾一下第11章4.2中，InputReader线程在获取事件以后，会调用processEventsLocked(mEventBuffer, count);处理事件。 1.1这里先根据event的种类进行分门别类的处理。 frameworks/native/services/inputflinger/InputReader.cpp :123456789101112131415161718192021222324252627282930313233343536373839void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123; for (const RawEvent* rawEvent = rawEvents; count;) &#123; int32_t type = rawEvent-&gt;type; size_t batchSize = 1; if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123; //如果这里获得是合成事件 //这里一次要将该输入设备中的一组事件都获取出来 int32_t deviceId = rawEvent-&gt;deviceId; while (batchSize &lt; count) &#123; if (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT || rawEvent[batchSize].deviceId != deviceId) &#123; break; &#125; batchSize += 1; &#125; //处理这些事件 processEventsForDeviceLocked(deviceId, rawEvent, batchSize); &#125; else &#123; //这些是一些设备状况的事件，没必要将这些消息发送出去，留给自己处理就可以了 switch (rawEvent-&gt;type) &#123; case EventHubInterface::DEVICE_ADDED: addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId); break; case EventHubInterface::DEVICE_REMOVED: removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId); break; case EventHubInterface::FINISHED_DEVICE_SCAN: handleConfigurationChangedLocked(rawEvent-&gt;when); break; default: ALOG_ASSERT(false); // can't happen break; &#125; &#125; count -= batchSize; rawEvent += batchSize; &#125;&#125; 1.2准备将事件交给设备进行处理。 frameworks/native/services/inputflinger/InputReader.cpp :1234567891011121314151617void InputReader::processEventsForDeviceLocked(int32_t deviceId, const RawEvent* rawEvents, size_t count) &#123; //判断设备是否是已知的 ssize_t deviceIndex = mDevices.indexOfKey(deviceId); if (deviceIndex &lt; 0) &#123; ALOGW(\"Discarding event for unknown deviceId %d.\", deviceId); return; &#125; //获得设备 InputDevice* device = mDevices.valueAt(deviceIndex); if (device-&gt;isIgnored()) &#123; //ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId); return; &#125; //交给设备进行处理 device-&gt;process(rawEvents, count);&#125; 1.3用device中的mapper去映射传入的事件，然后再处理。 frameworks/native/services/inputflinger/InputReader.cpp :12345678910111213141516171819202122232425262728293031void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123; // Process all of the events in order for each mapper. // We cannot simply ask each mapper to process them in bulk because mappers may // have side-effects that must be interleaved. For example, joystick movement events and // gamepad button presses are handled by different mappers but they should be dispatched // in the order received. //一个设备可能有多种类型的event，所有有多个mapper，但是需要保持event的顺序性 //所以这里采用先循环event，再循环mapper的方式 size_t numMappers = mMappers.size(); for (const RawEvent* rawEvent = rawEvents; count--; rawEvent++) &#123; if (mDropUntilNextSync) &#123; if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123; mDropUntilNextSync = false; //.. &#125; else &#123; //.. &#125; &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123; //.. mDropUntilNextSync = true; reset(rawEvent-&gt;when); &#125; else &#123; for (size_t i = 0; i &lt; numMappers; i++) &#123; InputMapper* mapper = mMappers[i]; //用每一种mapper尝试处理event mapper-&gt;process(rawEvent); &#125; &#125; &#125;&#125; 1.4这里InputMapper种类很多，每个事件处理方法各不相同，所以在这里不再详述。其中有如下的InputMapper： SwitchInputMapper, VibratorInputMapper, KeyboardInputMapper, CursorInputMapper, TouchInputMapper, SingleTouchInputMapper, MultiTouchInputMapper, JoystickInputMapper 这些方法处理到最后，会调用getListener()-&gt;notifyXXX(&amp;args)，让Dispatcher进行分发，XXX根据不同的Mapper有相应的名字。在创建InputReader时，将InputDispatcher作为参数传入，同时建立了QueuedInputListener来存放这个InputDispatcher，估计是准备将来处理多个InputDispatcher。所以这里getListener获取的就是当初建立的InputDispatcher对象。 1.5这里虽然已经开始调用InputDispatcher的函数，但是还是在InputReader线程中。这里开始向InputDispatcher的队列中插入事件，并且把InputDispatcher唤醒了。因为notifyXXX函数同样是针对不同的输入有着不同的处理，所以不再详述，截取一段MotionEvent的代码片段。 frameworks/native/services/inputflinger/InputDispatcher.cpp :1234567891011121314151617 //针对每种event，都会想将其封装成一个EventEntry // Just enqueue a new motion event. MotionEntry* newEntry = new MotionEntry(args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, policyFlags, args-&gt;action, args-&gt;actionButton, args-&gt;flags, args-&gt;metaState, args-&gt;buttonState, args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime, args-&gt;displayId, args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, 0, 0);//然后加入队列needWake = enqueueInboundEventLocked(newEntry);//...//唤醒Looper线程if (needWake) &#123; mLooper-&gt;wake(); &#125; 将一个事件放入队列之后，会根据needWake参数决定是否要唤醒线程。如果要唤醒，则调用Looper的wake函数就可以了，和原来道理一样。在有些时候，有事件添加进去，不一定要唤醒线程，比如线程正在等待应用反馈事件处理完毕的消息。 1.6实实在在的将这个EventEntry放入队列mInboundQueue中了。 frameworks/native/services/inputflinger/InputDispatcher.cpp :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123; //如果队列空了，需要唤醒 bool needWake = mInboundQueue.isEmpty(); //将事件加入队列 mInboundQueue.enqueueAtTail(entry); traceInboundQueueLengthLocked(); switch (entry-&gt;type) &#123; //这里会优化App切换的事件，如果上一个App还有事件没处理完，也没反馈事件处理完毕消息 //则清空之前的事件，切换下一个应用 case EventEntry::TYPE_KEY: &#123; // Optimize app switch latency. // If the application takes too long to catch up then we drop all events preceding // the app switch key. KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(entry); if (isAppSwitchKeyEventLocked(keyEntry)) &#123; if (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123; mAppSwitchSawKeyDown = true; &#125; else if (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123; if (mAppSwitchSawKeyDown) &#123;#if DEBUG_APP_SWITCH ALOGD(\"App switch is pending!\");#endif mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT; mAppSwitchSawKeyDown = false; needWake = true; &#125; &#125; &#125; break; &#125; //当一个非当前激活app的点击事件发生，会清空之前的事件 //从这个新的点击事件开始 case EventEntry::TYPE_MOTION: &#123; // Optimize case where the current application is unresponsive and the user // decides to touch a window in a different application. // If the application takes too long to catch up then we drop all events preceding // the touch into the other window. MotionEntry* motionEntry = static_cast&lt;MotionEntry*&gt;(entry); if (motionEntry-&gt;action == AMOTION_EVENT_ACTION_DOWN &amp;&amp; (motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER) &amp;&amp; mInputTargetWaitCause == INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY &amp;&amp; mInputTargetWaitApplicationHandle != NULL) &#123; int32_t displayId = motionEntry-&gt;displayId; int32_t x = int32_t(motionEntry-&gt;pointerCoords[0]. getAxisValue(AMOTION_EVENT_AXIS_X)); int32_t y = int32_t(motionEntry-&gt;pointerCoords[0]. getAxisValue(AMOTION_EVENT_AXIS_Y)); sp&lt;InputWindowHandle&gt; touchedWindowHandle = findTouchedWindowAtLocked(displayId, x, y); if (touchedWindowHandle != NULL &amp;&amp; touchedWindowHandle-&gt;inputApplicationHandle != mInputTargetWaitApplicationHandle) &#123; // User touched a different application than the one we are waiting on. // Flag the event, and start pruning the input queue. mNextUnblockedEvent = motionEntry; needWake = true; &#125; &#125; break; &#125; &#125; return needWake;&#125; 这里做了两种优化，主要是在当前App窗口处理事件过慢，同时你又触发其他App的事件时，Dispatcher就会丢弃先前的事件，从这个开始唤醒Dispatcher。这样做很合情合理，用户在使用时，会遇到App由于开发者水平有限导致处理事件过慢情况，这时用户等的不耐烦，则应该让用户轻松的切换到其它App，而不是阻塞在那。所以，事件无法响应只会发生在App内部，而不会影响应用的切换，从而提升用户体验。App的质量问题不会影响系统的运转，Android在这点上做的很人性。 2. InputDispatcher分发事件在第11章中3.2中，Dispatcher调用函数dispatchOnceInnerLocked(&amp;nextWakeupTime);来分配队列中的事件。 2.1从队列中获取event，然后准备处理。 frameworks/native/services/inputflinger/InputDispatcher.cpp :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; nsecs_t currentTime = now(); // Reset the key repeat timer whenever normal dispatch is suspended while the // device is in a non-interactive state. This is to ensure that we abort a key // repeat if the device is just coming out of sleep. if (!mDispatchEnabled) &#123; resetKeyRepeatLocked(); &#125; // If dispatching is frozen, do not process timeouts or try to deliver any new events. if (mDispatchFrozen) &#123; return; &#125; //对App切换的情况的优化 // Optimize latency of app switches. // Essentially we start a short timeout when an app switch key (HOME / ENDCALL) has // been pressed. When it expires, we preempt dispatch and drop all other pending events. bool isAppSwitchDue = mAppSwitchDueTime &lt;= currentTime; if (mAppSwitchDueTime &lt; *nextWakeupTime) &#123; //如果有切换App的event，且时间小于设定的时间 //则将等待事件设为小者 *nextWakeupTime = mAppSwitchDueTime; &#125; // Ready to start a new event. // If we don't already have a pending event, go grab one. if (! mPendingEvent) &#123; if (mInboundQueue.isEmpty()) &#123; //队列是空的情况 if (isAppSwitchDue) &#123; // The inbound queue is empty so the app switch key we were waiting // for will never arrive. Stop waiting for it. resetPendingAppSwitchLocked(false); isAppSwitchDue = false; &#125; // Synthesize a key repeat if appropriate. //如果有连续重复事件发生，则制造重复事件 if (mKeyRepeatState.lastKeyEntry) &#123; if (currentTime &gt;= mKeyRepeatState.nextRepeatTime) &#123; mPendingEvent = synthesizeKeyRepeatLocked(currentTime); &#125; else &#123; if (mKeyRepeatState.nextRepeatTime &lt; *nextWakeupTime) &#123; *nextWakeupTime = mKeyRepeatState.nextRepeatTime; &#125; &#125; &#125; // Nothing to do if there is no pending event. //如果真无事可做，下次睡眠可能比较久 if (!mPendingEvent) &#123; return; &#125; &#125; else &#123; // Inbound queue has at least one entry. //从队列中获取一个Event mPendingEvent = mInboundQueue.dequeueAtHead(); traceInboundQueueLengthLocked(); &#125; // Poke user activity for this event. if (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123; pokeUserActivityLocked(mPendingEvent); &#125; //重置ANRT // Get ready to dispatch the event. resetANRTimeoutsLocked(); &#125; // Now we have an event to dispatch. // All events are eventually dequeued and processed this way, even if we intend to drop them. bool done = false; DropReason dropReason = DROP_REASON_NOT_DROPPED; if (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123; dropReason = DROP_REASON_POLICY; &#125; else if (!mDispatchEnabled) &#123; dropReason = DROP_REASON_DISABLED; &#125; if (mNextUnblockedEvent == mPendingEvent) &#123; mNextUnblockedEvent = NULL; &#125; //分类处理Event switch (mPendingEvent-&gt;type) &#123; case EventEntry::TYPE_CONFIGURATION_CHANGED: &#123; ConfigurationChangedEntry* typedEntry = static_cast&lt;ConfigurationChangedEntry*&gt;(mPendingEvent); done = dispatchConfigurationChangedLocked(currentTime, typedEntry); dropReason = DROP_REASON_NOT_DROPPED; // configuration changes are never dropped break; &#125; case EventEntry::TYPE_DEVICE_RESET: &#123; DeviceResetEntry* typedEntry = static_cast&lt;DeviceResetEntry*&gt;(mPendingEvent); done = dispatchDeviceResetLocked(currentTime, typedEntry); dropReason = DROP_REASON_NOT_DROPPED; // device resets are never dropped break; &#125; case EventEntry::TYPE_KEY: &#123; KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent); if (isAppSwitchDue) &#123; if (isAppSwitchKeyEventLocked(typedEntry)) &#123; //这个Event就是SwitchEvent，我已经处理 //重置App切换的状态为false resetPendingAppSwitchLocked(true); isAppSwitchDue = false; &#125; else if (dropReason == DROP_REASON_NOT_DROPPED) &#123; //如果是其他事件，则丢弃，因为正在switch dropReason = DROP_REASON_APP_SWITCH; &#125; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123; dropReason = DROP_REASON_STALE; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123; dropReason = DROP_REASON_BLOCKED; &#125; //分发KeyEvent done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; case EventEntry::TYPE_MOTION: &#123; MotionEntry* typedEntry = static_cast&lt;MotionEntry*&gt;(mPendingEvent); if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123; dropReason = DROP_REASON_APP_SWITCH; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123; dropReason = DROP_REASON_STALE; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123; dropReason = DROP_REASON_BLOCKED; &#125; //分发Motion Event done = dispatchMotionLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; default: ALOG_ASSERT(false); break; &#125; if (done) &#123; if (dropReason != DROP_REASON_NOT_DROPPED) &#123; dropInboundEventLocked(mPendingEvent, dropReason); &#125; mLastDropReason = dropReason; //将mPendingEvent置为null releasePendingEventLocked(); //我已经处理的event，所以需要将睡眠设置时间小一点 *nextWakeupTime = LONG_LONG_MIN; // force next poll to wake up immediately &#125;&#125; 2.2这一步根据Event的种类，略有不同。有dispatchMotionLocked和dispatchKeyLocked等。主要过程类似，首先判断是否需要丢弃该event，然后获得目标Window，再向目标window发送event。代码片如下： frameworks/native/services/inputflinger/InputDispatcher.cpp :1234567//..// Identify targets.Vector&lt;InputTarget&gt; inputTargets;//..injectionResult = findTouchedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);//..dispatchEventLocked(currentTime, entry, inputTargets); 这里调用findTouchedWindowTargetsLocked()来获取目标Window。在前面12章3.6中，将mFocusedWindowHandle参数设置为了当前激活的Window，所以目前返回的inputTargets就是将mFocusedWindowHandle封装后的结果。 2.3向每一个目标发送event。 frameworks/native/services/inputflinger/InputDispatcher.cpp :1234567891011121314151617void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* eventEntry, const Vector&lt;InputTarget&gt;&amp; inputTargets) &#123; pokeUserActivityLocked(eventEntry); //向每一个目标发送event for (size_t i = 0; i &lt; inputTargets.size(); i++) &#123; const InputTarget&amp; inputTarget = inputTargets.itemAt(i); //获取目标的connection ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel); if (connectionIndex &gt;= 0) &#123; sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex); prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget); &#125; else &#123; //.. &#125; &#125;&#125; 2.4frameworks/native/services/inputflinger/InputDispatcher.cpp :123456789101112131415161718192021222324252627282930void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; // Skip this event if the connection status is not normal. // We don't want to enqueue additional outbound events if the connection is broken. if (connection-&gt;status != Connection::STATUS_NORMAL) &#123; return; &#125; // Split a motion event if needed. if (inputTarget-&gt;flags &amp; InputTarget::FLAG_SPLIT) &#123; //Motion event一般为连续的基本event组合而成 //所以可以分割 MotionEntry* originalMotionEntry = static_cast&lt;MotionEntry*&gt;(eventEntry); if (inputTarget-&gt;pointerIds.count() != originalMotionEntry-&gt;pointerCount) &#123; MotionEntry* splitMotionEntry = splitMotionEvent( originalMotionEntry, inputTarget-&gt;pointerIds); if (!splitMotionEntry) &#123; return; // split event was dropped &#125; enqueueDispatchEntriesLocked(currentTime, connection, splitMotionEntry, inputTarget); splitMotionEntry-&gt;release(); return; &#125; &#125; // Not splitting. Enqueue dispatch entries for the event as is. enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);&#125; 2.5这一步先判断目标Connection是否空，然后向其队列加入event。如果原来队列为空，说明可以进一步分发event；如果不为空，说明旧event还没有处理完毕，则不进一步分发。 frameworks/native/services/inputflinger/InputDispatcher.cpp :123456789bool wasEmpty = connection-&gt;outboundQueue.isEmpty();// Enqueue dispatch entries for the requested modes.//将event放入outboundQueue中，省略..// If the outbound queue was previously empty, start the dispatch cycle going.if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; startDispatchCycleLocked(currentTime, connection);&#125; 2.6循环的取出队列中的event，然后交给connection发送。 frameworks/native/services/inputflinger/InputDispatcher.cpp :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection) &#123; //将outboundQueue中的entry一一进行处理 while (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; //获取首部的entry DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head; dispatchEntry-&gt;deliveryTime = currentTime; // Publish the event. status_t status; EventEntry* eventEntry = dispatchEntry-&gt;eventEntry; switch (eventEntry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(eventEntry); //.. // Publish the key event. status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq, keyEntry-&gt;deviceId, keyEntry-&gt;source, dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags, keyEntry-&gt;keyCode, keyEntry-&gt;scanCode, keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime, keyEntry-&gt;eventTime); break; &#125; case EventEntry::TYPE_MOTION: &#123; MotionEntry* motionEntry = static_cast&lt;MotionEntry*&gt;(eventEntry); // Set the X and Y offset depending on the input source. //.. // Publish the motion event. status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq, motionEntry-&gt;deviceId, motionEntry-&gt;source, dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton, dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags, motionEntry-&gt;metaState, motionEntry-&gt;buttonState, xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision, motionEntry-&gt;downTime, motionEntry-&gt;eventTime, motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties, usingCoords); break; &#125; default: return; &#125; // Check the result. // Re-enqueue the event on the wait queue. //从outboundQueue中移除 connection-&gt;outboundQueue.dequeue(dispatchEntry); traceOutboundQueueLengthLocked(connection); //加入waitQueue connection-&gt;waitQueue.enqueueAtTail(dispatchEntry); traceWaitQueueLengthLocked(connection); &#125;&#125; 2.7这一步同样有多种情况，有publishMotionEvent和publishKeyEvent。基本思路相近。先封装成message，最后都调用了mChannel-&gt;sendMessage(&amp;msg)。frameworks/native/libs/input/InputTransport.cpp :1234567891011121314151617181920212223InputMessage msg;msg.header.type = InputMessage::TYPE_MOTION;msg.body.motion.seq = seq;msg.body.motion.deviceId = deviceId;msg.body.motion.source = source;msg.body.motion.action = action;msg.body.motion.actionButton = actionButton;msg.body.motion.flags = flags;msg.body.motion.edgeFlags = edgeFlags;msg.body.motion.metaState = metaState;msg.body.motion.buttonState = buttonState;msg.body.motion.xOffset = xOffset;msg.body.motion.yOffset = yOffset;msg.body.motion.xPrecision = xPrecision;msg.body.motion.yPrecision = yPrecision;msg.body.motion.downTime = downTime;msg.body.motion.eventTime = eventTime;msg.body.motion.pointerCount = pointerCount;for (uint32_t i = 0; i &lt; pointerCount; i++) &#123; msg.body.motion.pointers[i].properties.copyFrom(pointerProperties[i]); msg.body.motion.pointers[i].coords.copyFrom(pointerCoords[i]);&#125;return mChannel-&gt;sendMessage(&amp;msg); 2.8这一步就要像保存的文件描述符mFd中写入数据了。 frameworks/native/libs/input/InputTransport.cpp :12345size_t msgLength = msg-&gt;size();ssize_t nWrite;do &#123; nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);&#125; while (nWrite == -1 &amp;&amp; errno == EINTR); 到这里，Dispatcher终于把event通过当初建立的Channel pair发送给了应用window。这里和旧版本很不同，当初需要先将event放入共享内存，然后发送一个信号进行通知。 3. 当前激活Window获得消息这一节比较复杂，需要回忆大量的前面几章的细节和一定的逻辑推理（连蒙带猜）能力。 先来回忆一下第12章4.5节，在InputChannel注册到Client时，最后一步做了什么。 frameworks/base/core/jni/android_view_InputEventReceiver.cpp ：1mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); 这里给主线程的Looper添加的一个需要监听fd，这个fd是Client端的InputChannel的文件描述符。addFd函数的第4个参数是一个回调函数，这里this指NativeInputEventReceiver对象，它是LooperCallback的子类。addFd函数新建了一个Request对象，如下： system/core/libutils/Looper.cpp :1234567891011Request request;request.fd = fd;request.ident = ident;request.events = events;request.seq = mNextRequestSeq++;//回调函数指明是上一步传入的NativeInputEventReceiver对象request.callback = callback;request.data = data;//..//将request以fd为关键字加入mRequestsmRequests.add(fd, request); 再次回忆第10章1.6，也就是主线程被阻塞的地方。代码如下：system/core/libutils/Looper.cpp :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int Looper::pollInner(int timeoutMillis) &#123; // Adjust the timeout based on when the next message is due. //.. //清空mResponses数组 // Poll. int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; // We are about to idle. mPolling = true; //等待epoll监测到IO事件 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); //.. // Handle all events. for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; //这里处理的唤醒事件 awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); &#125; &#125; else &#123; //这里处理的是input事件 ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; //将event加入mResponses pushResponse(events, mRequests.valueAt(requestIndex)); &#125; else &#123; //.. &#125; &#125; &#125;Done: ; //遍历每一个存在mResponses的event // Invoke all response callbacks. for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; // Invoke the callback. Note that the file descriptor may be closed by // the callback (and potentially even reused) before the function returns so // we need to be a little careful when removing the file descriptor afterwards. //这一步开始调用回调函数，说明该文件描述符下有人输入的event int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); &#125; // Clear the callback reference in the response structure promptly because we // will not clear the response vector itself until the next poll. response.request.callback.clear(); result = POLL_CALLBACK; &#125; &#125; return result;&#125; 这一步处理wake事件已经在第10章第1节讲述过了，这里需要处理的另一种事件input event。对input event，先将其放入mResponses数组，然后依次调用他们的回调函数。这里就是NativeInputEventReceiver的handleEvent函数了。 3.1Event分为Input和Output，这里是事件输入，所以先看Input分支。 frameworks/base/core/jni/android_view_InputEventReceiver.cpp ：1234567891011121314int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; if (events &amp; ALOOPER_EVENT_INPUT) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); status_t status = consumeEvents(env, false /*consumeBatches*/, -1, NULL); mMessageQueue-&gt;raiseAndClearException(env, \"handleReceiveCallback\"); return status == OK || status == NO_MEMORY ? 1 : 0; &#125; if (events &amp; ALOOPER_EVENT_OUTPUT) &#123; //.. &#125; return 1;&#125; 3.2开始从目标Channel中读出event，然后包装成java层的对象，开始调用java函数进行处理。 frameworks/base/core/jni/android_view_InputEventReceiver.cpp ：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; ScopedLocalRef&lt;jobject&gt; receiverObj(env, NULL); bool skipCallbacks = false; //循环从Channel中读出event for (;;) &#123; uint32_t seq; InputEvent* inputEvent; //这一步开始从Channel中读取event，存入inputEvent中 status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); if (status) &#123; if (status == WOULD_BLOCK) &#123; if (!skipCallbacks &amp;&amp; !mBatchedInputEventPending &amp;&amp; mInputConsumer.hasPendingBatch()) &#123; // There is a pending batch. Come back later. //.. return OK; &#125; &#125; return status; &#125; if (!skipCallbacks) &#123; if (!receiverObj.get()) &#123; //这里的mReceiverWeakGlobal是java层的InputEventReceiver receiverObj.reset(jniGetReferent(env, mReceiverWeakGlobal)); //.. &#125; //根据不同的InputEvent种类，将其转化为java层的inputEventObj jobject inputEventObj; switch (inputEvent-&gt;getType()) &#123; case AINPUT_EVENT_TYPE_KEY: inputEventObj = android_view_KeyEvent_fromNative(env, static_cast&lt;KeyEvent*&gt;(inputEvent)); break; case AINPUT_EVENT_TYPE_MOTION: &#123; MotionEvent* motionEvent = static_cast&lt;MotionEvent*&gt;(inputEvent); if ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123; *outConsumedBatch = true; &#125; inputEventObj = android_view_MotionEvent_obtainAsCopy(env, motionEvent); break; &#125; default: assert(false); // InputConsumer should prevent this from ever happening inputEventObj = NULL; &#125; if (inputEventObj) &#123; //开始调用java层的dispatchInputEvent函数 env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); env-&gt;DeleteLocalRef(inputEventObj); &#125; else &#123; //.. &#125; &#125; if (skipCallbacks) &#123; //不需要调用回调函数，则可以直接反馈完成信号 mInputConsumer.sendFinishedSignal(seq, false); &#125; &#125;&#125; 我们先看如何从Channel中获取event的，3.3。然后讲解java层的分发过程，3.4。 3.3从Chuannel中读取一个（一组）event。 frameworks/native/libs/input/InputTransport.cpp :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) &#123; *outSeq = 0; *outEvent = NULL; // Fetch the next input message. // Loop until an event can be returned or no additional events are received. while (!*outEvent) &#123; if (mMsgDeferred) &#123; // mMsg contains a valid input message from the previous call to consume // that has not yet been processed. mMsgDeferred = false; &#125; else &#123; // Receive a fresh message. //从Channel中读取一个Message status_t result = mChannel-&gt;receiveMessage(&amp;mMsg); if (result) &#123; // Consume the next batched event unless batches are being held for later. //.. &#125; &#125; //根据message种类构造event switch (mMsg.header.type) &#123; case InputMessage::TYPE_KEY: &#123; KeyEvent* keyEvent = factory-&gt;createKeyEvent(); if (!keyEvent) return NO_MEMORY; initializeKeyEvent(keyEvent, &amp;mMsg); *outSeq = mMsg.body.key.seq; *outEvent = keyEvent; break; &#125; case AINPUT_EVENT_TYPE_MOTION: &#123; //对Motion event，需要处理成批的event事件 //.. MotionEvent* motionEvent = factory-&gt;createMotionEvent(); if (! motionEvent) return NO_MEMORY; updateTouchState(&amp;mMsg); initializeMotionEvent(motionEvent, &amp;mMsg); *outSeq = mMsg.body.motion.seq; *outEvent = motionEvent; break; &#125; default: return UNKNOWN_ERROR; &#125; &#125; return OK;&#125; mChannel-&gt;receiveMessage(&amp;mMsg)函数在InputChannel中主要如下实现，调用socket函数recv从mFd中读出数据。 frameworks/native/libs/input/InputTransport.cpp :1nRead = ::recv(mFd, msg, sizeof(InputMessage), MSG_DONTWAIT); 3.4回到java层，在获得event后，就需要进行分发了。receiverObj指向的是一个InputEventReceiver对象，这里其实是它的子类WindowInputEventReceiver对象，见第12章第4节。dispatchInputEvent函数还是继承的父类的，没有重写。 3.5这一步直接调用了下一步。 3.6将event插入等待事件队列的尾部，然后开始调度这些消息。 frameworks/base/core/java/android/view/ViewRootImpl.java :123456789101112131415161718192021222324252627282930void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; adjustInputEventForCompatibility(event); //将event和receiver封装在一起 QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); // Always enqueue the input event in order, regardless of its time stamp. // We do this because the application or the IME may inject key events // in response to touch events and we want to ensure that the injected keys // are processed in the order they were received and we cannot trust that // the time stamp of injected events are monotonic. //找到尾部插入 QueuedInputEvent last = mPendingInputEventTail; if (last == null) &#123; mPendingInputEventHead = q; mPendingInputEventTail = q; &#125; else &#123; last.mNext = q; mPendingInputEventTail = q; &#125; mPendingInputEventCount += 1; if (processImmediately) &#123; //立即处理所有的InputEvent doProcessInputEvents(); &#125; else &#123; //发送一个提醒消息 scheduleProcessInputEvents(); &#125; &#125; 这里会有两种不同的处理event的方式，一个是立即处理；另一种是向主线程Looper发送MSG_PROCESS_INPUT_EVENTS消息。这里选择立即处理。 3.7这里会把等待在队列中的event，一口气全处理了。这一步会循环拿出队列中的每一个event，然后调用下一步进行处理。 3.8准备交给stage处理。 frameworks/base/core/java/android/view/ViewRootImpl.java :12345678910111213141516 private void deliverInputEvent(QueuedInputEvent q) &#123;//...//下面开始从某个stage开始//寻找适合的stage进行处理 InputStage stage; if (q.shouldSendToSynthesizer()) &#123; stage = mSyntheticInputStage; &#125; else &#123; stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; &#125; if (stage != null) &#123; stage.deliver(q); &#125; else &#123; finishInputEvent(q); &#125; &#125; 3.9下面就讲解一下stage是什么东西。stage可以说是处理event的不同阶段，如果上一个stage处理不了，就交给下一个stage处理，总有一个stage可以将event处理掉。这里stage的处理顺序图如下所示： NativePrelmeInputStage: Delivers pre-ime input events to a native activity. Does not support pointer events. 其实我也不清楚到底是干什么的，没有想到具体的应用场景。 ViewPreImeInputStage: Delivers pre-ime input events to the view hierarchy. Does not support pointer events. 这一步只处理KeyEvent，在InputMethod处理这个KeyEvent之前，可以截获这个event。典型的例子是处理BACK key。 ImeInputStage: Delivers input events to the ime. Does not support pointer events. 将event交给IputMethodManager处理。 EarlyPostImeInputStage: Performs early processing of post-ime input events. 在交给下一阶段之前，先处理筛选一些event。 NativePostImeInputStage: Delivers post-ime input events to a native activity. 尝试让InputQueue发送event给native activity。 ViewPostImeInputStage: Delivers post-ime input events to the view hierarchy. 将event发送给view的层次结构中。 SyntheticInputStage: Performs synthesis of new input events from unhandled input events. 最后一个阶段，处理综合事件，比如trackball, joystick等。 这里我们暂且研究第6种stage，这个stage和View有直接关系。 3.10这里根据event的类型分别进行处理。我们先关注一下PointerEvent如何处理的。 3.11将event交给mView来处理，这里mView就是一个DecorView对象。 3.12这一步是DecorView继承自View的方法，将event分为TouchEvent和GenericMotionEvent来处理。先看TouchEvent如何处理。 3.13DecorView重写了该函数。这里调用getCallback函数来获取一个回调对象。该函数是PhoneWindow继承自Window类的方法，获得是mCallback。那么这个mCallback到底是谁呢？ 回顾一下Activity的创建过程，在Activity创建以后会调用attach函数对Activity进行一定的初始化，其中就创建了PhoneWindow，同时设置了callback为Activity它自己。所以这一步获得是一个Activity对象，然后调用它的函数继续分发event。 3.14Event交到Activity手中进行处理。为什么会先交给Activity处理？目的是让开发者可以重写这个函数，从而可以在分发这个事件之前进行截获。 12345678910111213141516171819202122/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; //绕一圈有交给PhoneWindow处理 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; //没有view可以处理，那么activity自己处理 //默认就是放弃，也可以重写实现特定功能 return onTouchEvent(ev);&#125; 3.15什么也没做，将event传回DecorView，让它处理。 ###3.16这里DecorView又交给dispatchTouchEvent处理。这里的dispatchTouchEvent是源自父类ViewGroup的函数，而不是自己重写的函数。 ###3.17ViewGroup是View的子类。它管理了一组View在mChildren数组中，按照设计模式的说法叫Composite模式。 这一步会依次访问每个子view，判断他们是否可以处理该event，如果能就交给它处理；没人能处理就自己处理。无论哪种方式，都会调用下一步dispatchTransformedTouchEvent函数。 frameworks/base/core/java/android/view/ViewGroup.java :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public boolean dispatchTouchEvent(MotionEvent ev) &#123; //.. // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; //如果Window没有被遮住，才进行以下过程 if (onFilterTouchEventForSecurity(ev)) &#123; //.. TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; //.. final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. //根据z坐标进行排序，从小到大的顺序 final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); //也可以自己定制顺序 final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); //所有子View存放在mChildren中 final View[] children = mChildren; //按z的值，从大到小开始遍历 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. //如果指定了一个view去获得这个event，一直循环到那个view为止 if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //判断该view是否可以接受这个event，是否在这个view范围内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //如果该child正在处理上一个event newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; //尝试去向该child发送event if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. //.. //将child加入mFirstTouchTarget为首的队列头部 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; //.. &#125; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; //没有child可以处理，那么就自己处理 // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; //.. if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; //.. &#125; predecessor = target; target = next; &#125; &#125; //.. &#125; return handled;&#125; 3.18ViewGroup会决定自己处理还是交给child处理。在ViewGroup自己处理，或者child为不再是一个ViewGroup时，则开始调用View的dispatchTouchEvent函数。 frameworks/base/core/java/android/view/ViewGroup.java :123456789//省略了计算坐标便宜的过程if (child == null) &#123; //ViewGroup决定自己处理 handled = super.dispatchTouchEvent(event);&#125; else &#123; //交给child处理，child可能是个view //也可能还是个ViewGroup，这就重复3.17步骤 handled = child.dispatchTouchEvent(event);&#125; 3.19这一步就会调用用户自己实现的Listener；如果没有Listener，则会调用view默认的处理函数。 frameworks/base/core/java/android/view/View.java :12345678910111213141516171819202122232425262728293031public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; //该View不可访问的状态，返回 return false; &#125; &#125; boolean result = false; //.. //先判断该View是否被遮挡，没被遮挡才进行处理 if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement //获得注册的Listener，看是否有注册OnTouchListener ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; //调用Listener的回调函数，处理event result = true; &#125; //View也可以采用默认的处理onTouchEvent if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; //.. return result; &#125; 默认处理函数onTouchEvent会处理一些基本的操作，比如button的按下松开的效果，滚动容器产生滚动的效果等。 3.20在InputStage完成处理event的任务后，会开始返回完成的消息。 3.21开始调用c++函数。 3.22将指针转化为NativeInputEventReceiver指针，交给它来处理。 frameworks/base/core/jni/android_view_InputEventReceiver.cpp ：123sp&lt;NativeInputEventReceiver&gt; receiver = reinterpret_cast&lt;NativeInputEventReceiver*&gt;(receiverPtr);status_t status = receiver-&gt;finishInputEvent(seq, handled); 3.23InputConsumer依次处理每个sequence，发送完成信号。 3.24向channel发送完成消息。 1234567status_t InputConsumer::sendUnchainedFinishedSignal(uint32_t seq, bool handled) &#123; InputMessage msg; msg.header.type = InputMessage::TYPE_FINISHED; msg.body.finished.seq = seq; msg.body.finished.handled = handled; return mChannel-&gt;sendMessage(&amp;msg);&#125; 向Channel写入事件后，处于睡眠的InputDispatcher被唤醒，开始分发下一个event。 最后说两句到这里，Input event的处理流程已经分析完了，心好累。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(12):InputChannel的注册过程","date":"2017-02-14T06:24:58.000Z","path":"2017/02/14/Android系统源码阅读-12-InputChannel的注册过程/","text":"请对照AOSP版本：6.0.1_r50。 InputManager可以获得输入事件并分发，Activity需要处理这些输入事件。那么，这两者之间如何建立的连接呢？这就需要InputChannel作为桥梁建立两者之间的通道。 1. ViewRootImpl创建InputChannel这里ViewRoot类已经消失了，由ViewRootImpl替代。Activity在创建时会将自己的DecorView设置给对应的ViewRootImpl。 1.1这一步会创建client的InputChannel，并且将当前启动的Activity的窗口传递给WindowManagerService。 frameworks/base/core/java/android/view/ViewRootImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * We have one child */public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; //将view设置为传入的DecorView mView = view; //.. mAdded = true; int res; /* = WindowManagerImpl.ADD_OKAY; */ //新建InputChannel if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; mInputChannel = new InputChannel(); &#125; try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); //mWindowSession是一个Binder代理对象 //它引用了运行在WindowManagerService中的一个类型为Session的Binder本地对象 //向WindowManagerService添加正在启动的Activity的窗口 //这里还会将InputChannel传递过去 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (RemoteException e) &#123; //.. &#125; finally &#123; //.. &#125; //.. if (view instanceof RootViewSurfaceTaker) &#123; mInputQueueCallback = ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue(); &#125; if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; //将InputChannel和主线程关联起来，在下面会详细讲解 mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; view.assignParent(this); &#125; &#125;&#125; 1.2这一步是进程间的请求，从应用进程转到WindowManagerService进程，对应于1.1中的函数addToDisplay。这里会补足一些参数，开始调用下一步函数。 1.3这一步也是调整一些参数，然后交给WindowManagerService来处理。 1.4这里会将传入的Window存入Map来进行统一管理，同时创建了一对server/client端的InputChannel。 frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; //先对添加的window做一些检查，省略.. //创建了一个WindowSatete对象 WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); //.. if (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; String name = win.makeInputChannelName(); //创建了一个InputChannel对，在1.5中详细讲解 InputChannel[] inputChannels = InputChannel.openInputChannelPair(name); //一个放在WindowState里作为server端的InputChannel win.setInputChannel(inputChannels[0]); //一个转化为client传递过来的outInputChannel inputChannels[1].transferTo(outInputChannel); //从上一篇文章中的1.1可知，InputManager作为参数传入 //WindowManagerService的构造函数，并且存放在mInputManager中 //下面章节会详细讲述如何注册server端的InputChannel mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); &#125; // From now on, no exceptions or errors allowed! //将win放入mWindowMap，以client的binder为关键字 mWindowMap.put(client.asBinder(), win); //将win加入相应的list，省略.. mInputMonitor.setUpdateInputWindowsNeededLw(); boolean focusChanged = false; if (win.canReceiveKeys()) &#123; focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS, false /*updateInputWindows*/); if (focusChanged) &#123; imMayMove = false; &#125; &#125; if (imMayMove) &#123; moveInputMethodWindowsIfNeededLocked(false); &#125; assignLayersLocked(displayContent.getWindowList()); // Don't do layout here, the window must call // relayout to be displayed, so we'll do it there. if (focusChanged) &#123; mInputMonitor.setInputFocusLw(mCurrentFocus, false /*updateInputWindows*/); &#125; mInputMonitor.updateInputWindowsLw(false /*force*/); &#125; return res; &#125; 1.5这一步会将任务交给c++层来处理。 1.6这一步对应的c++的函数为android_view_InputChannel_nativeOpenInputChannelPair，它会创建两个InputChannel，并返回。 frameworks/base/core/jni/android_view_InputChannel.cpp :12345678910111213141516171819202122232425static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env, jclass clazz, jstring nameObj) &#123; //将java String变为char* const char* nameChars = env-&gt;GetStringUTFChars(nameObj, NULL); String8 name(nameChars); env-&gt;ReleaseStringUTFChars(nameObj, nameChars); sp&lt;InputChannel&gt; serverChannel; sp&lt;InputChannel&gt; clientChannel; //创建c++层的两个Channel，将在下一步详细讲解 status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel); jobjectArray channelPair = env-&gt;NewObjectArray(2, gInputChannelClassInfo.clazz, NULL); //创建java的server channel jobject serverChannelObj = android_view_InputChannel_createInputChannel(env, new NativeInputChannel(serverChannel)); //创建java的client channel jobject clientChannelObj = android_view_InputChannel_createInputChannel(env, new NativeInputChannel(clientChannel)); //存入java数组 env-&gt;SetObjectArrayElement(channelPair, 0, serverChannelObj); env-&gt;SetObjectArrayElement(channelPair, 1, clientChannelObj); return channelPair;&#125; 1.7注意，这一步真的要创建ChannelPair了。 frameworks/native/libs/input/InputTransport.cpp :123456789101112131415161718192021222324252627282930status_t InputChannel::openInputChannelPair(const String8&amp; name, sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123; int sockets[2]; //这个socketpair建立的是一个可以双向通信的管道，创建一对套接字描述符 if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) &#123; status_t result = -errno; ALOGE(\"channel '%s' ~ Could not create socket pair. errno=%d\", name.string(), errno); outServerChannel.clear(); outClientChannel.clear(); return result; &#125; //设置管道缓存的大小 int bufferSize = SOCKET_BUFFER_SIZE; setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); //开始new 两个InputChannel String8 serverChannelName = name; serverChannelName.append(\" (server)\"); outServerChannel = new InputChannel(serverChannelName, sockets[0]); String8 clientChannelName = name; clientChannelName.append(\" (client)\"); outClientChannel = new InputChannel(clientChannelName, sockets[1]); return OK;&#125; socketpair创建了一对无名的套接字描述符（只能在AF_UNIX域中使用），描述符存储于一个二元数组s[2] .这对套接字可以进行双工通信，每一个描述符既可以读也可以写。这个在同一个进程中也可以进行通信，向s[0]中写入，就可以从s[1]中读取（只能从s[1]中读取），也可以在s[1]中写入，然后从s[0]中读取；但是，若没有在0端写入，而从1端读取，则1端的读取操作会阻塞，即使在1端写入，也不能从1读取，仍然阻塞；反之亦然。该段解释来自。 这里new了两个InputChannel，该类的构造函数如下： frameworks/native/libs/input/InputTransport.cpp :123456InputChannel::InputChannel(const String8&amp; name, int fd) : mName(name), mFd(fd) &#123; //.. int result = fcntl(mFd, F_SETFL, O_NONBLOCK); //..&#125; 这里将描述符mFd设置为nonblock。 显然，这里和Android 2.3版本有着很大区别。在旧版本中使用的是匿名共享内存和两个pipe来实现双向的通信。显然，新版本利用的linux系统的新机制，更为简洁高效。 以上步骤实在新Activity建立，窗口开始创建时执行的。这里主要就让WindowManagerService建立一对InputChannel，将Activity的Window和InputDispatcher建立起连接，从而传输输入事件。 2. Server端注册InputChannel在1.4中，创建了一对InputChannel，其中Server端的InputChannel会注册进InputManagerService。 1mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); 2.1这一步就检验了一下传入的InputChannel是否为空。下面一言不合就开始调用native函数。 2.2frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :123456789101112//将指针转化为NativeInputManagerNativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);//将java的InputChannel对象转化为一个c++层的InputChannel对象sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj);//将InputWindowHandle转化为c++层的InputWindowHandlersp&lt;InputWindowHandle&gt; inputWindowHandle = android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj);//将注册任务交给NativeInputManagerstatus_t status = im-&gt;registerInputChannel(env, inputChannel, inputWindowHandle, monitor);//.. 2.3这一步通过NativeInputManager中的InputManager，InputManager通过InputDispatcher来注册InputChannel。frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :12mInputManager-&gt;getDispatcher()-&gt;registerInputChannel( inputChannel, inputWindowHandle, monitor); 2.4终于，将Server端的InputChannel交给了InputDispatcher。 frameworks/native/services/inputflinger/InputDispatcher.cpp :12345678910111213141516171819AutoMutex _l(mLock);//判断是否该InputChannel已经添加过if (getConnectionIndexLocked(inputChannel) &gt;= 0) &#123; ALOGW(\"Attempted to register already registered input channel '%s'\", inputChannel-&gt;getName().string()); return BAD_VALUE;&#125;//创建一个Connectionsp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);//获得InputChannel的文件描述符int fd = inputChannel-&gt;getFd();//将Connection 以文件描述符为关键字，添加入mmConnectionsByFd.add(fd, connection);//..//将文件描述符添加Looper，让Looper监控InputChannel的IO事件//当IO事件发生时，就会调用回调函数handleReceiveCallbackmLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); 到这一步，InputDispatcher已经将InputChannel的Server端管理起来了。当Dispatcher将一个事件通过Channel发送给应用程序窗口以后，会进入休眠状态，直到应用窗口再次通过这个Channel返回一个消息将其激活，Dispatcher才准备发送下一个消息。 这里创建的Connection，Connection中又创建了InputPublisher。InputPublisher可以直接将消息通过这个InputChannel发送出去。 3. 向InputManagerService注册当前激活的应用程序窗口再次回顾一下1.4的，在1.4中WindowManagerService在焦点发生改变时，需要改变Focused Window。这里会在InputMonitor中注册当前激活的窗口。 3.1在InputMonitor中，有mInputFocus保存着当前激活的窗口，这里会将mInputFocus设置为传入的newWindow。然后调用updateInputWindowLW继续更新激活的窗口。 3.2在1.4中，每个window会被加入一个Window List。这里会遍历这些List中的Windows，然后将这些windows进一步交给InputManagerService处理。 rameworks/base/services/core/java/com/android/server/wm/InputMonitor.java :123456789101112131415161718192021222324252627282930313233343536373839404142// Populate the input window list with information about all of the windows that// could potentially receive input.// As an optimization, we could try to prune the list of windows but this turns// out to be difficult because only the native code knows for sure which window// currently has touch focus.//..// Add all windows on the default display.//mService指WindowManagerServicefinal int numDisplays = mService.mDisplayContents.size();for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; WindowList windows = mService.mDisplayContents.valueAt(displayNdx).getWindowList(); for (int winNdx = windows.size() - 1; winNdx &gt;= 0; --winNdx) &#123; final WindowState child = windows.get(winNdx); final InputChannel inputChannel = child.mInputChannel; final InputWindowHandle inputWindowHandle = child.mInputWindowHandle; if (inputChannel == null || inputWindowHandle == null || child.mRemoved) &#123; // Skip this window because it cannot possibly receive input. continue; &#125; //.. final int flags = child.mAttrs.flags; final int privateFlags = child.mAttrs.privateFlags; final int type = child.mAttrs.type; //只有一个window可以获得Focus final boolean hasFocus = (child == mInputFocus); final boolean isVisible = child.isVisibleLw(); //.. addInputWindowHandleLw(inputWindowHandle, child, flags, type, isVisible, hasFocus, hasWallpaper); &#125;&#125;// Send windows to native code.//将这些windows交给InputManager继续进行注册mService.mInputManager.setInputWindows(mInputWindowHandles);// Clear the list in preparation for the next round.clearInputWindowHandlesLw(); 3.3这一步InputManagerService将任务交给了c++层。 3.4进入c++层，将这些windowHandles交给NativeInputManager。 frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :1234567static void nativeSetInputWindows(JNIEnv* env, jclass /* clazz */, jlong ptr, jobjectArray windowHandleObjArray) &#123; //将ptr转化为指针 NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr); //windowHandleObjArray是传入的windowHandles im-&gt;setInputWindows(env, windowHandleObjArray);&#125; 3.5这一步先将java的windowHandle变为c++对象，然后这些windowHandle被交给InputDispatcher处理。 frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :1234567891011121314151617181920if (windowHandleObjArray) &#123; jsize length = env-&gt;GetArrayLength(windowHandleObjArray); //将java对象转化为c++对象 for (jsize i = 0; i &lt; length; i++) &#123; jobject windowHandleObj = env-&gt;GetObjectArrayElement(windowHandleObjArray, i); if (! windowHandleObj) &#123; break; // found null element indicating end of used portion of the array &#125; sp&lt;InputWindowHandle&gt; windowHandle = android_server_InputWindowHandle_getHandle(env, windowHandleObj); if (windowHandle != NULL) &#123; windowHandles.push(windowHandle); &#125; env-&gt;DeleteLocalRef(windowHandleObj); &#125; &#125; //将这些windowHandles交给Dispatcher处理 mInputManager-&gt;getDispatcher()-&gt;setInputWindows(windowHandles); 3.6InputDispatcher跟新WindowHandle，并且更新Focused window。 frameworks/native/services/inputflinger/InputDispatcher.cpp ：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; // acquire lock AutoMutex _l(mLock); //清理旧的WindowHandle Vector&lt;sp&lt;InputWindowHandle&gt; &gt; oldWindowHandles = mWindowHandles; mWindowHandles = inputWindowHandles; sp&lt;InputWindowHandle&gt; newFocusedWindowHandle; bool foundHoveredWindow = false; //找到新的Focused WindowHandle for (size_t i = 0; i &lt; mWindowHandles.size(); i++) &#123; const sp&lt;InputWindowHandle&gt;&amp; windowHandle = mWindowHandles.itemAt(i); if (!windowHandle-&gt;updateInfo() || windowHandle-&gt;getInputChannel() == NULL) &#123; mWindowHandles.removeAt(i--); continue; &#125; if (windowHandle-&gt;getInfo()-&gt;hasFocus) &#123; newFocusedWindowHandle = windowHandle; &#125; if (windowHandle == mLastHoverWindowHandle) &#123; foundHoveredWindow = true; &#125; &#125; if (!foundHoveredWindow) &#123; mLastHoverWindowHandle = NULL; &#125; if (mFocusedWindowHandle != newFocusedWindowHandle) &#123; //旧的FocusedWindow和新的不同，则需要停止向旧的Channel中发送消息 if (mFocusedWindowHandle != NULL) &#123; sp&lt;InputChannel&gt; focusedInputChannel = mFocusedWindowHandle-&gt;getInputChannel(); if (focusedInputChannel != NULL) &#123; synthesizeCancelationEventsForInputChannelLocked( focusedInputChannel, options); &#125; &#125; //设置新的Focused Window mFocusedWindowHandle = newFocusedWindowHandle; &#125; // Release information for windows that are no longer present. // This ensures that unused input channels are released promptly. // Otherwise, they might stick around until the window handle is destroyed // which might not happen until the next GC. for (size_t i = 0; i &lt; oldWindowHandles.size(); i++) &#123; const sp&lt;InputWindowHandle&gt;&amp; oldWindowHandle = oldWindowHandles.itemAt(i); if (!hasWindowHandleLocked(oldWindowHandle)) &#123; //释放已经不存在的旧Window oldWindowHandle-&gt;releaseInfo(); &#125; &#125;&#125; // release lock// Wake up poll loop since it may need to make new input dispatching choices.mLooper-&gt;wake(); 到这里，InputDispatcher获取了和激活的Window的双向通信通道，同时Dispatcher也知道了是哪个Window处于Focused状态。只要Client端将通信通道建立完毕，则Dispatcher可以向Activity的Window发送消息了。 4. Client端注册InputChannel1mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); 在1.1中，通过WindowSession添加Window和InputChannel后，mInputChannel对象已经转化为双向通道中的client端通道了，从1.4可以知道。然后，该步骤又创建了一个WindowInputEventReceiver类的对象mInputEventReceiver，它将mInputChannel和主线程绑定在一起。 下面就看一下WindowInputEventReceiver的构造过程。 4.1WindowInputEventReceiver是InputEventReceiver的子类，具体构造过程在InputEventReceiver中。 4.2这一步又开始调用native函数。 frameworks/base/core/java/android/view/InputEventReceiver.java:123mInputChannel = inputChannel;mMessageQueue = looper.getQueue();mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this), inputChannel, mMessageQueue); 4.3创建c++层的NativeInputEventReceiver。 frameworks/base/core/jni/android_view_InputEventReceiver.cpp :1234567891011121314151617181920static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject inputChannelObj, jobject messageQueueObj) &#123; //将java对象转化为c++对象 sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); //传入的java MessageQueue转化为c++的MessageQueue sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); //.. //创建了一个NativeInputEventReceiver，构造函数在下面 sp&lt;NativeInputEventReceiver&gt; receiver = new NativeInputEventReceiver(env, receiverWeak, inputChannel, messageQueue); //对其进行初始化 status_t status = receiver-&gt;initialize(); //返回一个NativeInputEventReceiver的指针 receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; NativeInputEventReceiver的构造函数。 frameworks/base/core/jni/android_view_InputEventReceiver.cpp :12345678910NativeInputEventReceiver::NativeInputEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;MessageQueue&gt;&amp; messageQueue) : mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)), mInputConsumer(inputChannel), mMessageQueue(messageQueue), mBatchedInputEventPending(false), mFdEvents(0) &#123; if (kDebugDispatchCycle) &#123; ALOGD(\"channel '%s' ~ Initializing input event receiver.\", getInputChannelName()); &#125;&#125; 4.4这一步调用函数setFdEvents，参数为ALOOPER_EVENT_INPUT。 4.5将传入的Channel让主线程监听起来，以便处理传入的消息。 frameworks/base/core/jni/android_view_InputEventReceiver.cpp123456789101112131415void NativeInputEventReceiver::setFdEvents(int events) &#123;' if (mFdEvents != events) &#123; mFdEvents = events; //获取Channel的文件描述符 int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) &#123; //获取Looper，给其添加监听fd的IO事件的请求 //MessageQueue的Looper为主线程Looper，如果Looper进入睡眠 //则会被Channel上写入的事件唤醒，从而可以处理新来的消息 mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); &#125; else &#123; mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); &#125; &#125;&#125; 这里监听的文件描述符发生IO事件时，调用的回调函数就是NativeInputEventReceiver自己，因为它为LooperCallback子类。 同时注意这里的Looper就是应用主线程的Looper，这里向其epoll多添加了一个文件描述符进行监听，因为epoll可以同时监听多个epoll的IO事件。同时设定了监听的类型为ALOOPER_EVENT_INPUT。 回忆下第10章的1.6步骤中epoll_wait进入的睡眠后，会监听mWakeEventFd文件描述符的事件。不仅如此，这一步还会监听更多的文件描述符的事件，这里就包括建立的InputChannel的文件描述符。所以在主线程通过调用pollInner进入睡眠以后，被唤醒后会判断发生事件的文件描述符是哪一个。 system/core/libutils/Looper.cpp :1234567891011121314151617181920if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); &#125; &#125; else &#123; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex)); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); &#125; &#125; 到这里，InputChannel在Client端也进行了监听，整个完整的window所在的应用主线程和InputDispatcher线程之间的双向Channel已经建立完毕，同时InputDispatcher知道哪一个window处于激活状态，因为它知道向哪一个window发送消息。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(11):Android的InputManagerService的工作过程","date":"2017-02-14T06:11:12.000Z","path":"2017/02/14/Android系统源码阅读-11-Android的InputManagerService的工作过程/","text":"请对照AOSP版本：6.0.1_r50。 1. 创建InputManager这里和老罗当年的版本有很大不同了，有了InputManagerService管理InputManager。 1.1想要探索如何启动的相关server，需要从SystemServer开始探寻。从SystemServer的进程开始运行开始，它就会创建一些系统server，这里就会启动other services。 其中，会创建Input Manager和Window Manager两个服务。 frameworks/base/services/java/com/android/server/SystemServer.java :1234567891011Slog.i(TAG, \"Input Manager\");inputManager = new InputManagerService(context);Slog.i(TAG, \"Window Manager\");wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore);ServiceManager.addService(Context.WINDOW_SERVICE, wm);ServiceManager.addService(Context.INPUT_SERVICE, inputManager);//..inputManager.start(); 1.2先来仔细端详一下InputManagerService的构造函数。这里会调用c++层的初始化函数。frameworks/base/services/core/java/com/android/server/input/InputManagerService.java :123this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper);//..mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); 注意这里将DisplayThread的Looper传递过去，DisplayThread是一个单例模式的类，它会启动唯一的线程。同时DisplayThread是一个HandlerThread的子类，实现了Looper循环机制。DisplayThread是用来执行和显示有关的操作，显示操作一般需要比较小的延迟。DisplayThread只能被WindowManager、DisplayManager，InputManager用来执行一些快速地实时操作。 1.3这一步首先将java层的MessageQueue变为了c++的MessageQueue。然后构造了一个NativeInputManager对象，最后将指向该对象的指针im返回给java层。 frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :1NativeInputManager* im = new NativeInputManager(contextObj, serviceObj, messageQueue-&gt;getLooper()); 1.4在构造NativeInputManager时，会创建一个InputManager对象mInputManager。 frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :12sp&lt;EventHub&gt; eventHub = new EventHub();mInputManager = new InputManager(eventHub, this, this); 1.5这一步会创建一个dispatcher负责分发输入事件，一个reader负责获取事件。frameworks/native/services/inputflinger/InputManager.cpp :123mDispatcher = new InputDispatcher(dispatcherPolicy);mReader = new InputReader(eventHub, readerPolicy, mDispatcher);initialize(); 1.6这里会创建两个线程，在以后的步骤中会用来运行前面创建的dispathcer和reader。 frameworks/native/services/inputflinger/InputManager.cpp :12mReaderThread = new InputReaderThread(mReader);mDispatcherThread = new InputDispatcherThread(mDispatcher); 2. 启动InputManager将视线再次回到SystemServer中，在创建完InputManagerService后，需要将这个Service启动，同样是在1.1的startOtherServices函数里，调用了InputManagerService的成员函数start。 2.1这里首先调用了c++层的nativeStart，然后InputManagerService将自己交给Watchdog监视。然后注册了PointerSpeedSetting和ShowTouchesSetting两个Observer。 frameworks/base/services/core/java/com/android/server/input/InputManagerService.java :1234567nativeStart(mPtr);// Add ourself to the Watchdog monitors.Watchdog.getInstance().addMonitor(this);registerPointerSpeedSettingObserver();registerShowTouchesSettingObserver(); 这两个Observer暂时还没搞清楚是干什么的。 2.2这一步将传来的ptr参数转化为一个NativeInputManager指针，同时开始启动NativeInputManager中的InputManager。 frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp :12NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);status_t result = im-&gt;getInputManager()-&gt;start(); 2.3这里会启动在1.6中创建的两个线程，分别用来分发和监听Input事件。 frameworks/native/services/inputflinger/InputManager.cpp ：12status_t result = mDispatcherThread-&gt;run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY);result = mReaderThread-&gt;run(\"InputReader\", PRIORITY_URGENT_DISPLAY);) 3. 启动InputDispatcher在2.3中运行的线程以threadLoop为入口，开始进入循环。 3.1这一步直接将任务交给InputDispatcher的dispatchOnce函数。 frameworks/native/services/inputflinger/InputDispatcher.cpp :1234bool InputDispatcherThread::threadLoop() &#123; mDispatcher-&gt;dispatchOnce(); return true;&#125; 3.2整个函数如下： frameworks/native/services/inputflinger/InputDispatcher.cpp :12345678910111213141516171819202122232425void InputDispatcher::dispatchOnce() &#123; nsecs_t nextWakeupTime = LONG_LONG_MAX; &#123; // acquire lock AutoMutex _l(mLock); mDispatcherIsAliveCondition.broadcast(); // Run a dispatch loop if there are no pending commands. // The dispatch loop might enqueue commands to run afterwards. if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; // Run all pending commands if there are any. // If any commands were run then force the next poll to wake up immediately. if (runCommandsLockedInterruptible()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125; &#125; // release lock nsecs_t currentTime = now(); int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime); mLooper-&gt;pollOnce(timeoutMillis);&#125; 在这一步骤中，首先判断是否有Command还未被执行，如果有去执行Command。否则，调用dispatchOnceInnerLocked函数去获取事件，这里会将nextWakeupTime传递过去，让其设置合适的苏醒时间，具体内容在以后讲解。然后runCommandsLockedInterruptible函数会执行缓存的Command，如果有Command在这一步中被执行，则需要将苏醒事件设置为LONG_LONG_MIN，因为执行这些命令需要耗费事件，在这期间可能已经有输入事件发生了，所有下次循环不需要等待。 最后，根据等待时间和当前时间，计算出需要睡眠的时间，通过pollOnce进入睡眠，等待唤醒，或者超时。 3.3这里和上一个章节中的pollOnce道理相同。 3.4这里会调用epoll_wait函数，使其在mEpollFd所描述的epoll上等待一段时间，这个epoll监听着文件描述符的读写事件。如果有人在pip中写入，则会返回，否则等待指定时间后返回。 system/core/libutils/Looper.cpp1int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); 4. 启动InputReader在2.3中运行的线程以threadLoop为入口，开始进入循环。 4.1这一步与3.1一样，将任务丢给InputReader处理。 4.2这一步会尝试从mEventHub中获取事件，如果获取一些事件，则进行处理。frameworks/native/services/inputflinger/InputReader.cpp :1234567//从EventHub中获取event，这里先详细讲解这一步size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);//省略..if (count) &#123; //事件处理，将在后面博客中讲解 processEventsLocked(mEventBuffer, count);&#125; 这里我们先考虑如何从EventHub中获取事件的。 4.3首先这一个函数不是就获得一个event这么简单，它是想获得一组event，这里和旧版本有所不同，可见工程师对系统做了优化。这一步内容比较到，让我们通过注释来讲解。 frameworks/native/services/inputflinger/EventHub.cpp :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) &#123; ALOG_ASSERT(bufferSize &gt;= 1); AutoMutex _l(mLock); struct input_event readBuffer[bufferSize]; //event 指向了存储事件的位置 RawEvent* event = buffer; size_t capacity = bufferSize; bool awoken = false; //开始循环获取事件,目的是填充buffer for (;;) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); // Reopen input devices if needed. //如果需要重新打开输入设备，则首先要关闭所有的设备 if (mNeedToReopenDevices) &#123; mNeedToReopenDevices = false; ALOGI(\"Reopening all input devices due to a configuration change.\"); closeAllDevicesLocked(); mNeedToScanDevices = true; break; // return to the caller before we actually rescan &#125; // Report any devices that had last been added/removed. //这里会移除所有关闭的设备 while (mClosingDevices) &#123; Device* device = mClosingDevices; ALOGV(\"Reporting device closed: id=%d, name=%s\\n\", device-&gt;id, device-&gt;path.string()); mClosingDevices = device-&gt;next; //创建了一个设备removed的event event-&gt;when = now; event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device-&gt;id; event-&gt;type = DEVICE_REMOVED; event += 1; delete device; mNeedToSendFinishedDeviceScan = true; if (--capacity == 0) &#123; break; &#125; &#125; //如果上面步骤关闭了设备，这里需要重新扫描所有的设备 if (mNeedToScanDevices) &#123; mNeedToScanDevices = false; //下面会详细讲解这里如何获取输入设备的 scanDevicesLocked(); mNeedToSendFinishedDeviceScan = true; &#125; //这里会添加正在开启的设备 while (mOpeningDevices != NULL) &#123; Device* device = mOpeningDevices; ALOGV(\"Reporting device opened: id=%d, name=%s\\n\", device-&gt;id, device-&gt;path.string()); mOpeningDevices = device-&gt;next; //同样这里会创建设备添加的event event-&gt;when = now; event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id; event-&gt;type = DEVICE_ADDED; event += 1; mNeedToSendFinishedDeviceScan = true; if (--capacity == 0) &#123; break; &#125; &#125; if (mNeedToSendFinishedDeviceScan) &#123; mNeedToSendFinishedDeviceScan = false; event-&gt;when = now; event-&gt;type = FINISHED_DEVICE_SCAN; event += 1; if (--capacity == 0) &#123; break; &#125; &#125; //以上步骤主要是负责重新获取接入的设备，下面将会负责获得设备中的event // Grab the next input event. bool deviceChanged = false; //开始循环获取pending的event //当前处理的Event序号是否小于正在等待的事件数目，这里会循环读出所有等待的事件 while (mPendingEventIndex &lt; mPendingEventCount) &#123; //获取一个event项 const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++]; //如果这是个INotify事件 if (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123; if (eventItem.events &amp; EPOLLIN) &#123; mPendingINotify = true; &#125; else &#123; ALOGW(\"Received unexpected epoll event 0x%08x for INotify.\", eventItem.events); &#125; continue; &#125; //如果这是一个Id wake事件，则读出mWakeReadPipeFd的数据，让等待在这个文件描述符上的线程得到唤醒 if (eventItem.data.u32 == EPOLL_ID_WAKE) &#123; if (eventItem.events &amp; EPOLLIN) &#123; ALOGV(\"awoken after wake()\"); awoken = true; char buffer[16]; ssize_t nRead; do &#123; nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer)); &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer)); &#125; else &#123; ALOGW(\"Received unexpected epoll event 0x%08x for wake read pipe.\", eventItem.events); &#125; continue; &#125; //这里开始处理其它非特殊的event //获取event项对应的设备的编号 ssize_t deviceIndex = mDevices.indexOfKey(eventItem.data.u32); if (deviceIndex &lt; 0) &#123; ALOGW(\"Received unexpected epoll event 0x%08x for unknown device id %d.\", eventItem.events, eventItem.data.u32); continue; &#125; //获取设备，所有已知的设备都放在了mDevices中 Device* device = mDevices.valueAt(deviceIndex); if (eventItem.events &amp; EPOLLIN) &#123; //从这个设备中读出数据流，并且存入readBuffer下 int32_t readSize = read(device-&gt;fd, readBuffer, sizeof(struct input_event) * capacity); if (readSize == 0 || (readSize &lt; 0 &amp;&amp; errno == ENODEV)) &#123; // Device was removed before INotify noticed. //先处理一些异常情况，先省略 //... &#125; else &#123; //键盘事件的id需要特殊处理，一直设置为0 int32_t deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id; size_t count = size_t(readSize) / sizeof(struct input_event); //开始循环，从设备中读出每一个event for (size_t i = 0; i &lt; count; i++) &#123; struct input_event&amp; iev = readBuffer[i]; //这里做了许多处理事件异常时间的工作，先略过 //... //将获取的事件存入event event-&gt;deviceId = deviceId; event-&gt;type = iev.type; event-&gt;code = iev.code; event-&gt;value = iev.value; //event指向下一个位置，容量也随之减少一个 event += 1; capacity -= 1; &#125; if (capacity == 0) &#123; // The result buffer is full. Reset the pending event index // so we will try to read the device again on the next iteration. //buffer已经填满，退出处理pending event的循环，将index回到上一个位置，因为该设备event还没读完，下次再接着读 mPendingEventIndex -= 1; break; &#125; &#125; &#125; else if (eventItem.events &amp; EPOLLHUP) &#123; //处理一些其它情况，省略 //... &#125; &#125; //在读出所有event后，才能关闭设备，这里省略了对此的处理过程 //... //到这里说明pending event已经处理完，或者buffer已经塞满。buffer塞满或者存了一些事件，则退出最外层填充buffer的循环 // Return now if we have collected any events or if we were explicitly awoken. if (event != buffer || awoken) &#123; break; &#125; //这里处理了一些wake lock的事情，省略 //... //到这一步说明buffer里没有填任何事件，同时也没有pending event //所以需要等待有人向device文件描述符里写入一些事件 int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis); //时间已到，还是没有事件，那咱就结束吧 if (pollResult == 0) &#123; // Timed out. mPendingEventCount = 0; break; &#125; //出错了，让我睡一会，下次再尝试 if (pollResult &lt; 0) &#123; // An error occurred. mPendingEventCount = 0; // Sleep after errors to avoid locking up the system. // Hopefully the error is transient. if (errno != EINTR) &#123; ALOGW(\"poll failed (errno=%d)\\n\", errno); usleep(100000); &#125; &#125; else &#123; // Some events occurred. mPendingEventCount = size_t(pollResult); //获取了一些event，那么继续循环，填充buffer！ &#125; &#125; // All done, return the number of events we read. return event - buffer;&#125; 4.4从这里开始扫描设备。在研究这个函数前，先看一下DEVICE_PATH的来头： frameworks/native/services/inputflinger/EventHub.cpp :12345//这一段代码位于EventHub的构造函数中，这里使用了linux的inotify机制//inotify机制可以监控文件的变化//因此系统可以实时监控设备的添加和移除mINotifyFd = inotify_init();int result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE); frameworks/native/services/inputflinger/EventHub.cpp :1234567891011void EventHub::scanDevicesLocked() &#123; //扫描目录：/dev/input status_t res = scanDirLocked(DEVICE_PATH); if(res &lt; 0) &#123; ALOGE(\"scan dir failed for %s\\n\", DEVICE_PATH); &#125; if (mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; 0) &#123; //创建一个虚拟键盘 createVirtualKeyboardLocked(); &#125;&#125; 4.5这里开始扫描/dev/input/目录下的所有设备。 frameworks/native/services/inputflinger/EventHub.cpp :1234567891011121314151617181920212223242526status_t EventHub::scanDirLocked(const char *dirname)&#123; char devname[PATH_MAX]; char *filename; DIR *dir; struct dirent *de; dir = opendir(dirname); if(dir == NULL) return -1; strcpy(devname, dirname); filename = devname + strlen(devname); //filename指向了devname目录的尾端，方便在其后面添加设备文件 *filename++ = '/'; //读取该目录下的每一个设备文件 while((de = readdir(dir))) &#123; if(de-&gt;d_name[0] == '.' &amp;&amp; (de-&gt;d_name[1] == '\\0' || (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2] == '\\0'))) continue; strcpy(filename, de-&gt;d_name); //打开设备，devname里是设备的绝对路径 openDeviceLocked(devname); &#125; closedir(dir); return 0;&#125; 4.6frameworks/native/services/inputflinger/EventHub.cpp :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859status_t EventHub::openDeviceLocked(const char *devicePath) &#123; char buffer[80]; //打开文件 int fd = open(devicePath, O_RDWR | O_CLOEXEC); if(fd &lt; 0) &#123; ALOGE(\"could not open %s, %s\\n\", devicePath, strerror(errno)); return -1; &#125; InputDeviceIdentifier identifier; // Get device name. if(ioctl(fd, EVIOCGNAME(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123; //fprintf(stderr, \"could not get device name for %s, %s\\n\", devicePath, strerror(errno)); &#125; else &#123; buffer[sizeof(buffer) - 1] = '\\0'; identifier.name.setTo(buffer); &#125; // Check to see if the device is on our excluded list //删除排除的设备 //一下步骤从文件中获取device的基本信息 //... // Get device driver version. // Get device identifier. // Get device physical location. // Get device unique id. // Fill in the descriptor. // Make file descriptor non-blocking for use with poll(). //创建device对象 // Allocate device. (The device object takes ownership of the fd at this point.) int32_t deviceId = mNextDeviceId++; Device* device = new Device(fd, deviceId, String8(devicePath), identifier); //根据device的特征，设置device的class参数 //... // Register with epoll. struct epoll_event eventItem; memset(&amp;eventItem, 0, sizeof(eventItem)); eventItem.events = EPOLLIN; if (mUsingEpollWakeup) &#123; eventItem.events |= EPOLLWAKEUP; &#125; eventItem.data.u32 = deviceId; //将该device的文件fd交给epoll监视，以及时获得它的变化 if (epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp;eventItem)) &#123; ALOGE(\"Could not add device fd to epoll instance. errno=%d\", errno); delete device; return -1; &#125; //处理时钟问题.. //添加device addDeviceLocked(device); return 0; 4.7这一步比较轻松，将创建好的device对象放入mDevices即可。12345void EventHub::addDeviceLocked(Device* device) &#123; mDevices.add(device-&gt;id, device); device-&gt;next = mOpeningDevices; mOpeningDevices = device;&#125;","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android Monkey 源代码阅读","date":"2017-02-14T06:09:32.000Z","path":"2017/02/14/Android-Monkey-源代码阅读/","text":"0. Monkey基本信息目前该工具位于源代码的位置：development/cmds/monkey。 生成的jar包位于：out/traget/product/generic/system/framework/monkey.jar。 在设备中，启动monkey的脚本位于/system/bin/monkey:1234567# Script to start &quot;monkey&quot; on the device, which has a very rudimentary# shell.#base=/systemexport CLASSPATH=$base/framework/monkey.jartrap &quot;&quot; HUPexec app_process $base/bin com.android.commands.monkey.Monkey $* 1. Monkey开始启动 main函数只是设置了进程的名称，主要过程在run函数中执行。 获取参数，初始化参数和随机数。然后它会获取系统的一些服务，见1.3。获取需要启动的main activity，见1.4。创建一个MonkeySourceRoandom对象mEventSource，由他管理随机事件的生成，这里首先让它生成了一个启动main activity的事件放入了队列。monkey还支持通过脚本、网络获取事件，这里只说默认的随机情况。下面，它启动Network Monitor。接着，启动Monkey的循环过程，见1.5。等待测试结束后，则输出测试报告。 获取一些系统服务，有ActivityManager、WindowManager、PackageManager。给ActivityManager设置了一个ActivityController对象，该对象提供了Activity启动、crash获取、应用无响应等功能。最后，还注册了一个网络状态的监听器。 从PackageManager中获取符合条件的main activity，然后添加入mMainApps中。 这一步就会循环的生成测试事件见1.6、触发事件1.10。 从队列中获取第一个事件返回。如果队列为空，则生成一个放入队列，见1.7。 这里先生成一个随机数，根据随机数范围，决定具体生成哪一个事件。这里有点击、拖动、缩放（前三个，见1.8）、轨迹球（已经不常用了，可以忽略）、旋转、权限（见1.9）和键盘事件。 这里会首先利用DisplayManager获得屏幕的实际大小，然后随机的生成生成点坐标。Touch只需要一点就够了，而Drag则需要生成一系列的点，这里利用了randomWalk函数来随机的移动来生成下一个点坐标，然后将这一系列点坐标封装成事件放入队列。两指缩放同样使用了和Drag类似的方法，只不过是将一个点变为两个点。 从目标package中的权限列表中获取一个，然后生成一个MonkeyPersissionEvent。 MonkeyEvent是一个抽象类，具体的实现在其子类中。MotionEvent通过InputManager注入事件。旋转MonkeyRotationEvent通过WindowManager进行旋转。MonkeyPermissionEvent利用PackageManager授予、撤销应用的一些权限。MonkeyKeyEvent同样是使用InputManager进行注入。 这里还有一些其它事件。MonkeyActivityEvent的事件是由ActivityManager启动的。MonkeyCommandEvent则启动一个进程，执行命令即可。MonkeyFlipEvent，唤起键盘的操作，这里是向/dev/input/event0写入了一组字节。MonkeyGetAppFrameRateEvent和MonkeyGetFrameRateEvent，获取应用帧频，通过命令行执行来实现。MonkeyInstrumentationEvent, 利用ActivityManager启动Instrumentation组件。MonkeyNoopEvent，什么也不做，呵呵。MonkeyPowerEvent，从log信息中获取电量信息。MonkeyThrottleEvent和MonkeyWaitEvent，Thread.sleep休眠一段时间。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(10):Android应用程序的消息处理机制","date":"2017-02-14T06:07:55.000Z","path":"2017/02/14/Android系统源码阅读-10-Android应用程序的消息处理机制/","text":"基础知识 原来写好的博客被CSDN给坑了，法克，只能靠回忆重写。 Android应用程序的四种组件皆运行于ActivityThread之中。ActivityThread包含有程序入口main，同时它会启动一个循环，这个循环会轮询消息队列，来处理发送给它的消息。而四种组件则被这个线程统一管理。所以，ActivityThread这个线程是一个动态的过程，像一个无休止的转动的法条，而四个组件则像是被驱动四个齿轮，需要它们转动时才会在法条的带动下进行转动。 主线程中有一个Looper，Looper是一个循环，其中又有一个MessageQueue来管理消息队列。MessageQueue又有一个mPtr变量，记录了c++层对应的NativeMessageQueue的位置。NativeMessageQueue也有一个c++层的Looper，它负责管理pip，而pip则是进程间通信的通道。 1. 线程消息循环 ActivityThread会由此进入循环。通过一个无限循环，从MessageQueue里获取Message，这里可能会被阻塞，见1.2。获取消息后，分发消息到响应的的组件。 调用nativePollOnce函数来判断是否有新的消息，见1.3。如果有新消息，则判断时机是否已到，时机到了则将Message返回。如果时机未到，或者还没有消息，则先执行一些IdleHandler。 这一步将ptr翻译成一个NativeMessageQueue的对象指针，然后将任务交给它来处理。目前该c++文件位于frameworks/base/core/jni目录下。 NativeMessage又将任务交给c++层的Looper来处理。 Looper.cpp文件位于system/core/libutils。这里同样一个循环，不断调用pollInner来判断时候有新消息。 Looper中有一个epoll实例，epoll是用来监听IO读写的一种机制，这里来监听pip是否有读写事件。这里使用epoll_wait来等待epoll中的读写事件，如果没有则会根据设定睡眠一段时间。如果有事件，则对比该事件描述符是否为mWakeEventFd文件描述符，如果是，则调用awoken。 尝试从mWakeEventFd文件描述符中读出数据，里面的数据并没有什么实际意义。 2. 线程消息发送过程Handler用来向一个消息队列发送消息。它内部有mLooper和mQueue，在构造Handler时，会将它所在线程中的Looper获取，放入mLooper。 发送一个消息。 加入延迟的发送消息。 在某个时间点发送消息，这里会将这个消息和发送时刻放入队列。 将message的target设为该Handler，然后将message放入mQueue。 消息队列是根据时间进行排序，所以这一步会根据该消息的时间，将消息插入到适合的位置。如果队列头发生变化，就要进入native世界，唤醒等待的人。 这一函数对应c++中的android_os_MessageQueue_nativeWake。这里会将传入的ptr转化为一个NativeMessageQueue的指针。 调用mLooper的wake函数。 这一步会向mWakeEventFd描述写入一个数据”1”，并没有什么实际意义，就是想触发一个IO事件，然后让等待这个IO事件的epoll_wait触发。 3. 线程消息处理 再次回到looper函数，在第1节中，线程会阻塞在该函数中，直到获取了一个消息。如果获得的消息为null，则退出循环。否则，获取消息的target，从2.4可知target为一个Handler，下面看这个Handler如何派发消息。 这里要处理三种情况：第一种，message提供了自己的回调函数，见3.3；第二种，使用Handler提供回调函数mCallback，见3.4；第三种，由Handler继续处理见3.5。 这里message的callback参数指向的是一个Runnable的对象，所以这一步直接启动这个对象的run函数即可。 CallBack接口中只有handleMessage函数，这里需要在定义Handler时，设定一个实现CallBack接口的对象。 同样，这是一个需要子类来具体实现的函数。一般我们在定义一个Handler时，定义的是一个Handler子类，在handleMessage函数中实现自己的功能。 4. 接着说两句在1.2中涉及到的IdleHandler，在没有消息需要处理时，会调返回这个空闲Handler。那么，我们来看一下这个Handler如何工作的。 在MessageQueue中，有mIdleHandlers来存放IdleHandler。在next函数中，如果没有获得一个消息，则会开始处理idler。这里会判断是否有idler在mIdleHandlers中，没有或者原来已经发送过一个了，则无需发送，所以一个线程的一次next调用，最多只会发送一次idler。 如果有idler，且为第一次发送，则开始处理这些idler。这里会调用IdleHandler的queueIdler函数。同样，这里需要自己实现IdlerHandler接口，来处理一些不紧急的事情。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(9):ContentProvider数据更新通知","date":"2017-02-14T06:05:43.000Z","path":"2017/02/14/Android系统源码阅读-9-ContentProvider数据更新通知/","text":"1. 用户注册内容观察者 用户（比如一个Activity）想要实时获得某项内容的变化，需要注册相应的观察者。这个观察者可以自定，但是需要继承ContentObserver类，这个类的构造函数需要一个Handle参数，这个Handle就是用来向用户发送数据变化消息的。然后将observer作为参数，利用ContentResolver的这个函数进行注册。 在1.1中想要注册observer，首先要利用该步骤获取ContentService。ContentService是一个系统服务，由ServiceManager管理。这一步获取的实际上市ContentService的Binder代理对象。 在1.1中注册的observer实际传递的是observer的Transport类型的Binder代理对象，所以这一步要从observer中获得这个transport。 这一步为进程间函数调用。这一步会将observer加入到mRootNode中，因为ContentService用一棵树来维护所有注册到这里的观测者。用树结构是因为URI天然的树状结构。 这个函数是一个在树上寻找和添加节点的递归函数。在按照URI的层次结构寻找目标节点时，可能会创造新的节点。直到匹配了最后的节点，将observer封装在ObserverEntry中，添加进该节点。 2. Content Provider发送更新消息 Content Provider如果想要发送更新通知，需要调用ontifyChange函数。这一步以新的URI、和Observer为参数，这里将Observer设置为null。这一步会做一些检测URI、observer是否为空的工作。最后，仍然是获取一个ContentService的进程间通讯代理，然后调用ContentService的notifyChange函数。 在这一步中，会从根节点mRootNode中收集所有的Observer，见2.3。然后依次调用这些Observer的onChange函数，见2.4。 这一步会根据URI指示的路径，依次遍历树上的节点。对于经过的每一个节点，需要将该节点上所有对这个消息感兴趣的observer都封装成ObserverCall添加进入。 这一步也是进程间的函数调用。这里Transport又将消息抛给ContentObserver处理。 ContentObserver将消息封装进一个NotificationRunnable函数，然后利用mHandler 将其post给应用程序主线程处理。 这个函数是在主线程中运行。这将要调用它父类的onChange函数。 运行自己重写的ContentObserver的onChange函数，消息发送完毕。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(8):ContentProvider数据传输过程","date":"2017-02-14T06:03:37.000Z","path":"2017/02/14/Android系统源码阅读-8-ContentProvider数据传输过程/","text":"该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 1. 用户开始查询 用户调用query函数进行查询。首先尝试获得provider，这里分为两种，先是unstable，后是stable，暂时没有分清这两者之间的区别。在尝试获取Provider的过程中，将会类似于第7篇文章中的过程。这里假设该用户已经有该provider的记录，获取过程见1.2。在取得provider后，见1.5。 继续获取Provider。 继续获取Provider。 ActivityThread将所有已经获得的Provider放在mProviderMap中。这里假设需要获取的Provider存在，返回一个IContentProvider类型的provider，这个接口指向了Content Provider的一个Transport代理对象，即ContentProviderProxy对象。 使用provider的代理进行查询。这里会创建一个BulkCursorToCursorAdaptor对象。该版本没有创建CursorWindow对象，即没有创建匿名内存，和旧版本有些区别。那么，新版本中在哪里创建共享的内存区呢？最后，准备通过进程间通信发送消息，等待返回的BulkCursorDescriptor，然后可以获得对应的BulkCursorToCursorAdaptor，即一个AbstractWindowedCursor。 2. Content Provider处理事务 该函数负责处理QUERY_TRANSACTION事务。首先将传入的数据解析出来，然后利用其子类Transport进行查询，从2.2~2.6，获得一个SQLiteCursor对象。然后用SQLiteCursor封装成CursorToBulkCursorAdapter对象。然后创建BulkCursorDescriptor，从2.7~2.11，目的就是创建window，将数据放入window。然后将BulkCursorDescriptor存入reply，里面包含了SQLiteCursor的binder本地对象，因为SQLiteCursor里又含有window，最后返回给用户后，用户可以获得window里存储的内容。 这里会检查用户是否有权限访问该数据，如果有权限，则调用自己实现的ContentProvider子类的query函数进行查询。 该函数需要在子类中重载，实现自己的查询过程。这里，我们假设使用了数据库查询。 这里会首先根据传入的参数创建一条SQL查询语句，然后在数据库中进行查询。 这一步会创建一个数据查询driver，用来执行查询。 创建一个SQLiteCursor对象，这个对象包含了database、driver、query。下面就是将SQLiteCursor返回，一直返回到2.1中。 该步骤会对创建的BulkCursorDescriptor进行一定的初始化。 获得用户需要的数据条数。开始时为-1，说明尚未执行查询过程，所以下面要执行查询数据，同时将数据放入内存共享区window。 因为window还没创建，所以第一件事是先创建共享内存区window，见2.10。然后填充window，见2.11。 这一步会创建新的window或者清空旧的window以重复利用。这里的window以数据库的路径为名称。创建CursorWindow的过程会调用native函数，见3.1~3.3，所以，新的Android版本放弃了原来在用户中创建window的模式，而是在Content Provider中统一创建、管理window。 填充window，这里同样会使用sql的一些方法，最后落脚于调用native函数，见4.1~4.3。执行到这里，需要查询的数据已经被存储于window中。 3. Provider创建window的native过程 在2.10中，会创建CursorWindow对象，所以，SQLiteCursor调用了CursorWindow的构造函数。在该步骤中，会设置window的大小，该大小会在资源文件xml中设置。然后创建window的过程就交给c++代码完成。 android_database_CursorWindow.cpp位于frameworks/base/core/jni/目录下。这里会创建一个CursorWindow对象window，见3.3。然后用reinterpret_cast函数将window指针类型变为jlong返回。 这里就会创建匿名内存块。这里使用了匿名内存分配的机制，暂不深究。 4. Provider填充window的native过程 在2.11中，会对步骤3中创建的window进行填充。这一步会获得一个SQLiteConnection对象，然后通过这个connection进行数据库操作。 这里开始调用native code执行数据查询，同时填充window。 这里会通过sqlite3一行一行的将数据copy入window，这里暂不深究sqlite3如何在c++中的使用过程。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(7):Content Provider的启动","date":"2017-02-14T06:01:17.000Z","path":"2017/02/14/Android系统源码阅读-7-ContentProvider的启动/","text":"该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 基本知识 Content Provider运行在一个独立的应用程序进程中，它本事就是一个Android应用程序。 Binder进程间通信只适合传递体积较小的数据结构，不适合大量数据的传输。所以需要采用匿名共享内存来传输体积较大的数据。 Cursor对象通过匿名共享内存来传输数据，而Bundle是通过Binder传递数据。 1. 用户开始调用Provider首先，Activity集成的ContextWrapper中有成员函数getContentResolver，用该函数可以获得一个ContentResolver对象。该ContentResolver对象是在ContextImpl对象建立时创建的一个ApplicationContentResolver对象。 下面从ContentResolver.acquireProvider开始。 步骤1的主要目的是验证URI是否正确，然后就会将acquireProvider的任务交给子类来实现，这里它将任务传递给ApplicationContentResolver。 步骤2直接将任务给主线程处理。 步骤3将会尝试从已有的Provider中获取目标Provider，ActivityThread将已经访问过的Provider放入mProviderMap中，如果其中含有需要获取的Provider，只需要增加对其的引用数目即可。如果没有，则需要请求ActivityManager来获取Provider（见1.4），ActivityManager最后会返回一个ContentProviderHolder（见2.2，见6.1）。最后，需要将获得的ContentProviderHolder进行install(见1.5)。 这里假设没有现成的Provider，则需要交给ActivityManager进行处理。 这一步和5.7是一样的函数，区别在于这里的holder不为null，所以不需要自己通过类加载创建Provider，只需要将这个Provider放入mProviderRefCountMap中，对其引用加1。 2. ActivityManager处理请求 这一步检验调用者caller是否为空，如果为空，则说明没有应用在请求Provider，则无需继续进行。 这一步所做的处理比较多。首先，Manager首先根据name在mProviderMap中查找是否已经启动。如果没有，则根据Class来查找是否已经启动。如果仍然没有，则构建ContentProviderRecord，里面包含了ProviderInfo,ApplicationInfo等重要信息。然后，如果是multiprocess属性为true，则将该ContentProviderRecord直接返回给调用者，让其实例化。在我们的例子中，我们假设该属性为false，需要创建新的进程来启动该Provider。下面就要开始启动新的进程，会在2.3中详细讲述，然后将Record放入mProvider。最后，ActivityManager进入循环等待provider启动，在发现provider启动后（见6.1），则退出循环，将ContentProviderHolder返回给用户（见1.3）。 这一步就是进入启动新进程的准备工作。 3. 新进程的启动这里的启动过程和原来一样。 4. ActivityManager处理新的进程 获取新进程pid。 这一步先根据pid获得对应的ProcessRecord，然后填充ProcessRecord的信息。然后，获取需要在该进程中启动的Provider的列表，将在4.3中详解。接下来依次启动该进程中的Content Provider（在4.4中详解）、Activity、Service和Broadcast Receiver。 这一步通过PackageManager获得所有的该应用进程下需要启动的Provider，然后为其创建ContentProviderRecord，放入mProviderMap。 准备向新进程发送消息。 5. Content Provider在新进程中启动 将收到的数据封装成一个AppBindData，准备发送到主线程中。 发送消息。 发送消息。 处理异步消息。 准备启动所有的Provider。 这一步将传递过来的每一个ProviderInfo通过installProvider函数（见5.7）封装成了ContentProviderHolder。然后将所有生成的ContentProviderHolder告知给ActivityManager（见5.11）。 这一步根据Provider的类名，使用ClassLoader实例化一个ContentProvider对象，并对其进行一定的初始化（见5.8、5.9）工作。然后，创建对应的ProviderClientRecord，将其放入mLocalProviders和mLocalProvidersByName。 获取该Provider的类型为Transport的Binder本地对象。这个Binder将会告知给ActivityManagerService，然后有它再告知给需要使用该Provider的其它组件。然后其它进程组件就可以使用这个Binder来使用这个provider了。 这里会设置该provider的context，同时设置读写权限。最后会调用重写的onCreate函数。 调用自己实现的onCreate函数。 将自己的Provider告知给ActivityManager。 6. ActivityManager发布Provider 这一步会将ActivityManager利用获得的ContentProviderHolder对记录的ContentProviderRecord的provider进行填充，同时将该ContentProviderRecord放入mProviderMap。最后将该Record移除mLaunchingProviders。在2.2中等待的ActivityManagerService线程循环等待发现provider不为null，退出循环，返回ContentProviderHolder给用户（见1.3）。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(6)广播机制","date":"2017-02-14T05:57:56.000Z","path":"2017/02/14/Android系统源码阅读-6-广播机制/","text":"Android系统源码阅读（6）：广播机制 该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 注册广播接收器Step1. Activity开始注册 Step2. ActivityManagerService处理注册 发送广播Step1. Activity发送广播 Step2. ActivityManagerService处理广播消息 Step3. Activity接收广播","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(5):Service在进程内绑定","date":"2017-02-14T05:56:11.000Z","path":"2017/02/14/Android系统源码阅读-5-Service在进程内绑定/","text":"Android系统源码阅读（5）：Service在进程内绑定 该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 Step1. Activity开始启动Service Step2. ActivityManagerService中准备 这里需要注意有两次进程间通信，先讲第7步 (Step3)，再讲第9步(Step4)。 Step3. Service创建 Step4. Service公布IBinder Step5. ActivityManagerService公布Service Step6. Activity建立Connection","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(4):Service在新进程中启动过程","date":"2017-02-14T05:54:43.000Z","path":"2017/02/14/Android系统源码阅读-4-Service在新进程中启动过程/","text":"Android系统源码阅读（4）：Service在新进程中启动过程 该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 Step1. Activity开始启动Service Step2. ActivityManagerService准备 Step3. ActivityThread新进程启动 Step4. ActivityManagerService启动等待的Service Step5. Server创建","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(3):子Activity在进程内的启动过程","date":"2017-02-14T05:51:41.000Z","path":"2017/02/14/Android系统源码阅读-3-子Activity在进程内的启动过程/","text":"该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 子Activity在进程内的启动过程Step1. Activity开始启动另一个Activity这里和从Launcher启动过程几乎没分别，但是启动有些参数的设置还是有区别的。 Step2. ActivityManagerService准备同样这些会先停止正在最前端的Activity。 Step3. 旧Activity停止同样这里需要在完成停止过程后告知ActivityManagerService。 Step4. ActivityManagerService继续准备万事俱备，只待真的启动Activity。 Step5. 新Activity创建到这里启动完毕。 Task, Process and Activity这几个概念真的很让人混淆，最基本的一句话是它们几个是完全不同的抽象概念。 先说Process和Activity。一个Application可以多个Activity和多个Process。两个Activity可以运行在相同的Process里，也可以在不同的Process里，这里可以在AndroidManifest.xml中设置android:process，默认情况下是运行在同一个Process里的。并且该进程中的Activity、Service都是运行在主线程中，所以Service也不是一个独立的线程概念，不可以直接在Service中运行耗时的任务。 Task同样和Process没有一一对应的关系。Task是描述Activity跳转状态的栈，利用后退操作是在同一个栈中进行Activity的回退；同样，某一个Activity启动了其它Application的Activity（比如你的app调用了系统自带的相册app），这两个Activity同样会放置于同一个栈中，虽然这两个acitivity明显不在同一个Application中，也有可能不在同一个Process中。Task在用户通过任务管理器来切换时，则会发生交换。将前台的Task放到后面，你选择的Task则会置于最前端。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(2):根Activity组件的启动过程","date":"2017-02-14T05:34:58.000Z","path":"2017/02/14/Android系统源码阅读-2-根Activity组件的启动过程/","text":"该系列只记录阅读代码时遇到的问题和心得体会，具体代码讲解可以参考老罗的《Android系统源代码情景分析》，我就不班门弄斧了。我编译的AOSP版本：6.0.1_r50。 代码摘抄两个版本的Launcher目前版本已经从Launcher2（packages/apps/Launcher2/src/com/android/launcher2）进化为Launcher3（packages/apps/Launcher3/src/com/android/launcher3）。两个版本的Launcher有着一定的差异，老罗书中以Launcher2为出发点。 packages/apps/Launcher2/src/com/android/launcher2/Launcher.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051boolean startActivity(View v, Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; // Only launch using the new animation if the shortcut has not opted out (this is a // private contract between launcher and may be ignored in the future). boolean useLaunchAnimation = (v != null) &amp;&amp; !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); UserHandle user = (UserHandle) intent.getParcelableExtra(ApplicationInfo.EXTRA_PROFILE); LauncherApps launcherApps = (LauncherApps) this.getSystemService(Context.LAUNCHER_APPS_SERVICE); if (useLaunchAnimation) &#123; ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); if (user == null || user.equals(android.os.Process.myUserHandle())) &#123; // Could be launching some bookkeeping activity startActivity(intent, opts.toBundle()); &#125; else &#123; launcherApps.startMainActivity(intent.getComponent(), user, intent.getSourceBounds(), opts.toBundle()); &#125; &#125; else &#123; if (user == null || user.equals(android.os.Process.myUserHandle())) &#123; startActivity(intent); &#125; else &#123; launcherApps.startMainActivity(intent.getComponent(), user, intent.getSourceBounds(), null); &#125; &#125; return true; &#125; catch (SecurityException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"Launcher does not have the permission to launch \" + intent + \". Make sure to create a MAIN intent-filter for the corresponding activity \" + \"or use the exported attribute for this activity. \" + \"tag=\"+ tag + \" intent=\" + intent, e); &#125; return false;&#125;boolean startActivitySafely(View v, Intent intent, Object tag) &#123; boolean success = false; try &#123; success = startActivity(v, intent, tag); &#125; catch (ActivityNotFoundException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e); &#125; return success;&#125; packages/apps/Launcher3/src/com/android/launcher3/Launcher.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private boolean startActivity(View v, Intent intent, Object tag) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; // Only launch using the new animation if the shortcut has not opted out (this is a // private contract between launcher and may be ignored in the future). boolean useLaunchAnimation = (v != null) &amp;&amp; !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this); UserManagerCompat userManager = UserManagerCompat.getInstance(this); UserHandleCompat user = null; if (intent.hasExtra(AppInfo.EXTRA_PROFILE)) &#123; long serialNumber = intent.getLongExtra(AppInfo.EXTRA_PROFILE, -1); user = userManager.getUserForSerialNumber(serialNumber); &#125; Bundle optsBundle = null; if (useLaunchAnimation) &#123; ActivityOptions opts = null; if (Utilities.ATLEAST_MARSHMALLOW) &#123; int left = 0, top = 0; int width = v.getMeasuredWidth(), height = v.getMeasuredHeight(); if (v instanceof TextView) &#123; // Launch from center of icon, not entire view Drawable icon = Workspace.getTextViewIcon((TextView) v); if (icon != null) &#123; Rect bounds = icon.getBounds(); left = (width - bounds.width()) / 2; top = v.getPaddingTop(); width = bounds.width(); height = bounds.height(); &#125; &#125; opts = ActivityOptions.makeClipRevealAnimation(v, left, top, width, height); &#125; else if (!Utilities.ATLEAST_LOLLIPOP) &#123; // Below L, we use a scale up animation opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); &#125; else if (Utilities.ATLEAST_LOLLIPOP_MR1) &#123; // On L devices, we use the device default slide-up transition. // On L MR1 devices, we a custom version of the slide-up transition which // doesn't have the delay present in the device default. opts = ActivityOptions.makeCustomAnimation(this, R.anim.task_open_enter, R.anim.no_anim); &#125; optsBundle = opts != null ? opts.toBundle() : null; &#125; if (user == null || user.equals(UserHandleCompat.myUserHandle())) &#123; // Could be launching some bookkeeping activity startActivity(intent, optsBundle); &#125; else &#123; // TODO Component can be null when shortcuts are supported for secondary user launcherApps.startActivityForProfile(intent.getComponent(), user, intent.getSourceBounds(), optsBundle); &#125; return true; &#125; catch (SecurityException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"Launcher does not have the permission to launch \" + intent + \". Make sure to create a MAIN intent-filter for the corresponding activity \" + \"or use the exported attribute for this activity. \" + \"tag=\"+ tag + \" intent=\" + intent, e); &#125; return false;&#125;public boolean startActivitySafely(View v, Intent intent, Object tag) &#123; boolean success = false; if (mIsSafeModeEnabled &amp;&amp; !Utilities.isSystemApp(this, intent)) &#123; Toast.makeText(this, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show(); return false; &#125; try &#123; success = startActivity(v, intent, tag); &#125; catch (ActivityNotFoundException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e); &#125; return success;&#125; Android的Singleton模式的实现在frameworks/base/core/java/android/app/ActivityManagerNative.java中IActivityManager是一个单利模式，所以Android实现了一个很标准的Singleton。在老罗版本里，没有使用这个类。 framework/base/core/java/android/util/Singleton.java:123456789101112131415161718192021/** * Singleton helper class for lazily initialization. * * Modeled after frameworks/base/include/utils/Singleton.h * * @hide */public abstract class Singleton&lt;T&gt; &#123; private T mInstance; protected abstract T create(); public final T get() &#123; synchronized (this) &#123; if (mInstance == null) &#123; mInstance = create(); &#125; return mInstance; &#125; &#125;&#125; ActivityManagerService显然，AcitivityManagerService的位置由frameworks/base/services/java/com/android/service/am/ActivityManagerService.java转移至frameworks/base/services/core/java/com/android/service/am/ActivityManagerService.java。同时startActivity函数也有所改变： frameworks/base/services/core/java/com/android/service/am/ActivityManagerService.java:123456789101112131415161718192021@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null);&#125; 主要的变化是添加了用户的概念，同时加入了mStackSupervisor（ActivityStackSuperVisor）来管理ActivityStack。 根Activity启动过程下面将用顺序图来展示根Activity是如何从桌面启动的。 Step1. Launcher启动一个APP当用户点击某一个应用图标，意味着需要启动一个应用的根Activity。Launcher也是一个应用，和普通应用启动Activity过程类似。这里展示了在Launcher中的进行的步骤，最后通过Binder与ActivityMangerService进行进程间通信，告知它来启动Activity。 Step2. ActivityMangerService进行准备工作这里主要工作就行将需要启动的Activity放置于栈顶，等待启动。在启动新Activity前，需要将旧的Activity先停止下来。 Step3. 旧Activity停止在这里，需要停止的Activity就是Launcher的Activity。在完成停止的过程后，需要告知ActivityMangerService。 Step4. ActivityMangerService继续准备这里会发现该Activity还没有进程可以运行，所以需要先启动一个新的ActvityThread进程。 Step5. ActivityThread进程启动等进程启动完毕后，同样需要ActivityMangerService，以便它将等待该进程的Activity启动起来。 Step6. ActivityMangerService继续启动这里会将等待该进程的Activity和Service启动起来。 Step7. 新Activity启动到这里，启动过程结束","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Android系统源码阅读(1):编译","date":"2017-02-14T05:31:31.000Z","path":"2017/02/14/Android系统源码阅读-1-编译/","text":"1. 编译过程参考官方，注意细节。 编译版本6.0.1_r50。 1.1 下载第三方二进制文件如果想要将编译好的img刷入物理设备，而不是虚拟机，一定要先下载好这些二进制文件，放在AOSP的根目录下。 二进制文件下载。下载完毕后并解压后，会有sh文件生成；运行sh文件，会在AOSP目录下生成vendor/文件夹，必要的文件会放在里面。然后再执行编译。 1.2 编译先清理一下旧的生成文件，个人认为很有必要。12345678make clobber``` 然后设置环境变量: ```sh$ source build/envsetup.sh# 或者$ . build/envsetup.sh 设置java 环境变量，这里根据你的AOSP选择java版本，设置适当的java路径:12$ export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64$ export PATH=$JAVA_HOME/bin:$PATH 设置缓存区域，根据自己情况设置：123export USE_CCACHE=1export CCACHE_DIR=/home/tianchi/Project/.ccache prebuilts/misc/linux-x86/ccache/ccache -M 50G 选择需要编译的目标：12$ launch#选择你想要编译的版本 开始编译，设置编译时用到的内核数目，这里写４：1$ make -j4 稍等几个小时，呵呵，奇迹就会发生。生成的结果位于out/target/product/flo/，flo是我Nexus 7的型号，和launch时选择的版本相同。 2. 刷入真机将编译好的img文件刷入设备比较容易，关键点在于前面步骤：下载了第三方包，选择了正确的编译版本。 重启设备进入fastboot模式，使用命令，这里刷入的Nexus7：1$ fastboot -p flo flashall 3. 启动emulator问题想要在虚拟机里跑起来，需要在launch步骤中选择正确的虚拟机版本，默认第一个。 相关工具emulator和kernel-qemu默认放置目录已经不在out/host/linux-xxx/bin，已经迁移到prebuilts/android-emulator/linux-x86_64/emulator和/prebuilts/qemu-kernel/x86_64/kernel-qemu等相对应的位置。 常用的启动命令：123prebuilts/android-emulator/linux-x86_64/emulator -kernel ./prebuilts/qemu-k ernel/x86_64/kernel-qemu -sysdir out/target/product/generic/ -system system.img -data userdata.img -ramdisk ramdisk.img``` 该命令启动会出现各种各样的问题，例如： qemu: could not load initrd ‘ramdisk.img’1234567891011121314151617181920212223242526272829303132333435虽然有人已经给出了相关解决方案，比如去掉`-ramdisk ramdisk.img`，或者修改`chmod -R 777 out/target/product/generic/`来增加权限，或者修改`/prebuilts/qemu-k ernel/x86_64/kernel-qemu`为合适的系统版本。这些解决方法有的不太有效，总之不是很优美，其实官方已经提供了一个启动emulator的省心方法： ```sh# 首先加入基本的环境变量$ source build/envsetup.sh# 选择需要启动的版本，这里因为我编译的1，所以一定要选择1.$ lunchYou&apos;re building on LinuxLunch menu... pick a combo: 1. aosp_arm-eng 2. aosp_arm64-eng 3. aosp_mips-eng 4. aosp_mips64-eng 5. aosp_x86-eng 6. aosp_x86_64-eng 7. aosp_deb-userdebug 8. aosp_flo-userdebug 9. full_fugu-userdebug 10. aosp_fugu-userdebug 11. mini_emulator_arm64-userdebug 12. m_e_arm-userdebug 13. mini_emulator_mips-userdebug 14. mini_emulator_x86_64-userdebug 15. mini_emulator_x86-userdebug 16. aosp_flounder-userdebug 17. aosp_angler-userdebug 18. aosp_bullhead-userdebug 19. aosp_hammerhead-userdebug 20. aosp_hammerhead_fp-userdebug 21. aosp_shamu-userdebug # 启动emulator$ emulator 4. 在Android Studio中阅读源码Android工程师很地道，考虑到了如何方便的将项目导入AndroidStudio。在编译完成，环境变量配置好的前提下，进行下面步骤。 4.1 生成idegen编译idegen:1$ mmm development/tools/idegen 运行idegen:1$ development/tools/idegen/idegen.sh 然后，你就回在AOSP目录下发现｀android.ipr｀等文件。 4.2 导入打开AndroidStudio，选择导入已有的项目，选择android.ipr。这里需要导入一段时间。 导入后会发现错误百出。首先打开Project Structure，选择｀SDKs｀添加一个SDK，我这里需要1.7：清理ClassPath下的所有jar包，然后保存。 选择Project，选择Project SDK为新建的SDK，Project language level也设置为对应的等级。 选择Modules，在Dependencies标签下，删除jar 依赖，最后如下： 然后在Modules下，Sources标签下，选择out/target/common/R文件，选择右键Source。这里一般情况下，会因为R文件过大，导致依然报错。这时需要修改AndroidStudio应用目录下Android_Studio/bin/idea.properties文件，找到filesize，将参数修改大一些。1idea.max.intellisense.filesize=5000 Android stack这个图应该时时回顾一下。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Nexus7搞机教程","date":"2017-02-14T05:28:37.000Z","path":"2017/02/14/Nexus7搞机教程/","text":"系统准备这里，我准备了Nexus 7（wifi第二版）作为测试机型，Android版本4.4.2。由于该机器是一个新机器，还没激活，需要在WLAN界面联网激活，否则无法进入系统。我已经尝试过使用代理IP，或者使用翻墙的其它手机作为热点，都以失败告终。所以，在这里我要介绍一种绕过Nexus 7激活的方法。 刷入recovery该过程用于Nexus 7绕过激活和设备root，有个好使的recovery也很必要。 首先保证电脑已经安装ADB环境，这里不再赘述安装过程。确保fastboot命令可以在终端执行即可。 我在这里推荐TWRP recovery，用起来很顺手。在 TeamWin - TWRP 找到自己需要的recovery，我在这里选择Asus Nexus 7 2013 Wi-Fi (flo)，这个一定要和自己移动设备匹配。 下载好twrp-xxxx.img文件，关机后，按Power+Volumn down来重启手机，进入fastboot模式。这时，保证设备和电脑通过USB连接，同时使用命令，可以在终端显示设备名称：1$ adb devices 如果手机初始状态为加锁状态，所以首先要解锁：1$ fastboot oem unlock 解锁成功后，然后刷入recovery：1$ fastboot flash recovery twrp.img 刷入recovery，成功会显示一些Okey字样。成功刷入以后，关闭设备，使用Power+Volumn up进入recovery模式，等待一小会，如果长时间停留在twrp初始界面，可以点击音量上或下键来观察是否已经进入。如果recovery无法进入，有可能是刷入的recovery和设备版本不一致。 Recovery不仅仅用于Nexus 7绕过激活，一会root手机时，也需要用到。 激活Nexus 7Twrp recovery提供了很人性化的界面，可以使用点击操作。你需要首先利用recovery的挂在功能(mount)，将/system分区挂在上，然后在计算机终端进入设备系统文件：12$ adb shell$ cd /system 这时可以看到文件build.prop，可以种cat或者vi来看里面内容，其中重要语句ro.setupwizard.network_required=true，这个就是要求网络验证的配置。这里，无论你用何种方法，把true改为false，保存即可。 重启手机，如果卡在等待界面，则按音量键，看时候可以进入（其实我也不知其中原委，只是这样试了一下，尽量耐心等待一段时间）。进入后会发现进入了正常的初始化步骤，到达WLAN连接激活时，发现下面神奇的多了一个按钮“跳过”！过程中可能会出现一些网络错误什么的，不必关心，只要一步步初始化，就可以最终进入系统。 Root手机已经root请跳过此步骤。 可以使用国内的root大师、精灵之流的root软件进行root，但是并不推荐，因为它们会附加安装一些应用。这里我推荐使用SuperSU结合recovery进行root。 首先下载SuperSU zip文件，下载完毕后，将其传入手机某个位置，然后重启进入recovery模式。 在recovery选择install 这个zip文件即可。重启后可以发现应用SuperSU，可以利用它管理手机权限。 刷入Android其它版本Android官方提供了很方便的image资源，其中 Nexus factory image列出了可用的所有Nexus镜像，寻找到适合的镜像进行下载，建议验证一下MD5校验码。下载完毕后，可以按照官网上的教程刷入系统，过程比较简单。 我在这里刷入了Android 4.3 (JSS15Q)版本，降低了Nexus系统的版本。刷机完毕后，可以重复上面步骤，刷入需要的的工具。需要注意的是在绕过激活时，4.3版本和4.4版本略有不同。在4.3版本中，前面步骤相同，最后修改build.prop时，只要加入ro.setupwizard.mode=DISABLED该配置即可绕过激活。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Android","slug":"Android","permalink":"http://itanch.github.io/tags/Android/"}]},{"title":"Ubuntu PPTPD 配置","date":"2017-02-14T05:12:48.000Z","path":"2017/02/14/UbuntuPPTPD配置/","text":"Server配置安装pptpd首先需要安装pptpd，ubuntu 默认安装该工具。 配置网络编辑 /etc/pptpd.conf，取消以下两行注释。当然也可以自己设定ip地址范围，这里使用默认的就可以。12localip 192.168.0.1remoteip 192.168.0.234-238,192.168.0.245 添加用户编辑/etc/ppp/chap-secrets文件，用户名添加如下：12345678 # Secrets for authentication using CHAP # client server secret IP addresses [client name] * &quot;[password]&quot; *``` 其中client的名字和密码自己设定即可，其它两项默认&quot;*&quot;就可以。### 设置DNS编辑`/etc/ppp/pptpd-options`，找到`ms-dns`部分，取消注释： ms-dns 223.5.5.5 ms-dns 223.6.6.61234默认的是google的DNS服务，`8.8.8.8`。因为国内使用不便，这里我修改成阿里的DNS服务。### 开启IP转发编辑`/etc/sysctl.conf`文件，取消注释： net.ipv4.ip_forward=11运行命令，使配置生效： sysctl -p123### iptables安装安装iptables: apt-get install iptablesiptables -t nat -I POSTROUTING -j MASQUERADE #每次运行前需要运行该命令12### 重启pptpd /etc/init.d/pptpd restart123456##Client配置在你需要使用代理的ubuntu设备上执行以下操作。当然，也可以用其它客户端。### 安装pptp一般系统已经默认安装。 sudo apt-get install pptp-linux12### 创建一个连接 sudo pptpsetup –create [server name] –server [server ip] –username [client name] –password [password] –encrypt –start1执行完上述命令后，会在`/etc/ppp/chap-secrets`自动生成相应的用户： added by pptpsetup for pptpd[client name] [server name] “password” *1在`/etc/ppp/peers/pptpd`中也会有生成的相应信息，这里需要注意一点，默认的是不用server 的DNS配置的，所以会出现ping ip地址可以成功，ping网址却失败的DNS解析错误，所以要加上如下一行: usepeerdns12345在上述命令成功后，`ifconfig`命令下回出现ppp0端口。### 路由设置将ppp0设置为默认路由端口： ip route del defaultip route add default dev ppp0123456这样配置基本算成功了。### 服务开关我自己写了如下命令方便开关和路由设置：打开服务(需要sudo): #!/bin/bashpon [server name]sleep 4ip route del defaultip route add default dev ppp01关闭服务(sudo): #!/bin/bashpoff pptpdsleep 4ip route del defaultip route add default via [your old route ip] dev eno1```这里需要记住原来设备的路由ip，以便删除后再回复。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://itanch.github.io/tags/ubuntu/"}]},{"title":"Cocos2d-x 安装","date":"2017-02-14T05:02:41.000Z","path":"2017/02/14/cocos2d-x安装/","text":"hello cocos2d 环境安装环境：Mac OS X运行目标：AndroidCocos2d版本：cocos2d-x-3.13.1，Cocos Console 2.1 Cocos2d-x 安装1. 基本工具安装Cocos2d-x，最基础的是安装命令行工具。在安装Cocos之前，需要一些其它基本工具： JAVA SDK Android SDK Android NDK Apache Ant Python 2.7.5 这些基本工具最好已经配置在环境变量中。 2. Cocos2d-x下载最新的Cocos2d-x，然后解压。找到setup.py，然后运行 1python setup.py 然后它会提醒你补足一些环境变量的绝对地址，最后在你原有的Home目录下的.bash_profile基础上增加一些环境变量，很贴心。 在我的mac上，补足的环境变量如下：123456789101112131415161718192021222324# Add environment variable COCOS_CONSOLE_ROOT for cocos2d-xexport COCOS_CONSOLE_ROOT=/Users/Tianchi/Tool/cocos2d-x-3.13.1/tools/cocos2d-console/binexport PATH=$COCOS_CONSOLE_ROOT:$PATH# Add environment variable COCOS_X_ROOT for cocos2d-xexport COCOS_X_ROOT=/Users/Tianchi/Toolexport PATH=$COCOS_X_ROOT:$PATH# Add environment variable COCOS_TEMPLATES_ROOT for cocos2d-xexport COCOS_TEMPLATES_ROOT=/Users/Tianchi/Tool/cocos2d-x-3.13.1/templatesexport PATH=$COCOS_TEMPLATES_ROOT:$PATH# Add environment variable NDK_ROOT for cocos2d-xexport NDK_ROOT=/Users/Tianchi/Tool/ndkexport PATH=$NDK_ROOT:$PATH# Add environment variable ANDROID_SDK_ROOT for cocos2d-xexport ANDROID_SDK_ROOT=/Users/Tianchi/Tool/sdkexport PATH=$ANDROID_SDK_ROOT:$PATHexport PATH=$ANDROID_SDK_ROOT/tools:$ANDROID_SDK_ROOT/platform-tools:$PATH# Add environment variable ANT_ROOT for cocos2d-xexport ANT_ROOT=/usr/local/apache-ant-1.9.4/binexport PATH=$ANT_ROOT:$PATH 是否安装成功：123$ cocos -vcocos2d-x-3.13.1Cocos Console 2.1 3. New Project创建一个项目： 1cocos new &lt;game name&gt; -p &lt;package identifier&gt; -l &lt;language&gt; -d &lt;location&gt; 样例：12345cocos new MyGame -p com.MyCompany.MyGame -l cpp -d ~/MyCompanycocos new MyGame -p com.MyCompany.MyGame -l lua -d ~/MyCompanycocos new MyGame -p com.MyCompany.MyGame -l js -d ~/MyCompany 编译项目： 1cocos compile -s &lt;path to your project&gt; -p &lt;platform&gt; -m &lt;mode&gt; -o &lt;output directory&gt; 样例： 12345cocos compile -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bincocos compile -s ~/MyCompany/MyGame -p android -m release -o ~/MyCompany/MyGame/bincocos compile -s c:\\MyCompany\\MyGame -p win32 -m release -o c:\\MyCompany\\MyGame\\bin 编译Android应用，需要指定目标版本1cocos compile -p android --ap android-22 编译成功后，就会在项目目录下的proj.android/bin下发现apk文件，可以进行安装。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://itanch.github.io/tags/Cocos2d-x/"}]},{"title":"AngularJS--SB Admin","date":"2016-01-15T02:56:03.000Z","path":"2016/01/15/AngularJS学习/","text":"从SB Admin开始学习AngularJS! SB Admin v2.0 rewritten in AngularJS是一个SB Admin的AngularJS的实现，源代码、安装和运行可以参考以上链接。 一些工具Nodejs升级：1234$ sudo npm cache clean -f$ sudo npm install -g n$ sudo n stable$ sudo ln -sf /usr/local/n/versions/node/&lt;VERSION&gt;/bin/node /usr/bin/node npm升级：123456789101112131415$ sudo npm install --global npm@latest``` [Bower](http://bower.io/)是一个对web开发进行包管理的工具。 [GRUNT](http://www.gruntjs.net/)的目的就是自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。 [Yeoman](http://yeoman.io/)生成web应用的基本架构。&lt;!--more--&gt;## Yeoman入门![yeoman](http://7xky03.com1.z0.glb.clouddn.com/yeoman.png) ### 1. 安装Bower、GRUNT和Yeoman： ```sh$ sudo npm install --global yo bower grunt-cli 2. 安装generator123456$ sudo npm install --global generator-karma generator-angular``` ### 3. 运行generator```sh$ yo angular 4. Yeoman总结Yeoman确实是一个很强大的web应用架构工具，他可以帮你完成大部分繁琐的工作，从而你可以更专心的实现你的功能。 源代码分析1. index.html位于app/目录下的index.html是整个网页的主要入口。123&lt;div ng-app=\"sbAdminApp\"&gt; &lt;div ui-view&gt;&lt;/div&gt;&lt;/div&gt; 2. app.js位于app/scripts/目录下，应用的主要module。 module首先，我们可以看到sbAdminApp使用了如下module： oc.lazyLoad：自动的加载一些module。 ui.router：AngularUI Router是一个路由框架，可以利用它将应用接口组织成为一个有穷状态机，不同于Angular自带的$route（根据URL进行路由），UI-Router则是根据状态进行路由。 ui.bootstrap：用AngularJS开发的Bootstrap组件。 configstateProvider：由ui.router提供，功能类似于Angular v1的router，但是它只专注于state。state就是应用中的某一个状态，到达某一个状态时，会将template插入到相应位置。该部分的主要工作是将state、html和controller对应起来。 resolve可以提供给controller一些定制的内容，采用key:value的格式。在这里，使用ocLazyLoad加载了一些模块。 首先加载的是sbAdminApp模块中的header部分，然后依次为header-notification、sidebar和sidebar-search。这些部分在加载的过程中，采用了module.directive函数，这个函数可以对指定的元素附加一些行为，如： angular.module('sbAdminApp') .directive('header',function(){ return { templateUrl:'scripts/directives/header/header.html', restrict: 'E', replace: true, } }); 这里就是在main.html的&lt;header&gt;&lt;/header&gt;元素替换为header.html的内容。 从源代码中不难发现，header、header-notification、sidebar和sidebar-search文件的加载是按照一定的顺序的，因为前后顺序在View中表现为嵌套的父子关系。 然后，加载了toggle-switch，一个开关模块；ngAnimate，动画效果；ngCookies，读写浏览器cookies；ngResource，加载资源对象；ngSanitize，可以对HTML进行清洁；ngTouch，对可触摸设备提供服务。 其它state类似。 ocLazyLoadProvider：来自于oc.lazyLoad，events:true可以使得加载module时可以发送广播。 urlRouterProvider：由ui.router提供，在这里只是用它来处理其它状态下的情况，统一重定向至/dashboard/home。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://itanch.github.io/tags/AngularJS/"},{"name":"Yeoman","slug":"Yeoman","permalink":"http://itanch.github.io/tags/Yeoman/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://itanch.github.io/tags/JavaScript/"}]},{"title":"MESOS and MARATHON安装","date":"2015-11-16T01:40:40.000Z","path":"2015/11/16/MESOS安装/","text":"基本环境系统环境：ubuntu14.04mesos: 0.25.0 从源代码安装根据官网Getting Started介绍，尝试从源代码编译安装，但未成功。在make check命令执行时出现一个错误，经过分析终于发现原因在于测试中会通过字符串比较验证结果，由于我的系统是中文系统，测试中预想的结果是英文的，所以就导致错误。最后，需要能够访问code.google.com才能进行make install。 从源代码安装时会安装一些依赖库，同时会安装openjdk。 apt-get根据mesosphere介绍，可以安装以下步骤进行安装： 添加库 123456$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv E56151BF$ DISTRO=$(lsb_release -is | tr '[:upper:]' '[:lower:]')$ CODENAME=$(lsb_release -cs)$ echo \"deb http://repos.mesosphere.com/$&#123;DISTRO&#125; $&#123;CODENAME&#125; main\" | \\ sudo tee /etc/apt/sources.list.d/mesosphere.list$ sudo apt-get -y update 安装 1$ sudo apt-get -y install mesos 启动master 1$ sudo mesos-master --ip=127.0.0.1 --work_dir=/var/lib/mesos 启动slave 1$ mesos-slave --master=127.0.0.1:5050 从浏览器观察结果http://127.0.0.1:5050。 MARATHON安装MARATHON依赖于Java 8。参考(mesosphere)[https://mesosphere.com/downloads/]的内容，安装过程如下： 添加必要的库 123456$ sudo apt-get update -y$ sudo DEBIAN_FRONTEND=noninteractive apt-get install -y python-software-properties software-properties-common$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv E56151BF$ DISTRO=$(lsb_release -is | tr '[:upper:]' '[:lower:]')$ CODENAME=$(lsb_release -cs)$ sudo echo \"deb http://repos.mesosphere.io/$&#123;DISTRO&#125; $&#123;CODENAME&#125; main\" | tee /etc/apt/sources.list.d/mesosphere.list 安装Java 8 1234$ sudo add-apt-repository ppa:webupd8team/java$ sudo apt-get update -y$ sudo apt-get install -y oracle-java8-installer oracle-java8-set-default$ sudo apt-get -y install marathon 运行MARATHON 1$ marathon --master zk://127.0.0.1:2181,127.0.0.1:2181/mesos --zk zk://127.0.0.1:2181,127.0.0.1:2181/marathon 从浏览器观察结果http://127.0.0.1:8080 MESOS的一些命令To (start | stop | restart) mesos-master:123456sudo service mesos-master (start | stop | restart)``` To (start | stop | restart) mesos-slave:```shsudo service mesos-slave (start | stop | restart) If you want to disable these service from launching automatically on a reboot:123echo manual &gt; /etc/init/mesos-master.overrideecho manual &gt; /etc/init/mesos-slave.overrideecho manual &gt; /etc/init/zookeeper.override","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"MESOS","slug":"MESOS","permalink":"http://itanch.github.io/tags/MESOS/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://itanch.github.io/tags/ubuntu/"}]},{"title":"MooseFS安装","date":"2015-09-22T08:21:51.000Z","path":"2015/09/22/MooseFS安装/","text":"MooseFS is a Fault tolerant, Highly available, Highly performing, Scaling-out, Network distributed file system. It spreads data over several physical commodity servers, which are visible to the user as one resource. For standard file operations MooseFS acts like any other Unix-like file system: 1.A hierarchical structure (directory tree) 2.Stores POSIX file attributes (permissions, last access and modification times) 3.Supports special files (block and character devices, pipes and sockets) 4.Symbolic links (file names pointing to target files, not necessarily on MooseFS) and hard links (different names of files which refer to the same data on MooseFS) 5.Access to the file system can be limited based on IP address and/or password 基本信息实验环境：两个Ubuntu14.04计算机。MooseFS版本：2.0.76。 MooseFS官网1，官网2。据观察，官网2内容较新。 参考1，参考2。 安装master(在选定的master节点上操作)添加key:123456$ wget -O - http://ppa.moosefs.com/moosefs.key | sudo apt-key add -``` 在文件`/etc/apt/sources.list.d/moosefs.list`中添加如下软件源： ```shdeb http://ppa.moosefs.com/stable/apt/ubuntu/trusty trusty main 更新软件源，安装master：12$ sudo apt-get update$ sudo apt-get install moosefs-master 拷贝/etc/mfs下的如下文件，可以按需修改其中的参数，也可以使用默认值：12$ cp mfsmaster.cfg.dist mfsmaster.cfg$ cp mfsexports.cfg.dist mfsexports.cfg 启动：1234567891011121314$ sudo mfsmaster start``` 可以修改`/etc/default/moosefs-ce-master`中的`MFSMASTER_ENABLE`为`true`，使得该服务开机启动。### 安装其它工具 ```sh$ sudo apt-get install moosefs-cgi$ sudo apt-get install moosefs-cgiserv$ sudo apt-get install moosefs-cli``` 启动mfscgiserv，可以在浏览器观察mfs运行情况。如果本机为master，可以访问[http://127.0.0.1:9425](http://127.0.0.1:9425)。```sh$ sudo mfscgiserv start 安装chunkserver(在选定的chunk节点上操作)首先像安装master一样添加软件源，然后安装：1234567$ sudo apt-get install moosefs-chunkserver``` 同样，修改`/etc/mfs`文件下的如下文件： ```sh$ sudo cp mfschunkserver.cfg.dist mfschunkserver.cfg$ sudo cp mfshdd.cfg.dist mfshdd.cfg 其中，mfschunkserver.cfg文件的参数MASTER_HOST = mfsmaster可以指定master的hostname，这里需要在/etc/hosts中写明，并且如果master也作为chunkserver时，hosts中mfsmaster的ip不能使用127.0.0.1。 建立文件,文件名字可以写自己喜欢的，这里取名mfschunk：12$ mkdir -p /mnt/mfschunk$ chown -R mfs:mfs /mnt/mfschunk 在mfshdd.cfg文件中添加一行/mnt/mfschunk。启动mfschunkserver:1$ sudo mfschunkserver start 安装客户端安装客户端，添加挂载点，进行挂载。mfsmaster在这里为master的hostname。123$ sudo apt-get install moosefs-client$ sudo mkdir -p /mnt/mfs$ sudo mfsmount mfs -H mfsmaster 查看：12$ df -hmfsmaster:9421 1.3T 70G 1.2T 6% /mnt/mfs","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://itanch.github.io/tags/ubuntu/"},{"name":"MooseFS","slug":"MooseFS","permalink":"http://itanch.github.io/tags/MooseFS/"}]},{"title":"slurm安装","date":"2015-09-10T09:17:44.000Z","path":"2015/09/10/slurm安装/","text":"说明 Slurm is an open-source workload manager designed for Linux clusters of all sizes. It provides three key functions. First it allocates exclusive and/or non-exclusive access to resources (computer nodes) to users for some duration of time so they can perform work. Second, it provides a framework for starting, executing, and monitoring work (typically a parallel job) on a set of allocated nodes. Finally, it arbitrates contention for resources by managing a queue of pending work. 系统：ubuntu 14.04。slurm版本2.6.5。节点：2个独立的ubuntu14.04计算机。 安装在ubuntu中，最简单的安装方法是使用apt-get，目前自动安装的slurm版本为2.6.5，并不是最新版本。1$ sudo apt-get install slurm-llnl 安装slurm的同时，会自动创建一个蛋疼的slurm用户，但是这个用户没有home文件，所以无法切换到该用户下进行工作。我的建议是删除旧的slurm用户，同时也是为了munge的正确运行做准备。1$ sudo deluser slurm 使用slurm，所有的节点必须在相同的用户下工作，建议新建一个slurm用户，必须指定UID，保证所有节点slurm用户的UID也相同：1$ sudo adduser --uid &lt;ID&gt; &lt;new name&gt; Munge在安装slurm的同时，也会安装munge。 MUNGE (MUNGE Uid ‘N’ Gid Emporium) is an authentication service for creating and validating credentials. It is designed to be highly scalable for use in an HPC cluster environment. It allows a process to authenticate the UID and GID of another local or remote process within a group of hosts having common users and groups. These hosts form a security realm that is defined by a shared cryptographic key. Clients within this security realm can create and validate credentials without the use of root privileges, reserved ports, or platform-specific methods. 1.生成key首先生成key，自动生成至/ete/munge/munge.key：1$ create-munge-key 2.部署将key拷贝至所有节点。拷贝/etc/munge/munge.key到所有节点的/etc/munge/目录下。 3.启动启动munge。1$ sudo /etc/init.d/munge start 出现错误：12* Starting MUNGE munged [fail]munged: Error: Logfile is insecure: group-writable permissions set on \"/var/log\" 出现上述错误需要修改log文件权限：1$ sudo chmod g-w /var/log 出现错误：12* Starting MUNGE munged [fail]munged: Error: Logfile is insecure: invalid ownership of \"/var/log/munge\" 首先尝试使用sudo启动，若不成功，则参考如下。munge安装的所有文件，默认用户为munge:munge，当前用户如果不是munge，启动出现错误：需要修改如下文件的用户：/etc/munge//var/lib/munge//var/log/munge//var/run/munge/修改文件用户的命令：1$ sudo chown -R &lt;user&gt;:&lt;group&gt; &lt;dir&gt; 修改/ete/init.d/munge，将USER变量修改为你的用户名。 4.验证在slurm用户下验证本机：123456789101112$ munge -n | unmungeSTATUS: Success (0)ENCODE_HOST: localhost (127.0.0.1)ENCODE_TIME: 2015-09-14 16:39:58 +0800 (1442219998)DECODE_TIME: 2015-09-14 16:39:58 +0800 (1442219998)TTL: 300CIPHER: aes128 (4)MAC: sha1 (3)ZIP: none (0)UID: slurm (1023)GID: slurm (1023)LENGTH: 0 验证其它节点：123456789101112$ munge -n | ssh node01 unmungeSTATUS: Success (0)ENCODE_HOST: localhost (127.0.0.1)ENCODE_TIME: 2015-09-14 16:40:09 +0800 (1442220009)DECODE_TIME: 2015-09-14 16:39:49 +0800 (1442219989)TTL: 300CIPHER: aes128 (4)MAC: sha1 (3)ZIP: none (0)UID: slurm (1023)GID: slurm (1023)LENGTH: 0 注意！munge自动认证的是相同的用户，即UID和GID相同，并不是按照用户名称来匹配，所以在创建slurm用户时必须指定相同的UID和GID。 slurm配置文件在安装文件中有配置工具：slurm-xxx/doc/html/configurator.html.in如果使用apt-get安装，则需要根据自己slurm的版本信息下载相应的tar文件，解压后使用，slurm所有版本。 配置文件样例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162# slurm.conf file generated by configurator.html.# Put this file on all nodes of your cluster.# See the slurm.conf man page for more information.#ControlMachine=node00#ControlAddr=#BackupController=#BackupAddr=#AuthType=auth/mungeCacheGroups=0#CheckpointType=checkpoint/noneCryptoType=crypto/munge#DisableRootJobs=NO#EnforcePartLimits=NO#Epilog=#EpilogSlurmctld=#FirstJobId=1#MaxJobId=999999#GresTypes=#GroupUpdateForce=0#GroupUpdateTime=600#JobCheckpointDir=/var/slurm/checkpoint#JobCredentialPrivateKey=#JobCredentialPublicCertificate=#JobFileAppend=0#JobRequeue=1#JobSubmitPlugins=1#KillOnBadExit=0#LaunchType=launch/slurm#Licenses=foo*4,bar#MailProg=/bin/mail#MaxJobCount=5000#MaxStepCount=40000#MaxTasksPerNode=128MpiDefault=none#MpiParams=ports=#-##PluginDir=#PlugStackConfig=#PrivateData=jobsProctrackType=proctrack/pgid#Prolog=#PrologSlurmctld=#PropagatePrioProcess=0#PropagateResourceLimits=#PropagateResourceLimitsExcept=#RebootProgram=ReturnToService=1#SallocDefaultCommand=SlurmctldPidFile=/var/run/slurmctld.pidSlurmctldPort=6817SlurmdPidFile=/var/run/slurmd.pidSlurmdPort=6818SlurmdSpoolDir=/home/slurm/SlurmSlurmUser=slurm#SlurmdUser=root#SrunEpilog=#SrunProlog=StateSaveLocation=/home/slurm/Slurm/outSwitchType=switch/none#TaskEpilog=TaskPlugin=task/none#TaskPluginParam=#TaskProlog=#TopologyPlugin=topology/tree#TmpFS=/tmp#TrackWCKey=no#TreeWidth=#UnkillableStepProgram=#UsePAM=0### TIMERS#BatchStartTimeout=10#CompleteWait=0#EpilogMsgTime=2000#GetEnvTimeout=2#HealthCheckInterval=0#HealthCheckProgram=InactiveLimit=30KillWait=30#MessageTimeout=10#ResvOverRun=0MinJobAge=300#OverTimeLimit=0SlurmctldTimeout=120SlurmdTimeout=300#UnkillableStepTimeout=60#VSizeFactor=0Waittime=300### SCHEDULING#DefMemPerCPU=0FastSchedule=1#MaxMemPerCPU=0#SchedulerRootFilter=1#SchedulerTimeSlice=30SchedulerType=sched/backfillSchedulerPort=7321SelectType=select/linear#SelectTypeParameters=### JOB PRIORITY#PriorityFlags=#PriorityType=priority/basic#PriorityDecayHalfLife=#PriorityCalcPeriod=#PriorityFavorSmall=#PriorityMaxAge=#PriorityUsageResetPeriod=#PriorityWeightAge=#PriorityWeightFairshare=#PriorityWeightJobSize=#PriorityWeightPartition=#PriorityWeightQOS=### LOGGING AND ACCOUNTING#AccountingStorageEnforce=0#AccountingStorageHost=#AccountingStorageLoc=#AccountingStoragePass=#AccountingStoragePort=AccountingStorageType=accounting_storage/none#AccountingStorageUser=AccountingStoreJobComment=YESClusterName=cluster#DebugFlags=#JobCompHost=#JobCompLoc=#JobCompPass=#JobCompPort=JobCompType=jobcomp/none#JobCompUser=JobAcctGatherFrequency=30JobAcctGatherType=jobacct_gather/noneSlurmctldDebug=3#SlurmctldLogFile=SlurmdDebug=3#SlurmdLogFile=#SlurmSchedLogFile=#SlurmSchedLogLevel=### POWER SAVE SUPPORT FOR IDLE NODES (optional)#SuspendProgram=#ResumeProgram=#SuspendTimeout=#ResumeTimeout=#ResumeRate=#SuspendExcNodes=#SuspendExcParts=#SuspendRate=#SuspendTime=### COMPUTE NODESNodeName=node01 CPUs=1 State=UNKNOWNNodeName=node00 CPUs=1 State=UNKNOWNPartitionName=debug Nodes=node00,node01 Default=YES MaxTime=INFINITE State=UP 将该配置文件拷贝至所有节点，放置于/etc/slurm-llnl/slurm.conf中。 启动和测试slurm到所有节点中启动：1$ sudo /ete/init.d/slurm-llnl start 查看节点信息：1$ sinfo 测试脚本test：12345678910#!/bin/bash#SBATCH -A &lt;account&gt;#SBATCH -D /home/slurm/Slurm#SBATCH -I#SBATCH --time=00:30:00#SBATCH --error=job.%J.err#SBATCH --output=job.%J.outecho \"hello world!\"./hello.sh 运行测试脚本:1$ sbatch test 当某一个job因为某些I/O原因阻塞以后，会导致某个节点一直处于comp状态，重启该节点可以使用如下命令：12$ scontrol update NodeName=OptiPlex State=DOWN Reason=hung_completing$ scontrol update NodeName=OptiPlex State=RESUME","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://itanch.github.io/tags/ubuntu/"},{"name":"slurm","slug":"slurm","permalink":"http://itanch.github.io/tags/slurm/"}]},{"title":"豆瓣电影Top250获取","date":"2015-08-29T12:53:09.000Z","path":"2015/08/29/豆瓣电影Top250获取/","text":"豆瓣API说明豆瓣为开发者提供了用于应用开发的Api接口，通过这些Api接口可以获得豆瓣的部分内容。 豆瓣Api V2认证使用了OAuth2，使得用户的授权过程更为安全，返回数据的格式为json，便于应用开发者解析获得的数据。豆瓣没有提供官方的SDK，但是提供了其他非官方的基于多种语言的SDK，我们采用了Java语言的SDK。由于该版本的Java SDK基于较早的豆瓣API的v1版本，所以需要进行部分修改适应新的v2版本，其中我们修改了电影相关的代码(新的源代码)。 Java SDK为Maven工程，可以使用Maven编译打包： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273mvn package -Dmaven.test.skip=true``` 为了将所有依赖一起打包进去，我们使用了fatjar工具进行打包，生成可以调用的函数库([jar](https://github.com/ITanCh/Douban-Java-SDK-OAuth2/raw/origin/Douban-Java-SDK-OAuth2-origin_fat.jar))。&lt;!--more--&gt;### API使用#### 相关库```javaimport com.dongxuexidu.douban4j.model.app.AccessToken;import com.dongxuexidu.douban4j.model.app.DoubanException;import com.dongxuexidu.douban4j.model.app.RequestGrantScope;import com.dongxuexidu.douban4j.model.v2.DoubanCastObject;import com.dongxuexidu.douban4j.model.v2.DoubanDirectorObj;import com.dongxuexidu.douban4j.model.v2.DoubanSubjectListObj;import com.dongxuexidu.douban4j.model.v2.DoubanSubjectObj;import com.dongxuexidu.douban4j.playground.BrowserLauncher;import com.dongxuexidu.douban4j.playground.PlayGround;import com.dongxuexidu.douban4j.provider.OAuthDoubanProvider;import com.dongxuexidu.douban4j.service.DoubanBookMovieMusicService;``` #### AccessToken获取 通过豆瓣API获取用户相关的信息时需要获取AccessToken，在Java中可以实现如下：```javapublic static String testAccessToken() &#123; try &#123; OAuthDoubanProvider oauth = new OAuthDoubanProvider(); oauth.setApiKey(&quot;your api key&quot;).setSecretKey( &quot;your secret key&quot;); oauth.addScope(RequestGrantScope.BASIC_COMMON_SCOPE) .addScope(RequestGrantScope.SHUO_READ_SCOPE) .addScope(RequestGrantScope.SHUO_WRITE_SCOPE) .addScope(RequestGrantScope.BASIC_NOTE_SCOPE) .addScope(RequestGrantScope.BOOK_READ_SCOPE) .addScope(RequestGrantScope.EVENT_READ_SCOPE) .addScope(RequestGrantScope.EVENT_WRITE_SCOPE) .addScope(RequestGrantScope.MAIL_READ_SCOPE) .addScope(RequestGrantScope.MAIL_WRITE_SCOPE) .addScope(RequestGrantScope.MOVIE_READ_SCOPE) .addScope(RequestGrantScope.MUSIC_READ_SCOPE); oauth.setRedirectUrl(&quot;http://www.liutianchi.com&quot;); BrowserLauncher.openURL(oauth.getGetCodeRedirectUrl()); System.out.println(oauth.getGetCodeRedirectUrl()); System.out.print(&quot;Put the code you got here.[Enter]:&quot;); BufferedReader br = new BufferedReader(new InputStreamReader( System.in)); String code = br.readLine(); System.out.println(&quot;code : &quot; + code); AccessToken at = oauth.tradeAccessTokenWithCode(code); System.out.println(&quot;at : &quot; + at.getAccessToken()); System.out.println(&quot;uid : &quot; + at.getDoubanUserId()); return at.getAccessToken(); &#125; catch (DoubanException ex) &#123; Logger.getLogger(PlayGround.class.getName()).log(Level.SEVERE, null, ex); return null; &#125; catch (IOException ex) &#123; Logger.getLogger(PlayGround.class.getName()).log(Level.SEVERE, null, ex); return null; &#125; &#125;``` 获取电影Top250的基本信息不涉及用户内容，所以不必获取AccessToken。 #### 获取Top250电影ID 虽然豆瓣提供了获取Top250的API： /v2/movie/top25012但是，通过上述方法获取的电影信息为简单内容，其中演员数为3，无电影的国家信息，无电影内容简介。这些内容无法达到我们数据分析的目的，所以我们首先统计出Top250的ID，然后使用如下API获取每一部电影的详细信息: /v2/movie/subject/:id123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204豆瓣限制了一次获取Top250的电影数目最大为100，所以需要进行3次请求。代码实现如下： ```javapublic static void getTop250ID() &#123; DoubanBookMovieMusicService instance = new DoubanBookMovieMusicService(); DoubanSubjectListObj results = null; try &#123; File dirFile = new File(FILEPATH); dirFile.mkdirs(); File idFile = new File(dirFile, &quot;movie_id&quot;); if (!idFile.exists()) idFile.createNewFile(); BufferedWriter out = new BufferedWriter(new FileWriter(idFile, false)); int start = 0; while (start &lt; 300) &#123; boolean flag = true; while (flag) &#123; try &#123; results = instance.getMoviesTop250(start, 100); flag = false; &#125; catch (NoHttpResponseException e) &#123; System.out.println(&quot;NoHttpResponseException&quot;); Thread.sleep(1000); &#125; &#125; List&lt;DoubanSubjectObj&gt; movieList = results.getSubjects(); for (DoubanSubjectObj result : movieList) &#123; out.write(result.getId()); out.newLine(); &#125; start += 100; Thread.sleep(1000); &#125; out.write(&quot;#&quot;); out.flush(); out.close(); &#125; catch (DoubanException | IOException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;``` 如下所示为Top250的部分ID: 1292052 1295644 1292720 1291546 1292063 1292001 1295124 1291561#### 获取每一部电影的信息 代码实现如下：```javapublic static void getTop250Info() &#123; File dirFile = new File(FILEPATH); File idFile = new File(dirFile, &quot;movie_id&quot;); if (!idFile.exists()) &#123; System.err.println(&quot;movie id file not exist!&quot;); return; &#125; LinkedHashSet&lt;String&gt; castSet = new LinkedHashSet&lt;&gt;(); LinkedHashSet&lt;String&gt; dirSet = new LinkedHashSet&lt;&gt;(); BufferedWriter writer; BufferedReader reader; try &#123; File mvFile = new File(dirFile, &quot;movie_info&quot;); if (!mvFile.exists()) mvFile.createNewFile(); writer = new BufferedWriter(new FileWriter(mvFile, false)); reader = new BufferedReader(new FileReader(idFile)); DoubanBookMovieMusicService instance = new DoubanBookMovieMusicService(); DoubanSubjectObj result = null; String id = &quot;&quot;; int count = 0; while (true) &#123; id = reader.readLine(); if (id == null || id.equals(&quot;#&quot;)) break; count++; System.out.println(count + &quot;: &quot; + id); long l = Long.parseLong(id); boolean flag = true; while (flag) &#123; try &#123; result = instance.getV2MovieInfoById(l); flag = false; &#125; catch (NoHttpResponseException | SocketTimeoutException e) &#123; System.out.println(&quot;NoHttpResponseException&quot;); Thread.sleep(2000); &#125; &#125; writer.write(result.getId() + &quot; &quot;); writer.write(result.getTitle() + &quot; &quot;); writer.write(result.getRating().getAverage() + &quot; &quot;); List&lt;DoubanCastObject&gt; castList = result.getCasts(); boolean first = true; for (DoubanCastObject cast : castList) &#123; if (!first) writer.write(&quot;#&quot;); writer.write(cast.getId()); castSet.add(cast.getId()); first = false; &#125; writer.write(&quot; &quot;); List&lt;DoubanDirectorObj&gt; dirList = result.getDirectors(); first = true; for (DoubanDirectorObj dir : dirList) &#123; if (!first) writer.write(&quot;#&quot;); writer.write(dir.getId()); dirSet.add(dir.getId()); first = false; &#125; writer.write(&quot; &quot;); List&lt;String&gt; strList = result.getCountries(); first = true; for (String str : strList) &#123; if (!first) writer.write(&quot;#&quot;); writer.write(str); first = false; &#125; writer.write(&quot; &quot;); strList = result.getGenres(); first = true; for (String str : strList) &#123; if (!first) writer.write(&quot;#&quot;); writer.write(str); first = false; &#125; writer.write(&quot; &quot; + result.getYear()); writer.newLine(); writer.flush(); Thread.sleep(3000); &#125; reader.close(); writer.close(); System.out.println(&quot;Get movie !&quot;); File castIdFile = new File(dirFile, &quot;cast_id&quot;); if (!castIdFile.exists()) castIdFile.createNewFile(); BufferedWriter castIdWriter = new BufferedWriter(new FileWriter( castIdFile, true)); Iterator&lt;String&gt; it = castSet.iterator(); while (it.hasNext()) &#123; castIdWriter.write(it.next()); castIdWriter.newLine(); &#125; castIdWriter.write(&quot;#&quot;); castIdWriter.flush(); castIdWriter.close(); File dirIdFile = new File(dirFile, &quot;dir_id&quot;); if (!dirIdFile.exists()) dirIdFile.createNewFile(); BufferedWriter dirIdWriter = new BufferedWriter(new FileWriter( dirIdFile, true)); it = dirSet.iterator(); while (it.hasNext()) &#123; dirIdWriter.write(it.next()); dirIdWriter.newLine(); &#125; dirIdWriter.write(&quot;#&quot;); dirIdWriter.flush(); dirIdWriter.close(); &#125; catch (IOException | DoubanException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 在获取电影信息时，我们同时利用哈希集统计了演员的ID和导演的ID，目的是为了进一步统计影人的具体信息。 在这里需要注意的是，豆瓣为了防止恶意访问，对每分钟请求的次数进行了限制，官方文档说为40次/分钟，经过实验发现，这个时间并不准确，最后我们采用3s一次的请求进行了连续的访问。如果请求次数过度频繁，则会出现警告页面，同时导致在该IP下若干小时内无法继续访问。 最后获取的电影信息部分结果如下所示(id，名称，平分，演员id集合，导演id集合，国家，标签集合，发行年份)： 1292052 肖申克的救赎 9.6 1054521#1054534#1041179#1000095 1047973 美国 犯罪#剧情 1994 1295644 这个杀手不太冷 9.4 1025182#1054454#1010507#1019050 1031876 法国 剧情#动作#犯罪 1994 1292720 阿甘正传 9.4 1054450#1002676#1031848#1031912 1053564 美国 剧情#爱情 1994 1291546 霸王别姬 9.4 1003494#1050265#1035641#1000905 1023040 中国大陆#香港 剧情#爱情#同性 1993 1292063 美丽人生 9.4 1041004#1000375#1000368#1082051 1041004 意大利 剧情#战争 1997 1292001 海上钢琴师 9.2 1025176#1010659#1027407#1009391 1018983 意大利 剧情#音乐 1998 1295124 辛德勒的名单 9.4 1031220#1054393#1006956#1041165 1054440 美国 剧情#历史#战争 1993 1291561 千与千寻 9.2 1023337#1005438#1045797#1025558 1054439 日本 剧情#动画#奇幻 2001 2131459 机器人总动员 9.3 1009535#1000389#1018022#1049585 1036450 美国 喜剧#爱情#科幻 2008 1292722 泰坦尼克号 9.1 1041029#1054446#1031864#1010555 1022571 美国 剧情#爱情#灾难 1997 3541415 盗梦空间 9.2 1041029#1101703#1012520#1027181 1054524 美国#英国 剧情#动作#科幻 2010 3793023 三傻大闹宝莱坞 9.1 1031931#1049635#1018290#1032430 1286677 印度 剧情#喜剧#爱情 2009 其中所有的演员和导演的信息用豆瓣赋予的ID表示，ID是豆瓣采用的唯一标示影人的序号。由于豆瓣提供的电影信息内容不完全规范，同一个影人可能在不同电影中使用了不同的名字，例如名字拼写、翻译不同，所以采用ID而不是影人的名字来进行数据分析。 获取影人信息因为需要对男女演员进行分别统计，所以我们对影人的详细信息又进行了获取，代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static void getCastInfo() &#123; File dirFile = new File(FILEPATH); File idFile = new File(dirFile, \"dir_id\"); if (!idFile.exists()) &#123; System.err.println(\"cast id file not exist!\"); return; &#125; BufferedWriter writer; BufferedReader reader; try &#123; File infoFile = new File(dirFile, \"dir_info\"); if (!infoFile.exists()) infoFile.createNewFile(); writer = new BufferedWriter(new FileWriter(infoFile, false)); reader = new BufferedReader(new FileReader(idFile)); DoubanBookMovieMusicService instance = new DoubanBookMovieMusicService(); DoubanCastObject result = null; String id = \"\"; int count = 0; while (true) &#123; id = reader.readLine(); if (id == null || id.equals(\"#\")) break; count++; System.out.println(count + \": \" + id); boolean flag = true; while (flag) &#123; try &#123; result = instance.getMoviesCast(id); flag = false; &#125; catch (NoHttpResponseException | SocketTimeoutException e) &#123; System.out.println(\"NoHttpResponseException\"); Thread.sleep(2000); &#125; &#125; writer.write(result.getId() + \" \"); writer.write(result.getName() + \" \"); writer.write(result.getGender()); writer.newLine(); writer.flush(); Thread.sleep(4000); &#125; reader.close(); writer.close(); System.out.println(\"Get movie !\"); &#125; catch (IOException | DoubanException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 获取的部分演员信息如下(id，名字，性别)： 1054521 蒂姆·罗宾斯 男 1054534 摩根·弗里曼 男 1041179 鲍勃·冈顿 男 1000095 威廉姆·赛德勒 男 1025182 让·雷诺 男 1054454 娜塔莉·波特曼 女 1010507 加里·奥德曼 男 1019050 丹尼·爱罗 男 1054450 汤姆·汉克斯 男 1002676 罗宾·怀特 女 1031848 加里·西尼斯 男 1031912 麦凯尔泰·威廉逊 男 1003494 张国荣 男 1050265 张丰毅 男 1035641 巩俐 女 获取的导演信息如下： 1047973 弗兰克·德拉邦特 男 1031876 吕克·贝松 男 1053564 罗伯特·泽米吉斯 男 1023040 陈凯歌 男 1041004 罗伯托·贝尼尼 男 1018983 朱塞佩·托纳多雷 男 1054440 史蒂文·斯皮尔伯格 男 1054439 宫崎骏 男 数据完善需要注意的是，获取的源数据形式并不规范，影人的名字格式多样，有的影人没有性别信息，所以对源数据进行过滤修正。","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"豆瓣","slug":"豆瓣","permalink":"http://itanch.github.io/tags/豆瓣/"},{"name":"电影","slug":"电影","permalink":"http://itanch.github.io/tags/电影/"}]},{"title":"ubuntu14.04基本配置","date":"2015-08-06T03:59:57.000Z","path":"2015/08/06/ubuntu14-04基本配置/","text":"更新：12$ sudo apt-get update $ sudo apt-get upgrade 安装搜狗输入法：123$ sudo add-apt-repository ppa:fcitx-team/nightly #添加fcitx源$ sudo apt-get install fcitx #下载搜狗输入法双击安装 安装JDK：123456789101112#下载最近的jdk包 $ sudo mv jdk.tar.gz /usr/lib/jvm/ $ cd /usr/lib/jvm/ $ sudo tar -zxvf jdk.tar.gz $ sudo rm jdk.tar.gz $ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk/bin/java 300 $ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk/bin/javac 300#选择默认java库$ sudo update-alternatives --config java $ java -version #测试 安装Eclispe123456789101112131415161718192021#下载最新的elipse包 $ sudo mv eclipse.tar.gz /opt/$ cd /opt/$ sudo tar -zxvf eclipse.tar.gz$ sudo rm eclipse.tar.gz#若想从命令行启动 $ sudo ln -sf /opt/eclipse/eclipse /usr/bin#创建桌面图标 $ sudo vi /usr/share/applications/eclipse.desktop#添加如下内容 [Desktop Entry]Type=ApplicationName=EclipseComment=Eclipse Integrated Development EnvironmentIcon=/opt/eclipse/icon.xpmExec=eclipseTerminal=falseCategories=Development;IDE;Java; 配置Android SDK:1234567891011121314151617181920#从官网下载最新的SDK#将文件解压到目标文件夹/opt/$ cd /opt/android-sdk/tools$ sudo ./android #运行Android SDK Manager,下载platfor-tools和bulid-tools$ sudo chmod 777 android-sdk #修改所有文件的权限,使之可以运行#64位的ubuntu 13.10及以上版本需要安装32位相关的库$ sudo dpkg --add-architecture i386$ sudo apt-get update$ sudo apt-get install libncurses5:i386 libstdc++6:i386 zlib1g:i386$ sudo vi /ect/profile #添加如下内容export PATH=/opt/android-sdk-linux/platform-tools:$PATH export PATH=/opt/android-sdk-linux/tools:$PATH$ source /ect/profile Firefox Flash插件123456#下载最新的Flash Player$ tar -zxvf flash.tar.gz#获取flashplayer.so$ sudo cp libflashplayer.so /usr/lib/mozilla/plugins 常用命令 取消某个软件(tomcat)开机自启动。 1sudo update-rc.d tomcat disable","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://itanch.github.io/tags/ubuntu/"}]},{"title":"Torque安装笔记(多ubuntu节点)","date":"2015-08-06T03:59:57.000Z","path":"2015/08/06/Torque学习笔记/","text":"1.实验系统ubuntu14.04。更新系统软件，防止相关软件版本过低 12sudo apt-get update sudo apt-get upgrade 2.从官网下载Torque，在这里为Torque 5.1.1。 3.解压文件 1tar -xzvf torque.tar.gz 4.运行configure，可加prefix指定Torque命令安装位置，也可不加，不加参数命令默认装在/usr/local/bin和/usr/local/sbin下。利用configure可以检测依赖软件，按照提示安装这些软件。 1./configure --prefix=/usr/local/torque 5.编译安装 12make make install 6.生成子节点安装包，mom和clients为需要拷贝的文件。需要安装ssh，ubuntu默认安装openssh-client，所以需要手动再安装openssh-server，让其他计算机登陆。 1234make packagesscp tpackages name@ip:dir #非必要scp torque-package-mom-linux-x86_64.sh name@ip:dir scp torque-package-clients-linux-x86_64.sh name@ip:dir 7.在子节点上安装，mom和clients。 12sudo ./torque-package-mom-linux-x86_64.sh --installsudo ./torque-package-clients-linux-x86_64.sh --install 8.配置主节 将/usr/local/torque/bin和/usr/local/torque/sbin添加进环境变量，这里我将其添加入.bashrc文件。 12345678export PATH=$PATH:/usr/local/torque/bin:/usr/local/torque/sbin ``` + 添加共享库到Torque的配置文件中（如果出现有什么库找不到，则必须加上） ```shecho '/usr/local/lib' &gt; /etc/ld.so.conf.d/torque.confldconfig 添加主节点名字： 1234567echo 主节点名字 &gt; /var/spool/torque/server_name ``` + 初始化serverdb文件，在使用pbs_sever之前必须完成该步骤：```sh./torque.setup 用户名 添加子节点，np为节点cpu核个数 vi /var/spool/torque/server_priv/nodes子节点的名字为计算机名，而非用户名。每次添加节点需要重启pbs_sever。添加如下内容（也可以先在子节点启动mom，在主节点启动server，然后用命令qmgr -c &#39;create node ubuntu np=4&#39;进行添加节点）：12子节点1名字 np=4 子节点2名字 np=4 启动 123pbs_serverpbs_sched pbs_mom 9.配置子节点，同样需要添加环境变量。 修改config使用make packages 命令生成mom安装于子节点的，无需进行这一步。 1234 vi /var/spool/torque/mom_priv/config 添加： pbsserver 主节点名称 logevent 255 启动： 1pbs_mom 10.注意！因为配置文件中使用了主节点名称和子节点名称，所以主、从节点都需要修改 12/etc/hosts 添加这些名称和对应的ip 11.检查运行情况保证在server上运行trqauthd、pbs_server、pbs_sched这三个程序。保证在子节点上运行pbs_mom。 12.常用命令pbsnodes: 子节点信息。qterm: 结束pbs_server。qsub: 提交job。qstat: job运行信息。 13.测试：注意！在提交Job时，需要主节点和子节点为相同的用户名，同时保证操作的文件目录也相同。12echo \"sleep 300\" | qsub qstat","tags":[{"name":"技术","slug":"技术","permalink":"http://itanch.github.io/tags/技术/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://itanch.github.io/tags/ubuntu/"},{"name":"Torque","slug":"Torque","permalink":"http://itanch.github.io/tags/Torque/"}]},{"title":"Hello World","date":"2015-07-31T23:33:44.000Z","path":"2015/08/01/hello/","text":"Tianchi’s Blog今天诞生了！ 夫君子之行，静以修身，俭以养德。非澹泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！","tags":[{"name":"记录","slug":"记录","permalink":"http://itanch.github.io/tags/记录/"}]}]